{"version":3,"file":"imageService-ySMyxaQp.js","sources":["../../src/utils/imageUtils.ts","../../src/services/imageService.ts"],"sourcesContent":["import { TransactionImage } from '@/types'\n\nexport interface ImageValidationResult {\n  isValid: boolean\n  error?: string\n}\n\nexport interface ImageCompressionOptions {\n  maxWidth?: number\n  maxHeight?: number\n  quality?: number\n  format?: 'jpeg' | 'png' | 'webp'\n  maxSizeKB?: number\n}\n\nexport interface EXIFData {\n  make?: string\n  model?: string\n  datetime?: string\n  orientation?: number\n  width?: number\n  height?: number\n  [key: string]: any\n}\n\n/**\n * Validates an image file for upload\n */\nexport function validateImageFile(file: File): ImageValidationResult {\n  // Check file type\n  const allowedTypes = [\n    'image/jpeg',\n    'image/jpg',\n    'image/png',\n    'image/gif',\n    'image/webp',\n    'image/bmp',\n    'image/tiff'\n  ]\n\n  if (!allowedTypes.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Invalid file type. Please upload one of: ${allowedTypes.join(', ')}`\n    }\n  }\n\n  // Check file size (25MB limit for high-quality receipts)\n  const maxSize = 25 * 1024 * 1024 // 25MB\n  if (file.size > maxSize) {\n    return {\n      isValid: false,\n      error: 'File too large. Maximum size: 25MB'\n    }\n  }\n\n  // Check minimum size\n  const minSize = 1024 // 1KB\n  if (file.size < minSize) {\n    return {\n      isValid: false,\n      error: 'File too small. Minimum size: 1KB'\n    }\n  }\n\n  return { isValid: true }\n}\n\n/**\n * Compresses an image file to reduce size while maintaining quality\n */\nexport function compressImage(\n  file: File,\n  options: ImageCompressionOptions = {}\n): Promise<File> {\n  const {\n    maxWidth = 1920,\n    maxHeight = 1080,\n    quality = 0.85,\n    format = 'jpeg',\n    maxSizeKB = 2048\n  } = options\n\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      // Calculate new dimensions\n      let { width, height } = img\n\n      if (width > maxWidth || height > maxHeight) {\n        const ratio = Math.min(maxWidth / width, maxHeight / height)\n        width *= ratio\n        height *= ratio\n      }\n\n      canvas.width = width\n      canvas.height = height\n\n      // Draw image\n      ctx?.drawImage(img, 0, 0, width, height)\n\n      // Convert to blob with compression\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            let compressedFile = new File([blob], file.name, {\n              type: `image/${format}`,\n              lastModified: Date.now()\n            })\n\n            // If still too large, compress further\n            if (blob.size > maxSizeKB * 1024) {\n              // Reduce quality and try again\n              canvas.toBlob(\n                (blob2) => {\n                  if (blob2) {\n                    compressedFile = new File([blob2], file.name, {\n                      type: `image/${format}`,\n                      lastModified: Date.now()\n                    })\n                  }\n                  resolve(compressedFile)\n                },\n                `image/${format}`,\n                quality * 0.7\n              )\n            } else {\n              resolve(compressedFile)\n            }\n          } else {\n            reject(new Error('Failed to compress image'))\n          }\n        },\n        `image/${format}`,\n        quality\n      )\n    }\n\n    img.onerror = () => reject(new Error('Failed to load image for compression'))\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Resizes an image to specific dimensions\n */\nexport function resizeImage(\n  file: File,\n  targetWidth: number,\n  targetHeight: number,\n  maintainAspectRatio: boolean = true\n): Promise<File> {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      let { width, height } = img\n\n      if (maintainAspectRatio) {\n        const ratio = Math.min(targetWidth / width, targetHeight / height)\n        width *= ratio\n        height *= ratio\n      } else {\n        width = targetWidth\n        height = targetHeight\n      }\n\n      canvas.width = targetWidth\n      canvas.height = targetHeight\n\n      // Clear canvas with white background\n      if (ctx) {\n        ctx.fillStyle = '#FFFFFF'\n        ctx.fillRect(0, 0, targetWidth, targetHeight)\n      }\n\n      // Draw and resize image\n      ctx?.drawImage(img, 0, 0, targetWidth, targetHeight)\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            const resizedFile = new File([blob], file.name, {\n              type: file.type,\n              lastModified: Date.now()\n            })\n            resolve(resizedFile)\n          } else {\n            reject(new Error('Failed to resize image'))\n          }\n        },\n        file.type,\n        0.9\n      )\n    }\n\n    img.onerror = () => reject(new Error('Failed to load image for resizing'))\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Converts an image to a different format\n */\nexport function convertImageFormat(\n  file: File,\n  targetFormat: 'jpeg' | 'png' | 'webp',\n  quality: number = 0.9\n): Promise<File> {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      canvas.width = img.width\n      canvas.height = img.height\n\n      // Draw image\n      ctx?.drawImage(img, 0, 0)\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            const newName = file.name.replace(/\\.[^.]+$/, `.${targetFormat}`)\n            const convertedFile = new File([blob], newName, {\n              type: `image/${targetFormat}`,\n              lastModified: Date.now()\n            })\n            resolve(convertedFile)\n          } else {\n            reject(new Error('Failed to convert image format'))\n          }\n        },\n        `image/${targetFormat}`,\n        quality\n      )\n    }\n\n    img.onerror = () => reject(new Error('Failed to load image for format conversion'))\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Extracts basic EXIF data from an image (simplified implementation)\n * Note: This is a basic implementation. For full EXIF support, consider using a library like exifr\n */\nexport function extractEXIFData(file: File): Promise<EXIFData> {\n  return new Promise((resolve) => {\n    const img = new Image()\n\n    img.onload = () => {\n      const exifData: EXIFData = {\n        width: img.naturalWidth,\n        height: img.naturalHeight,\n        orientation: 1\n      }\n      resolve(exifData)\n    }\n\n    img.onerror = () => resolve({\n      width: 0,\n      height: 0,\n      orientation: 1\n    })\n\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Applies EXIF orientation to correctly rotate the image\n */\nexport function applyEXIFOrientation(file: File, orientation: number): Promise<File> {\n  if (orientation === 1) {\n    return Promise.resolve(file) // No rotation needed\n  }\n\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      let { width, height } = img\n\n      // Apply transformations based on orientation\n      switch (orientation) {\n        case 3:\n        case 4:\n          // 180 degrees\n          ctx?.translate(width, height)\n          ctx?.rotate(Math.PI)\n          break\n        case 5:\n        case 6:\n          // 90 degrees clockwise\n          canvas.width = height\n          canvas.height = width\n          ctx?.translate(height, 0)\n          ctx?.rotate(Math.PI / 2)\n          ;[width, height] = [height, width]\n          break\n        case 7:\n        case 8:\n          // 90 degrees counter-clockwise\n          canvas.width = height\n          canvas.height = width\n          ctx?.translate(0, width)\n          ctx?.rotate(-Math.PI / 2)\n          ;[width, height] = [height, width]\n          break\n      }\n\n      ctx?.drawImage(img, 0, 0)\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            const correctedFile = new File([blob], file.name, {\n              type: file.type,\n              lastModified: Date.now()\n            })\n            resolve(correctedFile)\n          } else {\n            reject(new Error('Failed to apply EXIF orientation'))\n          }\n        },\n        file.type,\n        0.9\n      )\n    }\n\n    img.onerror = () => reject(new Error('Failed to load image for orientation correction'))\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Creates a thumbnail from an image\n */\nexport function createThumbnail(file: File, size: number = 150): Promise<File> {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const img = new Image()\n\n    img.onload = () => {\n      const { width, height } = img\n      const ratio = Math.min(size / width, size / height)\n\n      canvas.width = width * ratio\n      canvas.height = height * ratio\n\n      ctx?.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            const thumbnailName = file.name.replace(/\\.[^.]+$/, '_thumb.jpg')\n            const thumbnailFile = new File([blob], thumbnailName, {\n              type: 'image/jpeg',\n              lastModified: Date.now()\n            })\n            resolve(thumbnailFile)\n          } else {\n            reject(new Error('Failed to create thumbnail'))\n          }\n        },\n        'image/jpeg',\n        0.8\n      )\n    }\n\n    img.onerror = () => reject(new Error('Failed to load image for thumbnail creation'))\n    img.src = URL.createObjectURL(file)\n  })\n}\n\n/**\n * Formats file size for display\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes'\n  const k = 1024\n  const sizes = ['Bytes', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return (bytes / Math.pow(k, i)).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' ' + sizes[i]\n}\n\n/**\n * Calculates the estimated compressed size of an image\n */\nexport function estimateCompressedSize(\n  originalSize: number,\n  quality: number = 0.8,\n  format: 'jpeg' | 'png' | 'webp' = 'jpeg'\n): number {\n  // Rough estimation based on format and quality\n  const formatMultiplier = {\n    jpeg: 0.1 + (1 - quality) * 0.3, // JPEG compression is more effective\n    png: 0.6, // PNG compression is less effective\n    webp: 0.05 + (1 - quality) * 0.25 // WebP is very efficient\n  }\n\n  return Math.round(originalSize * (formatMultiplier[format] || 0.3))\n}\n\n/**\n * Checks if the browser supports a specific image format\n */\nexport function supportsImageFormat(format: string): boolean {\n  const canvas = document.createElement('canvas')\n  return canvas.toDataURL(`image/${format}`).indexOf(`image/${format}`) === 5\n}\n\n/**\n * Gets the optimal image format supported by the browser\n */\nexport function getOptimalImageFormat(): 'webp' | 'jpeg' | 'png' {\n  if (supportsImageFormat('webp')) return 'webp'\n  if (supportsImageFormat('jpeg')) return 'jpeg'\n  return 'png'\n}\n\n/**\n * Converts TransactionImage array to a more compact format for storage/transmission\n */\nexport function serializeTransactionImages(images: TransactionImage[]): any[] {\n  return images.map(img => ({\n    url: img.url,\n    fileName: img.fileName,\n    uploadedAt: img.uploadedAt.toISOString(),\n    size: img.size,\n    mimeType: img.mimeType\n  }))\n}\n\n/**\n * Converts serialized transaction images back to TransactionImage objects\n */\nexport function deserializeTransactionImages(images: any[]): TransactionImage[] {\n  return images.map(img => ({\n    url: img.url,\n    fileName: img.fileName,\n    uploadedAt: new Date(img.uploadedAt),\n    size: img.size,\n    mimeType: img.mimeType\n  }))\n}\n\n/**\n * Enhanced error handling for image upload operations\n */\nexport class ImageUploadError extends Error {\n  constructor(\n    message: string,\n    public code?: string,\n    public originalError?: any\n  ) {\n    super(message)\n    this.name = 'ImageUploadError'\n  }\n}\n\n/**\n * Creates user-friendly error messages for common upload issues\n */\nexport function getUserFriendlyErrorMessage(error: any): string {\n  if (error instanceof ImageUploadError) {\n    return error.message\n  }\n\n  if (error?.code) {\n    switch (error.code) {\n      case 'storage/unauthorized':\n        return 'You need to sign in to upload images. Please refresh the page and try again.'\n      case 'storage/quota-exceeded':\n        return 'Storage limit reached. Please contact support or delete some old images.'\n      case 'storage/invalid-format':\n        return 'Invalid image format. Please upload JPEG, PNG, GIF, or WebP files only.'\n      case 'storage/retry-limit-exceeded':\n        return 'Upload failed after multiple attempts. Please check your connection and try again.'\n      default:\n        return `Upload failed: ${error.message || 'Unknown error'}. Please try again.`\n    }\n  }\n\n  if (error?.message) {\n    if (error.message.includes('timeout')) {\n      return 'Upload timed out. Please try again with a smaller image or check your connection.'\n    }\n    if (error.message.includes('network') || error.message.includes('offline')) {\n      return 'Network error. Please check your internet connection and try again.'\n    }\n    if (error.message.includes('CORS')) {\n      return 'Access error. Please refresh the page and try again.'\n    }\n    if (error.message.includes('permission') || error.message.includes('auth')) {\n      return 'Permission error. Please sign in and try again.'\n    }\n  }\n\n  return 'Failed to upload image. Please try again.'\n}\n\n/**\n * Determines if an error is retryable\n */\nexport function isRetryableError(error: any): boolean {\n  if (error?.code) {\n    const retryableCodes = [\n      'storage/retry-limit-exceeded',\n      'storage/network-error',\n      'storage/timeout'\n    ]\n    return retryableCodes.includes(error.code)\n  }\n\n  if (error?.message) {\n    const retryableMessages = [\n      'timeout',\n      'network',\n      'offline',\n      'connection'\n    ]\n    return retryableMessages.some(msg => error.message.toLowerCase().includes(msg))\n  }\n\n  return false\n}\n\n/**\n * Gets suggested actions for common errors\n */\nexport function getErrorAction(error: any): string {\n  if (error?.code === 'storage/unauthorized') {\n    return 'Try refreshing the page to sign in again.'\n  }\n  if (error?.code === 'storage/quota-exceeded') {\n    return 'Contact support or delete some old images to free up space.'\n  }\n  if (error?.code === 'storage/invalid-format') {\n    return 'Use JPEG, PNG, GIF, or WebP format images.'\n  }\n  if (error?.message?.includes('network') || error?.message?.includes('timeout')) {\n    return 'Check your internet connection and try again.'\n  }\n  return 'Try again in a few moments.'\n}\n","import {\n  ref,\n  uploadBytesResumable,\n  getDownloadURL,\n  deleteObject,\n  getMetadata\n} from 'firebase/storage'\nimport { storage, ensureAuthenticatedForStorage } from './firebase'\nimport { TransactionImage } from '@/types'\nimport {\n  ImageUploadError,\n  getUserFriendlyErrorMessage\n} from '@/utils/imageUtils'\n\n\nexport interface UploadProgress {\n  loaded: number\n  total: number\n  percentage: number\n}\n\nexport interface ImageUploadResult {\n  url: string\n  fileName: string\n  size: number\n  mimeType: string\n}\n\nexport class ImageUploadService {\n  /**\n   * Check if Firebase Storage is available\n   */\n  static async checkStorageAvailability(): Promise<boolean> {\n    try {\n      if (!storage) {\n        console.error('Firebase Storage not initialized')\n        return false\n      }\n      return true\n    } catch (error) {\n      console.error('Storage availability check failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Ensure user is authenticated before storage operations\n   */\n  static async ensureAuthentication(): Promise<void> {\n    try {\n      // Use the enhanced authentication function that includes proper verification\n      await ensureAuthenticatedForStorage()\n    } catch (error) {\n      console.error('Failed to ensure authentication:', error)\n      throw new Error('Authentication required for storage operations. Please refresh the page and try again.')\n    }\n  }\n\n  /**\n   * Upload an item image to Firebase Storage\n   */\n  static async uploadItemImage(\n    file: File,\n    projectName: string,\n    itemId: string,\n    onProgress?: (progress: UploadProgress) => void,\n    retryCount: number = 0\n  ): Promise<ImageUploadResult> {\n    return this.uploadImageInternal(file, projectName, itemId, 'item_images', onProgress, retryCount)\n  }\n\n  /**\n   * Upload a transaction image to Firebase Storage\n   */\n  static async uploadTransactionImage(\n    file: File,\n    projectName: string,\n    transactionId: string,\n    onProgress?: (progress: UploadProgress) => void,\n    retryCount: number = 0\n  ): Promise<ImageUploadResult> {\n    return this.uploadImageInternal(file, projectName, transactionId, 'transaction_images', onProgress, retryCount)\n  }\n\n  /**\n   * Internal upload method with the new storage structure\n   */\n  private static async uploadImageInternal(\n    file: File,\n    projectName: string,\n    id: string,\n    imageType: 'item_images' | 'transaction_images',\n    onProgress?: (progress: UploadProgress) => void,\n    retryCount: number = 0\n  ): Promise<ImageUploadResult> {\n    const MAX_RETRIES = 3\n\n    console.log(`Upload attempt ${retryCount + 1}/${MAX_RETRIES + 1}`)\n\n    // Ensure authentication is established before storage operations\n    await this.ensureAuthentication()\n\n    // Check storage availability\n    const isStorageAvailable = await this.checkStorageAvailability()\n    if (!isStorageAvailable) {\n      throw new Error('Storage service is not available. Please check your connection and try again.')\n    }\n\n    // Validate and potentially compress file for mobile\n    let processedFile = file\n    if (this.shouldCompressForMobile(file)) {\n      console.log('Compressing file for mobile upload...')\n      processedFile = await this.compressForMobile(file)\n    }\n\n    if (!this.validateImageFile(processedFile)) {\n      throw new Error('Invalid image file. Please upload a valid image (JPEG, PNG, GIF, WebP) under 10MB.')\n    }\n\n    // Generate unique filename with datetime-based structure: {projectName}/{imageType}/{dateTime}/{timestamp}_{sanitizedFileName}\n    const timestamp = Date.now()\n    const sanitizedFileName = processedFile.name.replace(/[^a-zA-Z0-9.-]/g, '_')\n    const sanitizedProjectName = projectName.replace(/[^a-zA-Z0-9-]/g, '_')\n    const dateTime = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -1) // YYYY-MM-DDTHH-MM-SS format\n    const fileName = `${sanitizedProjectName}/${imageType}/${dateTime}/${timestamp}_${sanitizedFileName}`\n\n    console.log('Uploading to path:', fileName, 'Size:', processedFile.size, 'Type:', processedFile.type)\n\n    // Create storage reference\n    const storageRef = ref(storage, fileName)\n\n    try {\n      // Upload with progress tracking using uploadBytesResumable\n      const uploadTask = uploadBytesResumable(storageRef, processedFile);\n\n      if (onProgress) {\n        uploadTask.on('state_changed',\n          (snapshot) => {\n            const progress = {\n              loaded: snapshot.bytesTransferred,\n              total: snapshot.totalBytes,\n              percentage: (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n            }\n            onProgress(progress)\n          },\n          (error) => {\n            console.error('Upload error:', error)\n            if (error.code === 'storage/retry-limit-exceeded' && retryCount < MAX_RETRIES) {\n              console.log(`Retrying upload (${retryCount + 1}/${MAX_RETRIES})...`)\n              // Retry with exponential backoff\n              setTimeout(() => {\n                this.uploadImageInternal(processedFile, projectName, id, imageType, onProgress, retryCount + 1)\n              }, Math.pow(2, retryCount) * 1000)\n            } else {\n              throw new Error('Failed to upload image. Please try again.')\n            }\n          }\n        )\n      }\n\n      // Wait for upload to complete with timeout\n      const snapshot = await Promise.race([\n        uploadTask,\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Upload timeout after 60 seconds')), 60000)\n        )\n      ]) as any\n\n      // Get download URL for authenticated users\n      const downloadURL = await getDownloadURL(snapshot.ref)\n\n      console.log('Upload successful:', downloadURL)\n\n      return {\n        url: downloadURL,\n        fileName: processedFile.name,\n        size: processedFile.size,\n        mimeType: processedFile.type\n      }\n    } catch (error: any) {\n      console.error('Error uploading image:', error)\n\n      // Handle specific Firebase errors\n      if (error.code === 'storage/retry-limit-exceeded' && retryCount < MAX_RETRIES) {\n        console.log(`Retrying upload due to retry limit exceeded (${retryCount + 1}/${MAX_RETRIES})...`)\n        // Wait a bit longer for retry\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 2000))\n        return this.uploadImageInternal(processedFile, projectName, id, imageType, onProgress, retryCount + 1)\n      }\n\n      if (error.message?.includes('timeout') || error.message?.includes('Upload timeout')) {\n        if (retryCount < MAX_RETRIES) {\n          console.log('Upload timed out, retrying with smaller file...')\n          const compressedFile = await this.compressForMobile(processedFile)\n          return this.uploadImageInternal(compressedFile, projectName, id, imageType, onProgress, retryCount + 1)\n        } else {\n          throw new Error('Upload timed out. Please try again with a smaller image or check your connection.')\n        }\n      }\n\n      // Use enhanced error handling\n      const friendlyMessage = getUserFriendlyErrorMessage(error)\n      throw new ImageUploadError(friendlyMessage, error.code, error)\n    }\n  }\n\n  /**\n   * Upload multiple item images\n   */\n  static async uploadMultipleItemImages(\n    files: File[],\n    projectName: string,\n    itemId: string,\n    onProgress?: (fileIndex: number, progress: UploadProgress) => void\n  ): Promise<ImageUploadResult[]> {\n    const results: ImageUploadResult[] = []\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i]\n\n      try {\n        const result = await this.uploadItemImage(file, projectName, itemId, onProgress ? (progress) => onProgress(i, progress) : undefined)\n        results.push(result)\n      } catch (error) {\n        console.error(`Error uploading image ${i + 1}:`, error)\n        throw error // Re-throw to stop the upload process\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Upload multiple transaction images\n   */\n  static async uploadMultipleTransactionImages(\n    files: File[],\n    projectName: string,\n    transactionId: string,\n    onProgress?: (fileIndex: number, progress: UploadProgress) => void\n  ): Promise<ImageUploadResult[]> {\n    const results: ImageUploadResult[] = []\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i]\n\n      try {\n        const result = await this.uploadTransactionImage(file, projectName, transactionId, onProgress ? (progress) => onProgress(i, progress) : undefined)\n        results.push(result)\n      } catch (error) {\n        console.error(`Error uploading image ${i + 1}:`, error)\n        throw error // Re-throw to stop the upload process\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Delete an image from Firebase Storage\n   */\n  static async deleteImage(imageUrl: string): Promise<void> {\n    try {\n      // Ensure authentication is established before storage operations\n      await this.ensureAuthentication()\n\n      const imageRef = ref(storage, imageUrl)\n      await deleteObject(imageRef)\n    } catch (error) {\n      console.error('Error deleting image:', error)\n      throw new Error('Failed to delete image')\n    }\n  }\n\n  /**\n   * Delete multiple images\n   */\n  static async deleteMultipleImages(imageUrls: string[]): Promise<void> {\n    const deletePromises = imageUrls.map(url => this.deleteImage(url))\n    await Promise.all(deletePromises)\n  }\n\n  /**\n   * Convert File objects to TransactionImage objects\n   */\n  static convertFilesToTransactionImages(uploadResults: ImageUploadResult[]): TransactionImage[] {\n    return uploadResults.map(result => ({\n      url: result.url,\n      fileName: result.fileName,\n      uploadedAt: new Date(),\n      size: result.size,\n      mimeType: result.mimeType\n    }))\n  }\n\n  /**\n   * Validate image file\n   */\n  static validateImageFile(file: File): boolean {\n    // Check file type\n    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp']\n    if (!allowedTypes.includes(file.type)) {\n      return false\n    }\n\n    // Check file size (10MB limit)\n    const maxSize = 10 * 1024 * 1024 // 10MB\n    if (file.size > maxSize) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Get image metadata\n   */\n  static async getImageMetadata(imageUrl: string): Promise<any> {\n    try {\n      // Ensure authentication is established before storage operations\n      await this.ensureAuthentication()\n\n      const imageRef = ref(storage, imageUrl)\n      return await getMetadata(imageRef)\n    } catch (error) {\n      console.error('Error getting image metadata:', error)\n      return null\n    }\n  }\n\n  /**\n   * Compress image for preview (client-side)\n   */\n  static compressImage(file: File, maxWidth: number = 800, quality: number = 0.8): Promise<File> {\n    return new Promise((resolve, reject) => {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      const img = new Image()\n\n      img.onload = () => {\n        // Calculate new dimensions\n        let { width, height } = img\n\n        if (width > maxWidth) {\n          height = (height * maxWidth) / width\n          width = maxWidth\n        }\n\n        canvas.width = width\n        canvas.height = height\n\n        // Draw and compress\n        ctx?.drawImage(img, 0, 0, width, height)\n\n        canvas.toBlob(\n          (blob) => {\n            if (blob) {\n              const compressedFile = new File([blob], file.name, {\n                type: 'image/jpeg',\n                lastModified: Date.now()\n              })\n              resolve(compressedFile)\n            } else {\n              reject(new Error('Failed to compress image'))\n            }\n          },\n          'image/jpeg',\n          quality\n        )\n      }\n\n      img.onerror = () => reject(new Error('Failed to load image'))\n      img.src = URL.createObjectURL(file)\n    })\n  }\n\n  /**\n   * Take photo using device camera\n   */\n  static takePhoto(): Promise<File | null> {\n    return new Promise((resolve) => {\n      const input = document.createElement('input')\n      input.type = 'file'\n      input.accept = 'image/*'\n      input.capture = 'environment' // Use back camera on mobile\n\n      input.onchange = (e) => {\n        const target = e.target as HTMLInputElement\n        const file = target.files?.[0] || null\n        resolve(file)\n      }\n\n      input.click()\n    })\n  }\n\n  /**\n   * Select images from device gallery/camera roll\n   */\n  static selectFromGallery(): Promise<File[]> {\n    return new Promise((resolve, reject) => {\n      const input = document.createElement('input')\n      input.type = 'file'\n      input.accept = 'image/*'\n      input.multiple = true\n      // Note: capture attribute not set to allow gallery selection\n\n      // Set up timeout to prevent infinite hanging\n      const timeoutId = setTimeout(() => {\n        // Clean up the input element\n        if (document.body.contains(input)) {\n          document.body.removeChild(input)\n        }\n        reject(new Error('File selection timeout - user may have canceled'))\n      }, 10000) // 10 second timeout\n\n      // Handle successful file selection\n      const handleChange = (e: Event) => {\n        clearTimeout(timeoutId) // Clear timeout on success\n        if (document.body.contains(input)) {\n          document.body.removeChild(input) // Clean up\n        }\n\n        const target = e.target as HTMLInputElement\n        const files = target.files ? Array.from(target.files) : []\n        resolve(files)\n      }\n\n      // Handle cleanup if component unmounts during selection\n      const handleCancel = () => {\n        clearTimeout(timeoutId)\n        if (document.body.contains(input)) {\n          document.body.removeChild(input)\n        }\n        reject(new Error('File selection canceled'))\n      }\n\n      // Set up event listeners\n      input.onchange = handleChange\n      input.addEventListener('cancel', handleCancel)\n\n      // Add to DOM temporarily for proper event handling\n      document.body.appendChild(input)\n      input.click()\n    })\n  }\n\n  /**\n   * Create a preview URL for a file\n   */\n  static createPreviewUrl(file: File): string {\n    return URL.createObjectURL(file)\n  }\n\n  /**\n   * Clean up preview URL to prevent memory leaks\n   */\n  static revokePreviewUrl(url: string): void {\n    URL.revokeObjectURL(url)\n  }\n\n  /**\n   * Check if file should be compressed for mobile upload\n   */\n  private static shouldCompressForMobile(file: File): boolean {\n    // Check if we're on a mobile device and file is large\n    const userAgent = navigator.userAgent.toLowerCase()\n    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent)\n    const isTablet = /ipad|android(?!.*mobile)/i.test(userAgent)\n    const isLargeFile = file.size > 2 * 1024 * 1024 // 2MB threshold\n    const isMediumFile = file.size > 1024 * 1024 // 1MB threshold\n\n    // Compress for mobile devices with large files, or tablets with very large files\n    return (isMobile && isMediumFile) || (isTablet && isLargeFile)\n  }\n\n  /**\n   * Compress file for mobile upload\n   */\n  private static async compressForMobile(file: File): Promise<File> {\n    try {\n      console.log(`Compressing file: ${file.name}, Size: ${file.size} bytes`)\n\n      // Use aggressive compression for mobile\n      const compressedFile = await this.compressImage(file, 1200, 0.7)\n\n      console.log(`Compressed to: ${compressedFile.size} bytes (${Math.round((compressedFile.size / file.size) * 100)}% of original)`)\n\n      return compressedFile\n    } catch (error) {\n      console.warn('Failed to compress file, using original:', error)\n      return file // Return original file if compression fails\n    }\n  }\n}\n"],"names":["ImageUploadError","message","code","originalError","getUserFriendlyErrorMessage","error","getErrorAction","_a","_b","ImageUploadService","storage","ensureAuthenticatedForStorage","file","projectName","itemId","onProgress","retryCount","transactionId","id","imageType","processedFile","timestamp","sanitizedFileName","sanitizedProjectName","dateTime","fileName","storageRef","ref","uploadTask","uploadBytesResumable","snapshot","progress","_","reject","downloadURL","getDownloadURL","resolve","compressedFile","friendlyMessage","files","results","result","imageUrl","imageRef","deleteObject","imageUrls","deletePromises","url","uploadResults","maxSize","getMetadata","maxWidth","quality","canvas","ctx","img","width","height","blob","input","e","timeoutId","handleChange","target","handleCancel","userAgent","isMobile","isTablet","isLargeFile","isMediumFile"],"mappings":"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"}