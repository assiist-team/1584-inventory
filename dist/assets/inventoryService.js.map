{"version":3,"file":"inventoryService.js","sources":["../../src/constants/tax.ts","../../src/utils/dateUtils.ts","../../src/services/inventoryService.ts"],"sourcesContent":["export type SupportedTaxState = 'NV' | 'UT'\n\n// Configure the NV and UT tax rates here (percentages)\nexport const STATE_TAX_RATE_PCT: Record<SupportedTaxState, number> = {\n  NV: 8.375, // Nevada example rate\n  UT: 7.10   // Utah example rate\n}\n\nexport const isSupportedTaxState = (v: any): v is SupportedTaxState => v === 'NV' || v === 'UT'\n\nexport const SUPPORTED_TAX_STATES = ['NV', 'UT', 'Other'] as const\n\nexport type TaxStateOption = typeof SUPPORTED_TAX_STATES[number]\n\n\n","import type { DateValue } from '@/types'\n\n/**\n * Safely converts various date representations to JavaScript Date objects\n */\nexport const toDate = (value: DateValue): Date | null => {\n  if (!value) return null\n\n  if (value instanceof Date) {\n    return value\n  }\n\n  // Handle Firestore Timestamp objects\n  if (typeof value === 'object' && value) {\n    // Check if it's a Firestore Timestamp with toDate method\n    if ('toDate' in value && typeof (value as any).toDate === 'function') {\n      try {\n        return (value as any).toDate()\n      } catch (error) {\n        console.warn('Failed to convert Firestore Timestamp to Date:', error)\n        return null\n      }\n    }\n\n    // Check if it's a Firestore Timestamp with seconds/nanoseconds\n    if ('seconds' in value && 'nanoseconds' in value) {\n      try {\n        return new Date((value as any).seconds * 1000 + (value as any).nanoseconds / 1000000)\n      } catch (error) {\n        console.warn('Failed to convert Firestore Timestamp to Date:', error)\n        return null\n      }\n    }\n  }\n\n  // Handle string dates\n  if (typeof value === 'string') {\n    try {\n      // Check if it's a date-only string (YYYY-MM-DD format)\n      // This avoids timezone conversion issues by parsing as local time\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        // Parse as local date to avoid timezone conversion\n        const [year, month, day] = value.split('-').map(Number)\n        const date = new Date(year, month - 1, day) // month is 0-indexed\n        return isNaN(date.getTime()) ? null : date\n      }\n\n      // For other date formats, use the original parsing\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to parse date string:', value, error)\n      return null\n    }\n  }\n\n  // Handle number (milliseconds since epoch)\n  if (typeof value === 'number') {\n    try {\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to convert number to Date:', value, error)\n      return null\n    }\n  }\n\n  return null\n}\n\n/**\n * Safely formats a date value to a localized string\n */\nexport const formatDate = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    })\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value with specific options\n */\nexport const formatDateTime = (value: DateValue, options?: Intl.DateTimeFormatOptions, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value as a time string\n */\nexport const formatTime = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  } catch (error) {\n    console.warn('Failed to format time:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Checks if a date value is valid\n */\nexport const isValidDate = (value: DateValue): boolean => {\n  return toDate(value) !== null\n}\n\n/**\n * Formats a currency amount with proper thousands separators and decimal places\n */\nexport const formatCurrency = (amount: string | number, fallback: string = '$0.00'): string => {\n  const num = typeof amount === 'string' ? parseFloat(amount) : amount\n\n  if (isNaN(num)) return fallback\n\n  return num.toLocaleString('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Formats a number with thousands separators (no currency symbol)\n */\nexport const formatNumber = (num: string | number, fallback: string = '0.00'): string => {\n  const value = typeof num === 'string' ? parseFloat(num) : num\n\n  if (isNaN(value)) return fallback\n\n  return value.toLocaleString('en-US', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Returns today's date as a date-only string in YYYY-MM-DD format (local time)\n */\nexport const getTodayDateString = (): string => {\n  const now = new Date()\n  const yyyy = now.getFullYear()\n  const mm = String(now.getMonth() + 1).padStart(2, '0')\n  const dd = String(now.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n/**\n * Converts an input date value to a date-only string (YYYY-MM-DD) if possible.\n * Returns an empty string when conversion fails or value is falsy.\n */\nexport const toDateOnlyString = (value: DateValue): string => {\n  if (!value) return ''\n  // Already a date-only string\n  if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n    return value\n  }\n  const d = toDate(value)\n  if (!d) return ''\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n","import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField,\n  serverTimestamp\n} from 'firebase/firestore'\nimport { STATE_TAX_RATE_PCT, SupportedTaxState } from '@/constants/tax'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport { toDateOnlyString } from '@/utils/dateUtils'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, BusinessInventoryStats } from '@/types'\n\n// Audit Logging Service for allocation/de-allocation events\nexport const auditService = {\n  // Log allocation/de-allocation events\n  async logAllocationEvent(\n    eventType: 'allocation' | 'deallocation' | 'return',\n    itemId: string,\n    projectId: string | null,\n    transactionIdOrDetails: any,\n    detailsOrUndefined?: Record<string, any>\n  ): Promise<void> {\n    try {\n      // Handle different calling patterns\n      let transactionId: string | null | undefined = null\n      let details: Record<string, any> = {}\n\n      if (typeof transactionIdOrDetails === 'string') {\n        transactionId = transactionIdOrDetails\n        details = detailsOrUndefined || {}\n      } else {\n        transactionId = null\n        details = transactionIdOrDetails || {}\n      }\n\n      const auditRef = collection(db, 'audit_logs')\n      await addDoc(auditRef, {\n        event_type: eventType,\n        item_id: itemId,\n        project_id: projectId,\n        transaction_id: transactionId,\n        details: details,\n        timestamp: serverTimestamp(),\n        created_at: new Date().toISOString()\n      })\n      console.log(`üìã Audit logged: ${eventType} for item ${itemId}`)\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  },\n\n  // Log transaction state changes\n  async logTransactionStateChange(\n    transactionId: string,\n    changeType: 'created' | 'updated' | 'deleted',\n    oldState?: any,\n    newState?: any\n  ): Promise<void> {\n    try {\n      const auditRef = collection(db, 'transaction_audit_logs')\n      await addDoc(auditRef, {\n        transaction_id: transactionId,\n        change_type: changeType,\n        old_state: oldState,\n        new_state: newState,\n        timestamp: serverTimestamp(),\n        created_at: new Date().toISOString()\n      })\n      console.log(`üìã Transaction audit logged: ${changeType} for ${transactionId}`)\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  }\n}\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project (top-level collection)\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction (top-level only - post-migration)\n  async getTransaction(_projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory) - top-level only\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction: {\n          transaction_id: transactionSnap.id,\n          ...transactionData\n        } as Transaction,\n        projectId: data.project_id || null\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction (top-level collection)\n  async createTransaction(\n    projectId: string | null | undefined,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        project_id: projectId,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      // Apply tax mapping for NV/UT or compute from subtotal when Other\n      const txToSave: any = { ...newTransaction }\n\n      // Apply tax mapping for NV/UT or compute from subtotal for Other\n      if (txToSave.tax_state === 'NV' || txToSave.tax_state === 'UT') {\n        // Require mapping to exist\n        const mapped = STATE_TAX_RATE_PCT[txToSave.tax_state as SupportedTaxState]\n        if (mapped === undefined || mapped === null) {\n          throw new Error('Configured tax rate for selected state is missing.')\n        }\n        txToSave.tax_rate_pct = mapped\n        // Remove subtotal for mapped states\n        if (txToSave.subtotal !== undefined) {\n          delete txToSave.subtotal\n        }\n      } else if (txToSave.tax_state === 'Other') {\n        // Validate subtotal presence\n        const amountNum = parseFloat((txToSave.amount as any) || '0')\n        const subtotalNum = parseFloat((txToSave.subtotal as any) || '0')\n        if (isNaN(subtotalNum) || subtotalNum <= 0) {\n          throw new Error('Subtotal must be greater than 0 when Tax state is Other.')\n        }\n        if (isNaN(amountNum) || amountNum < subtotalNum) {\n          throw new Error('Subtotal cannot exceed the total amount.')\n        }\n        const rate = ((amountNum - subtotalNum) / subtotalNum) * 100\n        txToSave.tax_rate_pct = Math.round(rate * 10000) / 10000 // 4 decimal places\n      }\n\n      const docRef = await addDoc(transactionsRef, txToSave)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        // Propagate tax_rate_pct to created items if present on transaction\n        const itemsToCreate = items.map(i => ({ ...i }))\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          projectId || '',\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          itemsToCreate,\n          txToSave.tax_rate_pct\n        )\n        console.log('Created items:', createdItemIds)\n\n        // tax_rate_pct is included at item creation when possible (see createTransactionItems)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction (top-level collection)\n  async updateTransaction(_projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    // Filter out undefined values to prevent Firebase errors\n    const cleanUpdates: any = {}\n    Object.keys(finalUpdates).forEach(key => {\n      if (finalUpdates[key] !== undefined) {\n        cleanUpdates[key] = finalUpdates[key]\n      }\n    })\n\n    // Apply tax mapping / computation before save\n    const processedUpdates: any = { ...cleanUpdates }\n    if (processedUpdates.tax_state === 'NV' || processedUpdates.tax_state === 'UT') {\n      try {\n        processedUpdates.tax_rate_pct = STATE_TAX_RATE_PCT[processedUpdates.tax_state as SupportedTaxState]\n        // Remove subtotal when using mapped states\n        if (processedUpdates.subtotal !== undefined) {\n          processedUpdates.subtotal = deleteField()\n        }\n      } catch (e) {\n        console.warn('Tax mapping failed during update:', e)\n      }\n    } else if (processedUpdates.tax_state === 'Other') {\n      // compute from provided subtotal and amount if present in finalUpdates or existing doc\n      const txSnap = await getDoc(transactionRef)\n      const existing = txSnap.exists() ? txSnap.data() : {}\n      const amountVal = processedUpdates.amount !== undefined ? parseFloat(processedUpdates.amount) : parseFloat(existing.amount || '0')\n      const subtotalVal = processedUpdates.subtotal !== undefined ? parseFloat(processedUpdates.subtotal) : parseFloat(existing.subtotal || '0')\n      if (!isNaN(amountVal) && !isNaN(subtotalVal) && subtotalVal > 0 && amountVal >= subtotalVal) {\n        const rate = ((amountVal - subtotalVal) / subtotalVal) * 100\n        processedUpdates.tax_rate_pct = Math.round(rate * 10000) / 10000\n      }\n    }\n\n    await updateDoc(transactionRef, processedUpdates)\n\n    // If tax_rate_pct is set in updates, propagate to items\n    if (processedUpdates.tax_rate_pct !== undefined) {\n      try {\n        const items = await unifiedItemsService.getItemsForTransaction(_projectId, transactionId)\n        if (items && items.length > 0) {\n          const batch = writeBatch(db)\n          items.forEach(item => {\n            const itemRef = doc(db, 'items', item.item_id)\n            batch.update(itemRef, { tax_rate_pct: processedUpdates.tax_rate_pct, last_updated: new Date().toISOString() })\n          })\n          await batch.commit()\n        }\n      } catch (e) {\n        console.warn('Failed to propagate tax_rate_pct to items:', e)\n      }\n    }\n  },\n\n  // Delete transaction (top-level collection)\n  async deleteTransaction(_projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions (top-level collection)\n  subscribeToTransactions(_projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', _projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates (top-level collection)\n  subscribeToTransaction(\n    _projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'canceled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = toDateOnlyString(new Date())\n    }\n\n    // Add last_updated timestamp\n    updateData.last_updated = new Date().toISOString()\n\n    await updateDoc(transactionRef, updateData)\n  },\n\n  // Utility queries for Business Inventory and reporting (top-level collection)\n  async getInventoryRelatedTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('reimbursement_type', 'in', ['Client Owes', 'We Owe']),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get business inventory transactions (project_id == null)\n  async getBusinessInventoryTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', null),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Get items for a project (project_id == projectId)\n  async getItemsByProject(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('project_price', '>=', filters.priceRange.min),\n        where('project_price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery && items.length > 0) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.payment_method.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to items for a project\n  subscribeToItemsByProject(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Get business inventory items (project_id == null)\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Create new item\n  async createItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const now = new Date()\n\n    const newItem: any = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    // If item is being created with a transaction_id but missing tax_rate_pct,\n    // attempt to read the transaction and inherit its tax_rate_pct.\n    try {\n      if (newItem.transaction_id && newItem.tax_rate_pct === undefined) {\n        const txRef = doc(db, 'transactions', newItem.transaction_id)\n        const txSnap = await getDoc(txRef)\n        if (txSnap.exists()) {\n          const txData: any = txSnap.data()\n          if (txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n            newItem.tax_rate_pct = txData.tax_rate_pct\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when creating item:', e)\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.project_id !== undefined) firebaseUpdates.project_id = updates.project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.transaction_id !== undefined) firebaseUpdates.transaction_id = updates.transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n    if (updates.tax_rate_pct !== undefined) firebaseUpdates.tax_rate_pct = updates.tax_rate_pct\n    if (updates.tax_amount !== undefined) firebaseUpdates.tax_amount = updates.tax_amount\n\n    // If transaction_id is being set/changed and caller did not provide tax_rate_pct,\n    // attempt to inherit the transaction's tax_rate_pct and include it in the update.\n    try {\n      const willSetTransaction = updates.transaction_id !== undefined && updates.transaction_id !== null\n      const missingTax = updates.tax_rate_pct === undefined || updates.tax_rate_pct === null\n      if (willSetTransaction && missingTax) {\n        const txId = updates.transaction_id as string\n        if (txId) {\n          const txRef = doc(db, 'transactions', txId)\n          const txSnap = await getDoc(txRef)\n          if (txSnap.exists()) {\n            const txData: any = txSnap.data()\n            if (txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n              firebaseUpdates.tax_rate_pct = txData.tax_rate_pct\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when updating item:', e)\n    }\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete item\n  async deleteItem(itemId: string): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get items for a transaction (by transaction_id)\n  async getItemsForTransaction(_projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n  },\n\n  // Allocate single item to project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine current state and calculate amount\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n    const currentTransactionId: string | null = item.transaction_id || null\n\n    console.log('üîÑ Starting allocation process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.project_id,\n      finalAmount\n    })\n\n    // Log allocation start (catch errors to prevent cascading failures)\n    try {\n      await (auditService.logAllocationEvent as any)('allocation', itemId, item.project_id, currentTransactionId, {\n        action: 'allocation_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC from ALLOCATION_TRANSACTION_LOGIC.md\n\n    // Scenario A: Item currently in a Sale (Project X)\n    if (currentTransactionId?.startsWith('INV_SALE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n      if (currentProjectId === projectId) {\n        // A.1: Remove item from Sale and move to Inventory (delete Sale if empty)\n        console.log('üìã Scenario A.1: Item in Sale, allocating to same project ‚Üí move to inventory')\n        return await this.handleSaleToInventoryMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // A.2: Allocate to different project - remove from Sale, add to Purchase (Project Y)\n        console.log('üìã Scenario A.2: Item in Sale, allocating to different project')\n        return await this.handleSaleToDifferentProjectMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario B: Item currently in a Purchase (Project X)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // B.1: Allocate to same project - remove from Purchase, update amount, delete if empty\n        console.log('üìã Scenario B.1: Item in Purchase, allocating to same project')\n        return await this.handlePurchaseToInventoryMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // B.2: Allocate to different project - remove from Purchase, add to Sale (Project Y)\n        console.log('üìã Scenario B.2: Item in Purchase, allocating to different project')\n        return await this.handlePurchaseToDifferentProjectMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario C: Item in Inventory (no transaction)\n    // Only treat as inventory when there is no transaction_id. Previously this\n    // branch also treated items with a null project_id as inventory which\n    // incorrectly bypassed removal from existing INV_SALE_/INV_PURCHASE_\n    // transactions. Require absence of currentTransactionId to follow the\n    // inventory -> purchase flow.\n    if (!currentTransactionId) {\n      console.log('üìã Scenario C: Item in inventory, allocating to project')\n      return await this.handleInventoryToPurchaseMove(itemId, projectId, finalAmount, notes, space)\n    }\n\n    // Fallback: Unknown scenario, treat as new allocation\n    console.log('üìã Fallback: Unknown scenario, treating as new allocation')\n    return await this.handleInventoryToPurchaseMove(itemId, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle A.1 - Remove item from Sale (same project)\n  async handleSaleToPurchaseMove(\n    itemId: string,\n    currentTransactionId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Purchase (same project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle A.1 (authoritative) - Remove item from Sale and move to Inventory (same project)\n  async handleSaleToInventoryMove(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    // Per A.1: allocate back to the same project without creating an INV_PURCHASE\n    // i.e. set the item's project and mark as allocated, but do not attach a\n    // purchase transaction.\n    await this.updateItem(itemId, {\n      project_id: _projectId,\n      inventory_status: 'allocated',\n      transaction_id: null,\n      disposition: 'keep',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Inventory (same project)')\n\n    // Log successful move (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, _projectId, null, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_status: 'allocated',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion (A.1):', auditError)\n    }\n\n    // Return original sale transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle A.2 - Remove item from Sale, add to Purchase (different project)\n  async handleSaleToDifferentProjectMove(\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${newProjectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction for new project (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: newProjectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.2 completed: Sale ‚Üí Purchase (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, newProjectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.2',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle B.1 - Remove item from Purchase (same project)\n  async handlePurchaseToInventoryMove(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      disposition: 'inventory',\n      notes: _notes,\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.1 completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful deallocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('deallocation', itemId, null, 'inventory', {\n        action: 'deallocation_completed',\n        scenario: 'B.1',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n    }\n\n    return currentTransactionId // Return the original transaction ID since item is now in inventory\n  },\n\n  // Helper: Handle B.2 - Remove item from Purchase, add to Sale (different project)\n  async handlePurchaseToDifferentProjectMove(\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const saleTransactionId = `INV_SALE_${newProjectId}`\n\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Sale transaction for new project (create if none)\n    await this.addItemToTransaction(itemId, saleTransactionId, finalAmount, 'To Inventory', 'Inventory sale', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: saleTransactionId,\n      disposition: 'inventory',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.2 completed: Purchase ‚Üí Sale (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, null, saleTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'B.2',\n        from_transaction: currentTransactionId,\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Helper: Handle C - Add item to Purchase (new allocation)\n  async handleInventoryToPurchaseMove(\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ C completed: Inventory ‚Üí Purchase (new allocation)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'C',\n        from_status: 'inventory',\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Remove item from transaction and update amounts\n  async removeItemFromTransaction(itemId: string, transactionId: string, _itemAmount: string): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      console.warn('‚ö†Ô∏è Transaction not found for removal:', transactionId)\n      return\n    }\n\n    const existingData = transactionSnap.data()\n    const existingItemIds = existingData.item_ids || []\n    const updatedItemIds = existingItemIds.filter((id: string) => id !== itemId)\n\n    if (updatedItemIds.length === 0) {\n      // No items left - delete transaction\n      try {\n        await deleteDoc(transactionRef)\n        console.log('üóëÔ∏è Deleted empty transaction:', transactionId)\n\n        // Log transaction deletion (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'deleted', existingData, null)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction deletion:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to delete empty transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue even if deletion fails\n      }\n    } else {\n      // Recalculate amount from remaining items\n      try {\n        const itemsRef = collection(db, 'items')\n        const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n        const itemsSnapshot = await getDocs(itemsQuery)\n\n        const totalAmount = itemsSnapshot.docs\n          .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          last_updated: new Date().toISOString()\n        }\n\n        await updateDoc(transactionRef, updateData)\n        console.log('üîÑ Updated transaction after removal:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'updated', existingData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update transaction after removal:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Helper: Add item to transaction (create if none exists)\n  async addItemToTransaction(\n    itemId: string,\n    transactionId: string,\n    amount: string,\n    transactionType: 'Purchase' | 'Sale' | 'To Inventory',\n    triggerEvent: string,\n    notes?: string\n  ): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - add item and recalculate amount\n      try {\n        const existingData = transactionSnap.data()\n        const existingItemIds = existingData.item_ids || []\n        const updatedItemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n        // Get all items to recalculate amount\n        const itemsRef = collection(db, 'items')\n        const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n        const itemsSnapshot = await getDocs(itemsQuery)\n\n        const totalAmount = itemsSnapshot.docs\n          .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          last_updated: new Date().toISOString()\n        }\n\n        await updateDoc(transactionRef, updateData)\n        console.log('üîÑ Added item to existing transaction:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'updated', existingData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n\n        // If the transaction has a tax rate, propagate it to the added item\n        try {\n          const txTax = existingData.tax_rate_pct\n          if (txTax !== undefined && txTax !== null) {\n            const itemRef = doc(db, 'items', itemId)\n            await updateDoc(itemRef, { tax_rate_pct: txTax, last_updated: new Date().toISOString() })\n          }\n        } catch (e) {\n          console.warn('Failed to set tax_rate_pct on added item:', itemId, e)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update existing transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    } else {\n      // Create new transaction\n      try {\n        const project = await projectService.getProject(transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', ''))\n        const projectName = project?.name || 'Other'\n\n        const transactionData = {\n          project_id: transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', ''),\n          project_name: null,\n          transaction_date: toDateOnlyString(new Date()),\n          source: transactionType === 'Purchase' ? 'Inventory' : projectName,\n          transaction_type: transactionType,\n          payment_method: 'Pending',\n          amount: amount,\n          budget_category: 'Furnishings',\n          notes: notes || `Transaction for items ${transactionType === 'Purchase' ? 'purchased from' : 'sold to'} ${transactionType === 'Purchase' ? 'inventory' : 'project'}`,\n          status: 'pending' as const,\n          reimbursement_type: transactionType === 'Purchase' ? 'Client Owes' : 'We Owe',\n          trigger_event: triggerEvent,\n          item_ids: [itemId],\n          created_by: 'system',\n          created_at: new Date().toISOString(),\n          last_updated: new Date().toISOString()\n        }\n\n        await setDoc(transactionRef, transactionData)\n        console.log('üÜï Created new transaction:', transactionId, 'amount:', amount)\n\n        // Log transaction creation (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'created', null, transactionData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction creation:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to create new transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Batch allocate multiple items to project (updates INV_PURCHASE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Fetch the requested items by id (inspect transaction_id per-item to\n    // implement A.1 vs A.2 decisions). Do NOT rely solely on project_id.\n    const itemsRef = collection(db, 'items')\n    const itemsQuery = query(itemsRef, where('__name__', 'in', itemIds))\n    const itemsSnapshot = await getDocs(itemsQuery)\n\n    if (itemsSnapshot.empty) {\n      throw new Error('No items found for allocation')\n    }\n\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Process each item individually so we can apply A.1/A.2 rules per item.\n    for (const itemDoc of itemsSnapshot.docs) {\n      const itemId = itemDoc.id\n      const itemData: any = itemDoc.data()\n      const finalAmount = allocationData.amount || itemData.project_price || itemData.market_value || '0.00'\n      const currentTransactionId: string | null = itemData.transaction_id || null\n\n      // Scenario A: Item currently in a Sale (Project X)\n      if (currentTransactionId?.startsWith('INV_SALE_')) {\n        const saleProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n        if (saleProjectId === projectId) {\n          // A.1: Remove item from Sale and DO NOT add to Purchase. Assign back to\n          // the same project (mark allocated) but do not create an INV_PURCHASE.\n          console.log('üìã Batch A.1: Item in sale for target project ‚Äî removing from sale and assigning to project', itemId)\n          await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n          await this.updateItem(itemId, {\n            project_id: projectId,\n            inventory_status: 'allocated',\n            transaction_id: null,\n            disposition: 'keep',\n            notes: allocationData.notes,\n            space: allocationData.space || '',\n            last_updated: new Date().toISOString()\n          })\n          continue\n        } else {\n          // A.2: Remove from Sale then add to Purchase for target project\n          console.log('üìã Batch A.2: Item in sale for different project ‚Äî moving to purchase for target project', itemId)\n          await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n          await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n          await this.updateItem(itemId, {\n            project_id: projectId,\n            inventory_status: 'allocated',\n            transaction_id: canonicalTransactionId,\n            disposition: 'keep',\n            space: allocationData.space || '',\n            last_updated: new Date().toISOString()\n          })\n          continue\n        }\n      }\n\n      // Scenario C: Item in Inventory (no transaction_id) ‚Äî add to Purchase\n      if (!currentTransactionId) {\n        console.log('üìã Batch C: Item in inventory ‚Äî adding to purchase', itemId)\n        await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n        await this.updateItem(itemId, {\n          project_id: projectId,\n          inventory_status: 'allocated',\n          transaction_id: canonicalTransactionId,\n          disposition: 'keep',\n          space: allocationData.space || '',\n          last_updated: new Date().toISOString()\n        })\n        continue\n      }\n\n      // Fallback: other transaction types ‚Äî add to purchase and update item\n      console.log('üìã Batch Fallback: Item in other transaction ‚Äî adding to purchase', itemId, currentTransactionId)\n      await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n      await this.updateItem(itemId, {\n        project_id: projectId,\n        inventory_status: 'allocated',\n        transaction_id: canonicalTransactionId,\n        disposition: 'keep',\n        space: allocationData.space || '',\n        last_updated: new Date().toISOString()\n      })\n    }\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async returnItemFromProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine current state\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n    const currentTransactionId: string | null = item.transaction_id || null\n\n    console.log('üîÑ Starting return process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.project_id,\n      finalAmount\n    })\n\n    // Log return start (catch errors to prevent cascading failures)\n    try {\n      await (auditService.logAllocationEvent as any)('return', itemId, item.project_id, currentTransactionId, {\n        action: 'return_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC for returns (reverse of allocation)\n\n    // If item is in a Purchase transaction, this is a return (Scenario B reverse)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // Returning from same project - remove from Purchase, move to inventory\n        console.log('üìã Return Scenario: Item in Purchase, returning from same project')\n        return await this.handleReturnFromPurchase(itemId, currentTransactionId, projectId, finalAmount, notes)\n      }\n    }\n\n    // If item is not in any transaction or is in inventory, this is a new return\n    console.log('üìã Return Scenario: Item not in transaction or new return')\n    return await this.handleNewReturn(itemId, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle return from Purchase transaction (same project)\n  async handleReturnFromPurchase(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction and return it to inventory.\n    // Per allocation rules, do NOT create an INV_SALE when the item was part of\n    // an INV_PURCHASE for the same project. Simply remove the item from the\n    // purchase (the helper will delete the purchase if empty), then update the\n    // item to reflect that it's back in business inventory.\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory and clear transaction linkage for canonical state\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: null,\n      disposition: 'inventory',\n      notes: notes\n    })\n\n    console.log('‚úÖ Return completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('return', itemId, null, currentTransactionId, {\n        action: 'return_completed',\n        scenario: 'return_from_purchase',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    // Return the original purchase transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle new return (item was already in inventory or no transaction)\n  async handleNewReturn(\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Create Sale transaction (project selling TO us)\n    const saleTransactionId = `INV_SALE_${projectId}`\n\n    const transactionData = {\n      project_id: projectId,\n      project_name: null,\n      transaction_date: toDateOnlyString(new Date()),\n      source: projectName,\n      transaction_type: 'To Inventory',  // Project is moving item TO inventory\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,  // We owe the client for this purchase\n      trigger_event: 'Inventory sale' as const,\n      item_ids: [itemId],\n      created_by: 'system',\n      created_at: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    }\n\n    const transactionRef = doc(db, 'transactions', saleTransactionId)\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update item status to inventory\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: saleTransactionId,\n      disposition: 'inventory'\n    })\n\n    console.log('‚úÖ New return completed: Inventory ‚Üí Sale')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('return', itemId, null, saleTransactionId, {\n        action: 'return_completed',\n        scenario: 'new_return',\n        from_status: 'inventory',\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_PURCHASE_${projectId}`\n\n    // Get the transaction\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      throw new Error('Transaction not found')\n    }\n\n    const transactionData = transactionSnap.data()\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      payment_method: paymentMethod,\n      transaction_date: toDateOnlyString(new Date()),\n      last_updated: new Date().toISOString()\n    })\n\n    // Clear transaction_id from all linked items\n    const batch = writeBatch(db)\n    for (const itemId of itemIds) {\n      const itemRef = doc(db, 'items', itemId)\n      if (transactionType === 'sale') {\n        // For sales, keep project_id but clear transaction_id and set status to sold\n        batch.update(itemRef, {\n          transaction_id: null,\n          inventory_status: 'sold',\n          last_updated: new Date().toISOString()\n        })\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        batch.update(itemRef, {\n          project_id: null,\n          transaction_id: null,\n          inventory_status: 'available',\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    await batch.commit()\n  },\n\n  // Helper function to get item by ID\n  async getItemById(itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate an existing item (unified collection version)\n  async duplicateItem(projectId: string, originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getItemById(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes,\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transaction_id,\n      project_id: projectId,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'items', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version)\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transaction_date: string,\n    transactionSource: string,\n    items: TransactionItemFormData[],\n    taxRatePct?: number\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    // Attempt to read the transaction's tax rate once (avoid per-item reads)\n    let inheritedTax: number | undefined = undefined\n    try {\n      if ((taxRatePct === undefined || taxRatePct === null) && transactionId) {\n        const txRef = doc(db, 'transactions', transactionId)\n        const txSnap = await getDoc(txRef)\n        if (txSnap.exists()) {\n          const txData: any = txSnap.data()\n          if (txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n            inheritedTax = txData.tax_rate_pct\n          }\n        }\n      }\n    } catch (e) {\n      // non-fatal - continue without inherited tax\n    }\n\n    for (const itemData of items) {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item: any = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        project_price: itemData.project_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes,\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transaction_date,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      }\n\n      // Attach tax rate from explicit arg, otherwise inherited transaction value\n      if (taxRatePct !== undefined && taxRatePct !== null) {\n        item.tax_rate_pct = taxRatePct\n      } else if (inheritedTax !== undefined) {\n        item.tax_rate_pct = inheritedTax\n      }\n\n      // Cast to Item for downstream callers\n      const itemTyped = item as Item\n\n      batch.set(itemRef, itemTyped)\n    }\n\n    await batch.commit()\n    return createdItemIds\n  }\n}\n\n// Business Inventory Services (DEPRECATED - use unifiedItemsService instead)\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<Item | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate a business inventory item\n  async duplicateBusinessInventoryItem(originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getBusinessInventoryItem(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original business inventory item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `BI-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes,\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      inventory_status: 'available', // Default status for duplicates\n      business_inventory_location: originalItem.business_inventory_location || '',\n      transaction_id: originalItem.transaction_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'business_inventory', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let allocatedItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'allocated':\n          allocatedItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      allocatedItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item to determine the amount if not provided\n    const item = await this.getBusinessInventoryItem(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(new Date()),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to allocated and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'allocated',\n      transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(now),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        project_price: businessItemData.project_price, // 1584 design project price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes,\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItems = await unifiedItemsService.getItemsByProject(projectId)\n    const currentItemCount = currentItems.length\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n    async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'canceled',\n      last_updated: new Date().toISOString()\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: toDateOnlyString(new Date()),\n      payment_method: paymentMethod,\n      last_updated: new Date().toISOString()\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(new Date()),\n      source: 'Client Purchase',\n      transaction_type: 'Purchase',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('üîÑ handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('‚è≠Ô∏è Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('üîç Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('‚úÖ Item found:', item.item_id, 'disposition:', item.disposition, 'project_id:', item.project_id)\n\n      // If the item is currently linked to an INV_PURCHASE for the same project,\n      // this is a purchase-reversion: remove it from the purchase and return it\n      // to inventory instead of creating an INV_SALE. This prevents creating\n      // both INV_PURCHASE and INV_SALE canonical transactions for the same\n      // item/project.\n      if (item.transaction_id && item.transaction_id.startsWith('INV_PURCHASE_')) {\n        const purchaseProjectId = item.transaction_id.replace('INV_PURCHASE_', '')\n        if (purchaseProjectId === projectId) {\n          console.log('üîÅ Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory')\n\n          // Remove item from the existing purchase (will delete if empty)\n          await unifiedItemsService.removeItemFromTransaction(item.item_id, item.transaction_id, item.project_price || item.market_value || '0.00')\n\n          // Update the item to reflect it's back in business inventory\n          await unifiedItemsService.updateItem(item.item_id, {\n            project_id: null,\n            inventory_status: 'available',\n            transaction_id: null,\n            last_updated: new Date().toISOString()\n          })\n\n          try {\n            await auditService.logAllocationEvent('deallocation', itemId, null, item.transaction_id, {\n              action: 'deallocation_completed',\n              scenario: 'purchase_reversion',\n              from_transaction: item.transaction_id,\n              to_status: 'inventory',\n              amount: item.project_price || item.market_value || '0.00'\n            })\n          } catch (auditError) {\n            console.warn('‚ö†Ô∏è Failed to log deallocation completion for purchase-reversion:', auditError)\n          }\n\n          console.log('‚úÖ Purchase-reversion handled: item returned to inventory without creating INV_SALE')\n          return\n        }\n      }\n\n      // Unified approach: Always create/update a \"Sale\" transaction for inventory designation (project selling TO us)\n      console.log('üè¶ Creating/updating Sale transaction for inventory designation')\n\n      // Log deallocation start (catch errors to prevent cascading failures)\n      try {\n        await (auditService.logAllocationEvent as any)('deallocation', itemId, item.project_id, item.transaction_id, {\n          action: 'deallocation_started',\n          target_status: 'inventory',\n          current_transaction_id: item.transaction_id\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation start:', auditError)\n      }\n\n      const transactionId = await this.ensureSaleTransaction(\n        item,\n        projectId,\n        'Transaction for items purchased from project and moved to business inventory'\n      )\n\n      console.log('üì¶ Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(item.item_id, {\n        project_id: null,\n        inventory_status: 'available',\n        transaction_id: transactionId,\n        space: '', // Clear space field when moving to business inventory\n        last_updated: new Date().toISOString()\n      })\n\n      // Log successful deallocation (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent('deallocation', itemId, null, transactionId, {\n          action: 'deallocation_completed',\n          from_project_id: item.project_id,\n          to_transaction: transactionId,\n          amount: item.project_price || item.market_value || '0.00'\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n      }\n\n      console.log('‚úÖ Item moved to business inventory successfully')\n\n      console.log('‚úÖ Deallocation completed successfully')\n    } catch (error) {\n      console.error('‚ùå Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a sale transaction exists for inventory designation (follows ALLOCATION_TRANSACTION_LOGIC.md)\n  async ensureSaleTransaction(\n    item: Item,\n    projectId: string,\n    additionalNotes?: string\n  ): Promise<string | null> {\n    console.log('üè¶ Creating/updating sale transaction for item:', item.item_id)\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Defensive check: if the item is still linked to a purchase for this\n    // project, treat as purchase-reversion and do not create an INV_SALE.\n    if (item.transaction_id && item.transaction_id.startsWith('INV_PURCHASE_')) {\n      const purchaseProjectId = item.transaction_id.replace('INV_PURCHASE_', '')\n      if (purchaseProjectId === projectId) {\n        console.log('‚ÑπÔ∏è ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE')\n\n        // Remove the item from the purchase and return to inventory\n        await unifiedItemsService.removeItemFromTransaction(item.item_id, item.transaction_id, item.project_price || item.market_value || '0.00')\n        await unifiedItemsService.updateItem(item.item_id, {\n          project_id: null,\n          inventory_status: 'available',\n          transaction_id: null,\n          last_updated: new Date().toISOString()\n        })\n\n        // Return null to indicate no INV_SALE was created\n        return null\n      }\n    }\n\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n    console.log('üîë Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists (top-level collection)\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.item_id])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const itemsRef = collection(db, 'items')\n      const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n      const itemsSnapshot = await getDocs(itemsQuery)\n\n      const totalAmount = itemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        ...existingData,\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, updatedTransactionData, { merge: true })\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n        // Calculate amount from item for new transaction\n      const calculatedAmount = item.project_price || item.market_value || '0.00'\n\n      // New transaction - create Sale transaction (project moving item TO inventory)\n      const transactionData = {\n        project_id: projectId,\n        project_name: null,\n        transaction_date: toDateOnlyString(new Date()),\n        source: projectName,  // Project name as source (project moving to inventory)\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: parseFloat(calculatedAmount || '0').toFixed(2),\n        budget_category: 'Furnishings',\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: 'We Owe' as const,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [item.item_id],\n        created_by: 'system',\n        created_at: new Date().toISOString(),\n        last_updated: new Date().toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      await setDoc(transactionRef, transactionData, { merge: true })\n    }\n\n    console.log('‚úÖ Sale transaction created/updated successfully')\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction('sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(itemId, projectId, disposition)\n  }\n}\n"],"names":["STATE_TAX_RATE_PCT","toDate","value","error","year","month","day","date","formatDate","fallback","formatCurrency","amount","num","toDateOnlyString","d","yyyy","mm","dd","auditService","eventType","itemId","projectId","transactionIdOrDetails","detailsOrUndefined","transactionId","details","auditRef","collection","db","addDoc","serverTimestamp","changeType","oldState","newState","projectService","ensureAuthenticatedForStorage","projectsRef","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectRef","projectSnap","getDoc","projectData","now","newProject","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","transactionService","transactionsRef","where","transactionData","_projectId","transactionRef","transactionSnap","items","newTransaction","txToSave","mapped","amountNum","subtotalNum","rate","itemsToCreate","i","createdItemIds","unifiedItemsService","finalUpdates","deleteField","cleanUpdates","key","processedUpdates","e","txSnap","existing","amountVal","subtotalVal","batch","writeBatch","item","itemRef","transactions","transaction","status","updateData","filters","pagination","itemsRef","searchTerm","limit","_a","itemData","newItem","txRef","txData","firebaseUpdates","willSetTransaction","missingTax","txId","notes","space","finalAmount","currentTransactionId","auditError","purchaseTransactionId","_notes","newProjectId","saleTransactionId","_itemAmount","existingData","updatedItemIds","id","itemsQuery","totalAmount","sum","price","safeAmount","transactionType","triggerEvent","existingItemIds","txTax","project","projectName","setDoc","itemIds","allocationData","itemsSnapshot","canonicalTransactionId","itemDoc","paymentMethod","itemSnap","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","transaction_date","transactionSource","taxRatePct","inheritedTax","qrKey","itemTyped","businessInventoryService","getCountFromServer","allItemsQuery","allItemsSnap","availableItems","allocatedItems","soldItems","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","projectItemsRef","itemQuery","newBusinessItem","deallocationService","disposition","additionalNotes","updatedTransactionData","calculatedAmount","integrationService","_transactionId","_itemId"],"mappings":"qLAGO,MAAMA,EAAwD,CACnE,GAAI,MACJ,GAAI,GACN,ECDaC,EAAUC,GAAkC,CACvD,GAAI,CAACA,EAAO,OAAO,KAEnB,GAAIA,aAAiB,KACnB,OAAOA,EAIT,GAAI,OAAOA,GAAU,UAAYA,EAAO,CAEtC,GAAI,WAAYA,GAAS,OAAQA,EAAc,QAAW,WACxD,GAAI,CACF,OAAQA,EAAc,OAAA,CACxB,OAASC,EAAO,CACd,eAAQ,KAAK,iDAAkDA,CAAK,EAC7D,IACT,CAIF,GAAI,YAAaD,GAAS,gBAAiBA,EACzC,GAAI,CACF,OAAO,IAAI,KAAMA,EAAc,QAAU,IAAQA,EAAc,YAAc,GAAO,CACtF,OAASC,EAAO,CACd,eAAQ,KAAK,iDAAkDA,CAAK,EAC7D,IACT,CAEJ,CAGA,GAAI,OAAOD,GAAU,SACnB,GAAI,CAGF,GAAI,sBAAsB,KAAKA,CAAK,EAAG,CAErC,KAAM,CAACE,EAAMC,EAAOC,CAAG,EAAIJ,EAAM,MAAM,GAAG,EAAE,IAAI,MAAM,EAChDK,EAAO,IAAI,KAAKH,EAAMC,EAAQ,EAAGC,CAAG,EAC1C,OAAO,MAAMC,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,CAGA,MAAMA,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,+BAAgCD,EAAOC,CAAK,EAClD,IACT,CAIF,GAAI,OAAOD,GAAU,SACnB,GAAI,CACF,MAAMK,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,oCAAqCD,EAAOC,CAAK,EACvD,IACT,CAGF,OAAO,IACT,EAKaK,EAAa,CAACN,EAAkBO,EAAmB,YAAsB,CACpF,MAAMF,EAAON,EAAOC,CAAK,EACzB,GAAI,CAACK,EAAM,OAAOE,EAElB,GAAI,CACF,OAAOF,EAAK,mBAAmB,QAAS,CACtC,KAAM,UACN,MAAO,QACP,IAAK,SAAA,CACN,CACH,OAASJ,EAAO,CACd,eAAQ,KAAK,yBAA0BD,EAAOC,CAAK,EAC5CM,CACT,CACF,EAsDaC,EAAiB,CAACC,EAAyBF,EAAmB,UAAoB,CAC7F,MAAMG,EAAM,OAAOD,GAAW,SAAW,WAAWA,CAAM,EAAIA,EAE9D,OAAI,MAAMC,CAAG,EAAUH,EAEhBG,EAAI,eAAe,QAAS,CACjC,MAAO,WACP,SAAU,MACV,sBAAuB,EACvB,sBAAuB,CAAA,CACxB,CACH,EA+BaC,EAAoBX,GAA6B,CAC5D,GAAI,CAACA,EAAO,MAAO,GAEnB,GAAI,OAAOA,GAAU,UAAY,sBAAsB,KAAKA,CAAK,EAC/D,OAAOA,EAET,MAAMY,EAAIb,EAAOC,CAAK,EACtB,GAAI,CAACY,EAAG,MAAO,GACf,MAAMC,EAAOD,EAAE,YAAA,EACTE,EAAK,OAAOF,EAAE,SAAA,EAAa,CAAC,EAAE,SAAS,EAAG,GAAG,EAC7CG,EAAK,OAAOH,EAAE,QAAA,CAAS,EAAE,SAAS,EAAG,GAAG,EAC9C,MAAO,GAAGC,CAAI,IAAIC,CAAE,IAAIC,CAAE,EAC5B,EC1KaC,EAAe,CAE1B,MAAM,mBACJC,EACAC,EACAC,EACAC,EACAC,EACe,CACf,GAAI,CAEF,IAAIC,EAA2C,KAC3CC,EAA+B,CAAA,EAE/B,OAAOH,GAA2B,UACpCE,EAAgBF,EAChBG,EAAUF,GAAsB,CAAA,IAEhCC,EAAgB,KAChBC,EAAUH,GAA0B,CAAA,GAGtC,MAAMI,EAAWC,EAAWC,EAAI,YAAY,EAC5C,MAAMC,EAAOH,EAAU,CACrB,WAAYP,EACZ,QAASC,EACT,WAAYC,EACZ,eAAgBG,EAChB,QAAAC,EACA,UAAWK,EAAA,EACX,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACD,QAAQ,IAAI,oBAAoBX,CAAS,aAAaC,CAAM,EAAE,CAChE,OAASjB,EAAO,CACd,QAAQ,KAAK,+CAAgDA,CAAK,CAEpE,CACF,EAGA,MAAM,0BACJqB,EACAO,EACAC,EACAC,EACe,CACf,GAAI,CACF,MAAMP,EAAWC,EAAWC,EAAI,wBAAwB,EACxD,MAAMC,EAAOH,EAAU,CACrB,eAAgBF,EAChB,YAAaO,EACb,UAAWC,EACX,UAAWC,EACX,UAAWH,EAAA,EACX,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACD,QAAQ,IAAI,gCAAgCC,CAAU,QAAQP,CAAa,EAAE,CAC/E,OAASrB,EAAO,CACd,QAAQ,KAAK,qDAAsDA,CAAK,CAE1E,CACF,CACF,EAGa+B,EAAiB,CAE5B,MAAM,aAAkC,CAEtC,MAAMC,EAAA,EAEN,MAAMC,EAAcT,EAAWC,EAAI,UAAU,EACvCS,EAAIC,EAAMF,EAAaG,EAAQ,YAAa,MAAM,CAAC,EAGzD,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,WAAWrB,EAA4C,CAE3D,MAAMc,EAAA,EAEN,MAAMS,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAC1CwB,EAAc,MAAMC,EAAOF,CAAU,EAE3C,GAAIC,EAAY,SAAU,CACxB,MAAMH,EAAOC,EAAkBE,EAAY,KAAA,CAAM,EACjD,MAAO,CACL,GAAIA,EAAY,GAChB,GAAGH,CAAA,CAEP,CACA,OAAO,IACT,EAGA,MAAM,cAAcK,EAA+E,CACjG,MAAMX,EAAcT,EAAWC,EAAI,UAAU,EACvCoB,MAAU,KAEVC,EAAa,CACjB,GAAGF,EACH,UAAWC,EACX,UAAWA,CAAA,EAIb,OADe,MAAMnB,EAAOO,EAAaa,CAAU,GACrC,EAChB,EAGA,MAAM,cAAc5B,EAAmB6B,EAA0C,CAC/E,MAAMN,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAChD,MAAM8B,EAAUP,EAAY,CAC1B,GAAGM,EACH,cAAe,IAAK,CACrB,CACH,EAGA,MAAM,cAAc7B,EAAkC,CACpD,MAAMuB,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAChD,MAAM+B,EAAUR,CAAU,CAC5B,EAGA,oBAAoBS,EAAyC,CAC3D,MAAMjB,EAAcT,EAAWC,EAAI,UAAU,EACvCS,EAAIC,EAAMF,EAAaG,EAAQ,YAAa,MAAM,CAAC,EAEzD,OAAOe,EAAWjB,EAAIkB,GAAa,CACjC,MAAMC,EAAWD,EAAS,KAAK,IAAId,GAAO,CACxC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,EACDW,EAASG,CAAQ,CACnB,CAAC,CACH,CACF,EAMaC,EAAqB,CAEhC,MAAM,gBAAgBpC,EAA2C,CAC/D,MAAMqC,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAMtC,CAAS,EACnCkB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,eAAeC,EAAoBrC,EAAoD,CAC3F,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAC5B,MAAMrB,EAAOC,EAAkBoB,EAAgB,KAAA,CAAM,EAErD,QAAQ,IAAI,+BAAgCrB,CAAI,EAChD,QAAQ,IAAI,yCAA0CA,EAAK,kBAAkB,EAC7E,QAAQ,IAAI,8CAA+C,OAAOA,EAAK,kBAAkB,EAEzF,MAAMkB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,eAAQ,IAAI,gDAAiDkB,CAAe,EAErE,CACL,eAAgBG,EAAgB,GAChC,GAAGH,CAAA,CAEP,CAEA,OAAO,IACT,EAGA,MAAM,mBAAmBpC,EAA+F,CACtH,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAC5B,MAAMrB,EAAOC,EAAkBoB,EAAgB,KAAA,CAAM,EAC/CH,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,YAAa,CACX,eAAgBqB,EAAgB,GAChC,GAAGH,CAAA,EAEL,UAAWlB,EAAK,YAAc,IAAA,CAElC,CAEA,MAAO,CAAE,YAAa,KAAM,UAAW,IAAA,CACzC,EAGA,MAAM,kBACJrB,EACAuC,EACAI,EACiB,CACjB,GAAI,CACF,MAAMN,EAAkB/B,EAAWC,EAAI,cAAc,EAG/CqC,EAAiB,CACrB,GAAGL,EACH,WAAYvC,EACZ,eALc,KAAA,EAKE,YAAA,EAEhB,OAAQuC,EAAgB,QAAU,YAClC,mBAAoBA,EAAgB,oBAAsB,KAC1D,cAAeA,EAAgB,eAAiB,IAAA,EAGlD,QAAQ,IAAI,wBAAyBK,CAAc,EACnD,QAAQ,IAAI,qBAAsBD,CAAK,EAGvC,MAAME,EAAgB,CAAE,GAAGD,CAAA,EAG3B,GAAIC,EAAS,YAAc,MAAQA,EAAS,YAAc,KAAM,CAE9D,MAAMC,EAASnE,EAAmBkE,EAAS,SAA8B,EACzE,GAA4BC,GAAW,KACrC,MAAM,IAAI,MAAM,oDAAoD,EAEtED,EAAS,aAAeC,EAEpBD,EAAS,WAAa,QACxB,OAAOA,EAAS,QAEpB,SAAWA,EAAS,YAAc,QAAS,CAEzC,MAAME,EAAY,WAAYF,EAAS,QAAkB,GAAG,EACtDG,EAAc,WAAYH,EAAS,UAAoB,GAAG,EAChE,GAAI,MAAMG,CAAW,GAAKA,GAAe,EACvC,MAAM,IAAI,MAAM,0DAA0D,EAE5E,GAAI,MAAMD,CAAS,GAAKA,EAAYC,EAClC,MAAM,IAAI,MAAM,0CAA0C,EAE5D,MAAMC,GAASF,EAAYC,GAAeA,EAAe,IACzDH,EAAS,aAAe,KAAK,MAAMI,EAAO,GAAK,EAAI,GACrD,CAGA,MAAM9C,GADS,MAAMK,EAAO6B,EAAiBQ,CAAQ,GACxB,GAI7B,GAHA,QAAQ,IAAI,oCAAqC1C,CAAa,EAG1DwC,GAASA,EAAM,OAAS,EAAG,CAC7B,QAAQ,IAAI,kCAAmCxC,CAAa,EAE5D,MAAM+C,EAAgBP,EAAM,QAAU,CAAE,GAAGQ,GAAI,EACzCC,EAAiB,MAAMC,EAAoB,uBAC/CrD,GAAa,GACbG,EACAoC,EAAgB,iBAChBA,EAAgB,OAChBW,EACAL,EAAS,YAAA,EAEX,QAAQ,IAAI,iBAAkBO,CAAc,CAG9C,CAEA,OAAOjD,CACT,OAASrB,EAAO,CACd,cAAQ,MAAM,8BAA+BA,CAAK,EAC5CA,CACR,CACF,EAGA,MAAM,kBAAkB0D,EAAoBrC,EAAuB0B,EAA8C,CAC/G,MAAMY,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAGtDmD,EAAoB,CAAE,GAAGzB,CAAA,EAG3ByB,EAAa,SAAW,aAAeA,EAAa,qBAAuB,SAC7EA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,qBAAuB,KACtCA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,oBAAsBA,EAAa,SAAW,cAE7DA,EAAa,OAAS,WAIxB,MAAME,EAAoB,CAAA,EAC1B,OAAO,KAAKF,CAAY,EAAE,QAAQG,GAAO,CACnCH,EAAaG,CAAG,IAAM,SACxBD,EAAaC,CAAG,EAAIH,EAAaG,CAAG,EAExC,CAAC,EAGD,MAAMC,EAAwB,CAAE,GAAGF,CAAA,EACnC,GAAIE,EAAiB,YAAc,MAAQA,EAAiB,YAAc,KACxE,GAAI,CACFA,EAAiB,aAAe/E,EAAmB+E,EAAiB,SAA8B,EAE9FA,EAAiB,WAAa,SAChCA,EAAiB,SAAWH,EAAA,EAEhC,OAASI,EAAG,CACV,QAAQ,KAAK,oCAAqCA,CAAC,CACrD,SACSD,EAAiB,YAAc,QAAS,CAEjD,MAAME,EAAS,MAAMnC,EAAOgB,CAAc,EACpCoB,EAAWD,EAAO,OAAA,EAAWA,EAAO,KAAA,EAAS,CAAA,EAC7CE,EAAYJ,EAAiB,SAAW,OAAY,WAAWA,EAAiB,MAAM,EAAI,WAAWG,EAAS,QAAU,GAAG,EAC3HE,EAAcL,EAAiB,WAAa,OAAY,WAAWA,EAAiB,QAAQ,EAAI,WAAWG,EAAS,UAAY,GAAG,EACzI,GAAI,CAAC,MAAMC,CAAS,GAAK,CAAC,MAAMC,CAAW,GAAKA,EAAc,GAAKD,GAAaC,EAAa,CAC3F,MAAMd,GAASa,EAAYC,GAAeA,EAAe,IACzDL,EAAiB,aAAe,KAAK,MAAMT,EAAO,GAAK,EAAI,GAC7D,CACF,CAKA,GAHA,MAAMnB,EAAUW,EAAgBiB,CAAgB,EAG5CA,EAAiB,eAAiB,OACpC,GAAI,CACF,MAAMf,EAAQ,MAAMU,EAAoB,uBAAuBb,EAAYrC,CAAa,EACxF,GAAIwC,GAASA,EAAM,OAAS,EAAG,CAC7B,MAAMqB,EAAQC,EAAW1D,CAAE,EAC3BoC,EAAM,QAAQuB,GAAQ,CACpB,MAAMC,EAAU/C,EAAIb,EAAI,QAAS2D,EAAK,OAAO,EAC7CF,EAAM,OAAOG,EAAS,CAAE,aAAcT,EAAiB,aAAc,aAAc,IAAI,OAAO,YAAA,CAAY,CAAG,CAC/G,CAAC,EACD,MAAMM,EAAM,OAAA,CACd,CACF,OAASL,EAAG,CACV,QAAQ,KAAK,6CAA8CA,CAAC,CAC9D,CAEJ,EAGA,MAAM,kBAAkBnB,EAAoBrC,EAAsC,CAChF,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAC5D,MAAM4B,EAAUU,CAAc,CAChC,EAGA,wBAAwBD,EAAoBR,EAAiD,CAC3F,MAAMK,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAME,CAAU,EACpCtB,EAAQ,aAAc,MAAM,CAAA,EAG9B,OAAOe,EAAWjB,EAAIkB,GAAa,CACjC,MAAMkC,EAAelC,EAAS,KAAK,IAAId,GAAO,CAC5C,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,EACDP,EAASoC,CAAY,CACvB,CAAC,CACH,EAGA,uBACE5B,EACArC,EACA6B,EACA,CACA,MAAMS,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAE5D,OAAO8B,EAAWQ,EAAiBrB,GAAQ,CACzC,GAAIA,EAAI,SAAU,CAChB,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEzC,QAAQ,IAAI,yCAA0CC,CAAI,EAC1D,QAAQ,IAAI,mDAAoDA,EAAK,kBAAkB,EAEvF,MAAMkB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,QAAQ,IAAI,0DAA2DkB,CAAe,EAEtF,MAAM8B,EAAc,CAClB,eAAgBjD,EAAI,GACpB,GAAGmB,CAAA,EAELP,EAASqC,CAAW,CACtB,MACErC,EAAS,IAAI,CAEjB,CAAC,CACH,EAGA,MAAM,uBAAuBhC,EAA2C,CACtE,MAAMqC,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEgB,EAAIC,EACRoB,EACAC,EAAM,SAAU,KAAM,SAAS,EAC/BpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,wBACJvC,EACAG,EACAmE,EACAzC,EACe,CACf,MAAMY,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EAE7EoE,EAAkB,CACtB,OAAAD,EACA,GAAGzC,CAAA,EAIDyC,IAAW,aAAe,EAACzC,GAAA,MAAAA,EAAS,oBACtC0C,EAAW,iBAAmB/E,EAAiB,IAAI,IAAM,GAI3D+E,EAAW,aAAe,IAAI,KAAA,EAAO,YAAA,EAErC,MAAMzC,EAAUW,EAAgB8B,CAAU,CAC5C,EAGA,MAAM,iCAA0D,CAC9D,MAAMlC,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,qBAAsB,KAAM,CAAC,cAAe,QAAQ,CAAC,EAC3DpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,kCAA2D,CAC/D,MAAMF,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAM,IAAI,EAC9BpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,CACF,EAGac,EAAsB,CAEjC,MAAM,kBACJrD,EACAwE,EACAC,EACiB,CACjB,MAAM3D,EAAA,EAEN,MAAM4D,EAAWpE,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMyD,EAAUpC,EAAM,aAAc,KAAMtC,CAAS,CAAC,EAwB5D,GArBIwE,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,cAAe,KAAMkC,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXxD,EAAIC,EAAMD,EAAGsB,EAAM,SAAU,KAAMkC,EAAQ,QAAQ,CAAC,GAGlDA,GAAA,MAAAA,EAAS,MAAQA,EAAQ,KAAK,OAAS,IACzCxD,EAAIC,EAAMD,EAAGsB,EAAM,OAAQ,qBAAsBkC,EAAQ,IAAI,CAAC,GAG5DA,GAAA,MAAAA,EAAS,aACXxD,EAAIC,EACFD,EACAsB,EAAM,gBAAiB,KAAMkC,EAAQ,WAAW,GAAG,EACnDlC,EAAM,gBAAiB,KAAMkC,EAAQ,WAAW,GAAG,CAAA,GAKnDA,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCxD,EAAIC,EACFD,EACAsB,EAAM,cAAe,KAAMqC,CAAU,EACrCrC,EAAM,cAAe,KAAMqC,EAAa,GAAQ,CAAA,CAEpD,CAGA3D,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCuD,IACFzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAO1D,IAAI9B,GAHkB,MAAMxB,EAAQH,CAAC,GAGX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,aAAe7B,EAAM,OAAS,EAAG,CAC5C,MAAMgC,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,GAC1CT,EAAK,eAAe,YAAA,EAAc,SAASS,CAAU,CAAA,CAEzD,CAEA,OAAOhC,CACT,EAGA,0BACE3C,EACAgC,EACAwC,EACA,CACA,MAAME,EAAWpE,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMyD,EAAUpC,EAAM,aAAc,KAAMtC,CAAS,EAAGkB,EAAQ,eAAgB,MAAM,CAAC,EAU7F,GARIsD,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,cAAe,KAAMkC,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXxD,EAAIC,EAAMD,EAAGsB,EAAM,SAAU,KAAMkC,EAAQ,QAAQ,CAAC,GAGlDA,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCxD,EAAIC,EACFD,EACAsB,EAAM,cAAe,KAAMqC,CAAU,EACrCrC,EAAM,cAAe,KAAMqC,EAAa,GAAQ,CAAA,CAEpD,CAEA,OAAO1C,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,GAC1CT,EAAK,eAAe,YAAA,EAAc,SAASS,CAAU,CAAA,CAEzD,CAEA3C,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,0BACJ6B,EACAC,EACiB,CACjB,MAAM3D,EAAA,EAEN,MAAM4D,EAAWpE,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMyD,EAAUpC,EAAM,aAAc,KAAM,IAAI,CAAC,EAGnDkC,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMkC,EAAQ,MAAM,CAAC,GAI9DxD,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCuD,IACFzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAM1D,IAAI9B,GAFkB,MAAMxB,EAAQH,CAAC,GAEX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,KAC1CE,EAAAX,EAAK,8BAAL,YAAAW,EAAkC,cAAc,SAASF,IAAU,CAEvE,CAEA,OAAOhC,CACT,EAGA,6BACEX,EACAwC,EACA,CACA,MAAME,EAAWpE,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMyD,EAAUpC,EAAM,aAAc,KAAM,IAAI,EAAGpB,EAAQ,eAAgB,MAAM,CAAC,EAExF,OAAIsD,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMkC,EAAQ,MAAM,CAAC,GAGvDvC,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,KAC1CE,EAAAX,EAAK,8BAAL,YAAAW,EAAkC,cAAc,SAASF,IAAU,CAEvE,CAEA3C,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,WAAWmC,EAAoF,CACnG,MAAMhE,EAAA,EAEN,MAAM4D,EAAWpE,EAAWC,EAAI,OAAO,EACjCoB,MAAU,KAEVoD,EAAe,CACnB,GAAGD,EACH,iBAAkBA,EAAS,kBAAoB,YAC/C,aAAcnD,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAKhC,GAAI,CACF,GAAIoD,EAAQ,gBAAkBA,EAAQ,eAAiB,OAAW,CAChE,MAAMC,EAAQ5D,EAAIb,EAAI,eAAgBwE,EAAQ,cAAc,EACtDnB,EAAS,MAAMnC,EAAOuD,CAAK,EACjC,GAAIpB,EAAO,SAAU,CACnB,MAAMqB,EAAcrB,EAAO,KAAA,EACvBqB,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OAC/DF,EAAQ,aAAeE,EAAO,aAElC,CACF,CACF,OAAStB,EAAG,CACV,QAAQ,KAAK,qDAAsDA,CAAC,CACtE,CAGA,OADe,MAAMnD,EAAOkE,EAAUK,CAAO,GAC/B,EAChB,EAGA,MAAM,WAAWhF,EAAgB8B,EAAuC,CACtE,MAAMf,EAAA,EAEN,MAAMqD,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EAEjCmF,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCrD,EAAQ,mBAAqB,SAAWqD,EAAgB,iBAAmBrD,EAAQ,kBACnFA,EAAQ,aAAe,SAAWqD,EAAgB,WAAarD,EAAQ,YACvEA,EAAQ,8BAAgC,SAAWqD,EAAgB,4BAA8BrD,EAAQ,6BACzGA,EAAQ,iBAAmB,SAAWqD,EAAgB,eAAiBrD,EAAQ,gBAC/EA,EAAQ,iBAAmB,SAAWqD,EAAgB,eAAiBrD,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWqD,EAAgB,cAAgBrD,EAAQ,eAC7EA,EAAQ,cAAgB,SAAWqD,EAAgB,YAAcrD,EAAQ,aACzEA,EAAQ,SAAW,SAAWqD,EAAgB,OAASrD,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWqD,EAAgB,IAAMrD,EAAQ,KACzDA,EAAQ,eAAiB,SAAWqD,EAAgB,aAAerD,EAAQ,cAC3EA,EAAQ,iBAAmB,SAAWqD,EAAgB,eAAiBrD,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWqD,EAAgB,YAAcrD,EAAQ,aACzEA,EAAQ,QAAU,SAAWqD,EAAgB,MAAQrD,EAAQ,OAC7DA,EAAQ,QAAU,SAAWqD,EAAgB,MAAQrD,EAAQ,OAC7DA,EAAQ,WAAa,SAAWqD,EAAgB,SAAWrD,EAAQ,UACnEA,EAAQ,SAAW,SAAWqD,EAAgB,OAASrD,EAAQ,QAC/DA,EAAQ,eAAiB,SAAWqD,EAAgB,aAAerD,EAAQ,cAC3EA,EAAQ,aAAe,SAAWqD,EAAgB,WAAarD,EAAQ,YAI3E,GAAI,CACF,MAAMsD,EAAqBtD,EAAQ,iBAAmB,QAAaA,EAAQ,iBAAmB,KACxFuD,EAAavD,EAAQ,eAAiB,QAAaA,EAAQ,eAAiB,KAClF,GAAIsD,GAAsBC,EAAY,CACpC,MAAMC,EAAOxD,EAAQ,eACrB,GAAIwD,EAAM,CACR,MAAML,EAAQ5D,EAAIb,EAAI,eAAgB8E,CAAI,EACpCzB,EAAS,MAAMnC,EAAOuD,CAAK,EACjC,GAAIpB,EAAO,SAAU,CACnB,MAAMqB,EAAcrB,EAAO,KAAA,EACvBqB,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OAC/DC,EAAgB,aAAeD,EAAO,aAE1C,CACF,CACF,CACF,OAAStB,EAAG,CACV,QAAQ,KAAK,qDAAsDA,CAAC,CACtE,CAEA,MAAM7B,EAAUqC,EAASe,CAAe,CAC1C,EAGA,MAAM,WAAWnF,EAA+B,CAC9C,MAAMe,EAAA,EAEN,MAAMqD,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EACvC,MAAMgC,EAAUoC,CAAO,CACzB,EAGA,MAAM,uBAAuB3B,EAAoBrC,EAAwC,CACvF,MAAMW,EAAA,EAEN,MAAM4D,EAAWpE,EAAWC,EAAI,OAAO,EACjCS,EAAIC,EACRyD,EACApC,EAAM,iBAAkB,KAAMnC,CAAa,EAC3Ce,EAAQ,eAAgB,KAAK,CAAA,EAK/B,OAFsB,MAAMC,EAAQH,CAAC,GAEhB,KAAK,IAAII,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,CACZ,EAGA,MAAM,sBACJrB,EACAC,EACAV,EACAgG,EACAC,EACiB,CACjB,MAAMzE,EAAA,EAGN,MAAMoD,EAAO,MAAM,KAAK,YAAYnE,CAAM,EAC1C,GAAI,CAACmE,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMsB,EAAclG,GAAU4E,EAAK,eAAiBA,EAAK,cAAgB,OACnEuB,EAAsCvB,EAAK,gBAAkB,KAEnE,QAAQ,IAAI,kCAAmC,CAC7C,OAAAnE,EACA,UAAAC,EACA,qBAAAyF,EACA,cAAevB,EAAK,WACpB,YAAAsB,CAAA,CACD,EAGD,GAAI,CACF,MAAO3F,EAAa,mBAA2B,aAAcE,EAAQmE,EAAK,WAAYuB,EAAsB,CAC1G,OAAQ,qBACR,kBAAmBzF,EACnB,uBAAwByF,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,qCAAsCA,CAAU,CAC/D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,aACVA,EAAqB,QAAQ,YAAa,EAAE,IAE5CzF,GAEvB,QAAQ,IAAI,+EAA+E,EACpF,MAAM,KAAK,0BAA0BD,EAAQ0F,EAAsBzF,EAAWwF,EAAaF,EAAOC,CAAK,IAG9G,QAAQ,IAAI,gEAAgE,EACrE,MAAM,KAAK,iCAAiCxF,EAAQ0F,EAAsBzF,EAAWwF,EAAaF,EAAOC,CAAK,GAKrHE,GAAA,MAAAA,EAAsB,WAAW,iBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDzF,GAEvB,QAAQ,IAAI,+DAA+D,EACpE,MAAM,KAAK,8BAA8BD,EAAQ0F,EAAsBzF,EAAWwF,EAAaF,EAAOC,CAAK,IAGlH,QAAQ,IAAI,oEAAoE,EACzE,MAAM,KAAK,qCAAqCxF,EAAQ0F,EAAsBzF,EAAWwF,EAAaF,EAAOC,CAAK,GAUxHE,GAML,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,8BAA8B1F,EAAQC,EAAWwF,EAAaF,CAAK,IANnF,QAAQ,IAAI,yDAAyD,EAC9D,MAAM,KAAK,8BAA8BvF,EAAQC,EAAWwF,EAAaF,EAAOC,CAAK,EAMhG,EAGA,MAAM,yBACJxF,EACA0F,EACAzF,EACAwF,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgB3F,CAAS,GAGvD,MAAM,KAAK,0BAA0BD,EAAQ0F,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBzF,EAAQ4F,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWvF,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB2F,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,iDAAiD,EAG7D,GAAI,CACF,MAAM1F,EAAa,mBAAmB,aAAcE,EAAQC,EAAW2F,EAAuB,CAC5F,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BACJ5F,EACA0F,EACAjD,EACAgD,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BxF,EAAQ0F,EAAsBD,CAAW,EAM9E,MAAM,KAAK,WAAWzF,EAAQ,CAC5B,WAAYyC,EACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,OACb,MAAO+C,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,kDAAkD,EAG9D,GAAI,CACF,MAAM1F,EAAa,mBAAmB,aAAcE,EAAQyC,EAAY,KAAM,CAC5E,OAAQ,uBACR,SAAU,MACV,iBAAkBiD,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,gDAAiDA,CAAU,CAC1E,CAGA,OAAOD,CACT,EAGA,MAAM,iCACJ1F,EACA0F,EACAI,EACAL,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBE,CAAY,GAG1D,MAAM,KAAK,0BAA0B9F,EAAQ0F,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBzF,EAAQ4F,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWvF,EAAQ,CAC5B,WAAY8F,EACZ,iBAAkB,YAClB,eAAgBF,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAM1F,EAAa,mBAAmB,aAAcE,EAAQ8F,EAAcF,EAAuB,CAC/F,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,8BACJ5F,EACA0F,EACAjD,EACAgD,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BxF,EAAQ0F,EAAsBD,CAAW,EAG9E,MAAM,KAAK,WAAWzF,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,YAAa,YACb,MAAO6F,EACP,MAAOL,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAM1F,EAAa,mBAAmB,eAAgBE,EAAQ,KAAM,YAAa,CAC/E,OAAQ,yBACR,SAAU,MACV,iBAAkB0F,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,OAAOD,CACT,EAGA,MAAM,qCACJ1F,EACA0F,EACAI,EACAL,EACAF,EACAC,EACiB,CACjB,MAAMO,EAAoB,YAAYD,CAAY,GAGlD,MAAM,KAAK,0BAA0B9F,EAAQ0F,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBzF,EAAQ+F,EAAmBN,EAAa,eAAgB,iBAAkBF,CAAK,EAG/G,MAAM,KAAK,WAAWvF,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB+F,EAChB,YAAa,YACb,MAAOP,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAM1F,EAAa,mBAAmB,aAAcE,EAAQ,KAAM+F,EAAmB,CACnF,OAAQ,uBACR,SAAU,MACV,iBAAkBL,EAClB,eAAgBK,EAChB,OAAQN,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOI,CACT,EAGA,MAAM,8BACJ/F,EACAC,EACAwF,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgB3F,CAAS,GAGvD,MAAM,KAAK,qBAAqBD,EAAQ4F,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWvF,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB2F,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAM1F,EAAa,mBAAmB,aAAcE,EAAQC,EAAW2F,EAAuB,CAC5F,OAAQ,uBACR,SAAU,IACV,YAAa,YACb,eAAgBA,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BAA0B5F,EAAgBI,EAAuB4F,EAAoC,CACzG,MAAMtD,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAI,CAACC,EAAgB,SAAU,CAC7B,QAAQ,KAAK,wCAAyCvC,CAAa,EACnE,MACF,CAEA,MAAM6F,EAAetD,EAAgB,KAAA,EAE/BuD,GADkBD,EAAa,UAAY,CAAA,GACV,OAAQE,GAAeA,IAAOnG,CAAM,EAE3E,GAAIkG,EAAe,SAAW,EAE5B,GAAI,CACF,MAAMlE,EAAUU,CAAc,EAC9B,QAAQ,IAAI,iCAAkCtC,CAAa,EAG3D,GAAI,CACF,MAAMN,EAAa,0BAA0BM,EAAe,UAAW6F,EAAc,IAAI,CAC3F,OAASN,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAAS5G,EAAO,CACd,QAAQ,MAAM,wCAAyCqB,EAAerB,CAAK,CAE7E,KAGA,IAAI,CACF,MAAM4F,EAAWpE,EAAWC,EAAI,OAAO,EACjC4F,EAAalF,EAAMyD,EAAUpC,EAAM,WAAY,KAAM2D,CAAc,CAAC,EAGpEG,GAFgB,MAAMjF,EAAQgF,CAAU,GAEZ,KAC/B,IAAI/E,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAACiF,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD7B,EAAa,CACjB,SAAU0B,EACV,OAAQM,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMzE,EAAUW,EAAgB8B,CAAU,EAC1C,QAAQ,IAAI,wCAAyCpE,EAAe,cAAeoG,CAAU,EAG7F,GAAI,CACF,MAAM1G,EAAa,0BAA0BM,EAAe,UAAW6F,EAAczB,CAAU,CACjG,OAASmB,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CACF,OAAS5G,EAAO,CACd,QAAQ,MAAM,gDAAiDqB,EAAerB,CAAK,CAErF,CAEJ,EAGA,MAAM,qBACJiB,EACAI,EACAb,EACAkH,EACAC,EACAnB,EACe,CACf,MAAM7C,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAElB,GAAI,CACF,MAAMsD,EAAetD,EAAgB,KAAA,EAC/BgE,EAAkBV,EAAa,UAAY,CAAA,EAC3CC,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGS,EAAiB3G,CAAM,CAAC,CAAC,EAG1D2E,EAAWpE,EAAWC,EAAI,OAAO,EACjC4F,EAAalF,EAAMyD,EAAUpC,EAAM,WAAY,KAAM2D,CAAc,CAAC,EAGpEG,GAFgB,MAAMjF,EAAQgF,CAAU,GAEZ,KAC/B,IAAI/E,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAACiF,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD7B,EAAa,CACjB,SAAU0B,EACV,OAAQM,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMzE,EAAUW,EAAgB8B,CAAU,EAC1C,QAAQ,IAAI,yCAA0CpE,EAAe,cAAeoG,CAAU,EAG9F,GAAI,CACF,MAAM1G,EAAa,0BAA0BM,EAAe,UAAW6F,EAAczB,CAAU,CACjG,OAASmB,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CAGA,GAAI,CACF,MAAMiB,EAAQX,EAAa,aAC3B,GAA2BW,GAAU,KAAM,CACzC,MAAMxC,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EACvC,MAAM+B,EAAUqC,EAAS,CAAE,aAAcwC,EAAO,aAAc,IAAI,KAAA,EAAO,YAAA,EAAe,CAC1F,CACF,OAAShD,EAAG,CACV,QAAQ,KAAK,4CAA6C5D,EAAQ4D,CAAC,CACrE,CACF,OAAS7E,EAAO,CACd,QAAQ,MAAM,2CAA4CqB,EAAerB,CAAK,CAEhF,KAGA,IAAI,CACF,MAAM8H,EAAU,MAAM/F,EAAe,WAAWV,EAAc,QAAQqG,IAAoB,WAAa,gBAAkB,YAAa,EAAE,CAAC,EACnIK,GAAcD,GAAA,YAAAA,EAAS,OAAQ,QAE/BrE,EAAkB,CACtB,WAAYpC,EAAc,QAAQqG,IAAoB,WAAa,gBAAkB,YAAa,EAAE,EACpG,aAAc,KACd,iBAAkBhH,EAAiB,IAAI,IAAM,EAC7C,OAAQgH,IAAoB,WAAa,YAAcK,EACvD,iBAAkBL,EAClB,eAAgB,UAChB,OAAAlH,EACA,gBAAiB,cACjB,MAAOgG,GAAS,yBAAyBkB,IAAoB,WAAa,iBAAmB,SAAS,IAAIA,IAAoB,WAAa,YAAc,SAAS,GAClK,OAAQ,UACR,mBAAoBA,IAAoB,WAAa,cAAgB,SACrE,cAAeC,EACf,SAAU,CAAC1G,CAAM,EACjB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAM+G,EAAOrE,EAAgBF,CAAe,EAC5C,QAAQ,IAAI,8BAA+BpC,EAAe,UAAWb,CAAM,EAG3E,GAAI,CACF,MAAMO,EAAa,0BAA0BM,EAAe,UAAW,KAAMoC,CAAe,CAC9F,OAASmD,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAAS5G,EAAO,CACd,QAAQ,MAAM,sCAAuCqB,EAAerB,CAAK,CAE3E,CAEJ,EAGA,MAAM,4BACJiI,EACA/G,EACAgH,EAII,CAAA,EACa,CACjB,MAAMlG,EAAA,EAIN,MAAM4D,EAAWpE,EAAWC,EAAI,OAAO,EACjC4F,EAAalF,EAAMyD,EAAUpC,EAAM,WAAY,KAAMyE,CAAO,CAAC,EAC7DE,EAAgB,MAAM9F,EAAQgF,CAAU,EAE9C,GAAIc,EAAc,MAChB,MAAM,IAAI,MAAM,+BAA+B,EAGjD,MAAMC,EAAyB,gBAAgBlH,CAAS,GAGxD,UAAWmH,KAAWF,EAAc,KAAM,CACxC,MAAMlH,EAASoH,EAAQ,GACjBrC,EAAgBqC,EAAQ,KAAA,EACxB3B,EAAcwB,EAAe,QAAUlC,EAAS,eAAiBA,EAAS,cAAgB,OAC1FW,EAAsCX,EAAS,gBAAkB,KAGvE,GAAIW,GAAA,MAAAA,EAAsB,WAAW,aAGnC,GAFsBA,EAAqB,QAAQ,YAAa,EAAE,IAE5CzF,EAAW,CAG/B,QAAQ,IAAI,8FAA+FD,CAAM,EACjH,MAAM,KAAK,0BAA0BA,EAAQ0F,EAAsBD,CAAW,EAC9E,MAAM,KAAK,WAAWzF,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,OACb,MAAOgH,EAAe,MACtB,MAAOA,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,KAAO,CAEL,QAAQ,IAAI,2FAA4FjH,CAAM,EAC9G,MAAM,KAAK,0BAA0BA,EAAQ0F,EAAsBD,CAAW,EAC9E,MAAM,KAAK,qBAAqBzF,EAAQmH,EAAwB1B,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAWjH,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgBkH,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,CAIF,GAAI,CAACvB,EAAsB,CACzB,QAAQ,IAAI,qDAAsD1F,CAAM,EACxE,MAAM,KAAK,qBAAqBA,EAAQmH,EAAwB1B,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAWjH,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgBkH,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,CAGA,QAAQ,IAAI,oEAAqEjH,EAAQ0F,CAAoB,EAC7G,MAAM,KAAK,qBAAqB1F,EAAQmH,EAAwB1B,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAWjH,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgBkH,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,CAEA,OAAOE,CACT,EAGA,MAAM,sBACJnH,EACAC,EACAV,EACAgG,EACiB,CACjB,MAAMxE,EAAA,EAGN,MAAMoD,EAAO,MAAM,KAAK,YAAYnE,CAAM,EAC1C,GAAI,CAACmE,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMsB,EAAclG,GAAU4E,EAAK,eAAiBA,EAAK,cAAgB,OACnEuB,EAAsCvB,EAAK,gBAAkB,KAEnE,QAAQ,IAAI,8BAA+B,CACzC,OAAAnE,EACA,UAAAC,EACA,qBAAAyF,EACA,cAAevB,EAAK,WACpB,YAAAsB,CAAA,CACD,EAGD,GAAI,CACF,MAAO3F,EAAa,mBAA2B,SAAUE,EAAQmE,EAAK,WAAYuB,EAAsB,CACtG,OAAQ,iBACR,kBAAmBzF,EACnB,uBAAwByF,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,iCAAkCA,CAAU,CAC3D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,kBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDzF,GAEvB,QAAQ,IAAI,mEAAmE,EACxE,MAAM,KAAK,yBAAyBD,EAAQ0F,EAAsBzF,EAAWwF,EAAaF,CAAK,IAK1G,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,gBAAgBvF,EAAQC,EAAWwF,EAAaF,CAAK,EACzE,EAGA,MAAM,yBACJvF,EACA0F,EACAjD,EACAgD,EACAF,EACiB,CAMjB,MAAM,KAAK,0BAA0BvF,EAAQ0F,EAAsBD,CAAW,EAG9E,MAAM,KAAK,WAAWzF,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,YACb,MAAAuF,CAAA,CACD,EAED,QAAQ,IAAI,yDAAyD,EAGrE,GAAI,CACF,MAAMzF,EAAa,mBAAmB,SAAUE,EAAQ,KAAM0F,EAAsB,CAClF,OAAQ,mBACR,SAAU,uBACV,iBAAkBA,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAGA,OAAOD,CACT,EAGA,MAAM,gBACJ1F,EACAC,EACAwF,EACAF,EACiB,CAEjB,IAAIuB,EAAc,QAClB,GAAI,CACF,MAAMD,EAAU,MAAM/F,EAAe,WAAWb,CAAS,EACzD6G,GAAcD,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAAS9H,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAGA,MAAMgH,EAAoB,YAAY9F,CAAS,GAEzCuC,EAAkB,CACtB,WAAYvC,EACZ,aAAc,KACd,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQqH,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQrB,EACR,gBAAiB,cACjB,MAAOF,GAAS,+EAChB,OAAQ,UACR,mBAAoB,SACpB,cAAe,iBACf,SAAU,CAACvF,CAAM,EACjB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGjC0C,EAAiBrB,EAAIb,EAAI,eAAgBuF,CAAiB,EAChE,MAAMgB,EAAOrE,EAAgBF,EAAiB,CAAE,MAAO,GAAM,EAG7D,MAAM,KAAK,WAAWxC,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB+F,EAChB,YAAa,WAAA,CACd,EAED,QAAQ,IAAI,0CAA0C,EAGtD,GAAI,CACF,MAAMjG,EAAa,mBAAmB,SAAUE,EAAQ,KAAM+F,EAAmB,CAC/E,OAAQ,mBACR,SAAU,aACV,YAAa,YACb,eAAgBA,EAChB,OAAQN,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAEA,OAAOI,CACT,EAGA,MAAM,2BACJU,EACAxG,EACAoH,EACe,CACf,MAAMtG,EAAA,EAGN,MAAMoG,EAAyBV,IAAoB,OAC/C,YAAYxG,CAAS,GACrB,gBAAgBA,CAAS,GAGvByC,EAAiBrB,EAAIb,EAAI,eAAgB2G,CAAsB,EAC/DxE,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAI,CAACC,EAAgB,SACnB,MAAM,IAAI,MAAM,uBAAuB,EAIzC,MAAMqE,EADkBrE,EAAgB,KAAA,EACR,UAAY,CAAA,EAG5C,MAAMZ,EAAUW,EAAgB,CAC9B,OAAQ,YACR,eAAgB2E,EAChB,iBAAkB5H,EAAiB,IAAI,IAAM,EAC7C,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAMwE,EAAQC,EAAW1D,CAAE,EAC3B,UAAWR,KAAUgH,EAAS,CAC5B,MAAM5C,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EACnCyG,IAAoB,OAEtBxC,EAAM,OAAOG,EAAS,CACpB,eAAgB,KAChB,iBAAkB,OAClB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGDH,EAAM,OAAOG,EAAS,CACpB,WAAY,KACZ,eAAgB,KAChB,iBAAkB,YAClB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CAEL,CAEA,MAAMH,EAAM,OAAA,CACd,EAGA,MAAM,YAAYjE,EAAsC,CACtD,MAAMe,EAAA,EAEN,MAAMqD,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EACjCsH,EAAW,MAAM5F,EAAO0C,CAAO,EAErC,OAAIkD,EAAS,SACJ,CACL,QAASA,EAAS,GAClB,GAAGA,EAAS,KAAA,CAAK,EAGd,IACT,EAGA,MAAM,cAAcrH,EAAmBsH,EAAyC,CAE9E,MAAMC,EAAe,MAAM,KAAK,YAAYD,CAAc,EAC1D,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,MAAM5F,MAAU,KACV6F,EAAY,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACtEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,MACpB,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,eAAgBF,EAAa,eAC7B,WAAYvH,EACZ,aAAc2B,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQ4F,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQjE,GAAO,CACrCiE,EAAejE,CAAG,IAAM,QAC1B,OAAOiE,EAAejE,CAAG,CAE7B,CAAC,EAGD,MAAMU,EAAU/C,EAAIb,EAAI,QAASiH,CAAS,EAC1C,aAAMV,EAAO3C,EAASuD,CAAc,EAE7BF,CACT,EAGA,MAAM,uBACJxH,EACAG,EACAwH,EACAC,EACAjF,EACAkF,EACmB,CACnB,MAAM7D,EAAQC,EAAW1D,CAAE,EACrB6C,EAA2B,CAAA,EAC3BzB,MAAU,KAGhB,IAAImG,EACJ,GAAI,CACF,GAAiCD,GAAe,MAAS1H,EAAe,CACtE,MAAM6E,EAAQ5D,EAAIb,EAAI,eAAgBJ,CAAa,EAC7CyD,EAAS,MAAMnC,EAAOuD,CAAK,EACjC,GAAIpB,EAAO,SAAU,CACnB,MAAMqB,EAAcrB,EAAO,KAAA,EACvBqB,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OAC/D6C,EAAe7C,EAAO,aAE1B,CACF,CACF,MAAY,CAEZ,CAEA,UAAWH,KAAYnC,EAAO,CAC5B,MAAM5C,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACzEqD,EAAe,KAAKrD,CAAM,EAE1B,MAAMoE,EAAU/C,EAAIb,EAAI,QAASR,CAAM,EACjCgI,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEnE7D,EAAY,CAChB,QAASnE,EACT,YAAa+E,EAAS,YACtB,OAAQ8C,EACR,IAAK9C,EAAS,KAAO,GACrB,eAAgBA,EAAS,eACzB,cAAeA,EAAS,cACxB,aAAcA,EAAS,cAAgB,GACvC,eAAgB,cAChB,YAAa,OACb,MAAOA,EAAS,MAChB,OAAQiD,EACR,SAAU,GACV,eAAgB5H,EAChB,WAAYH,EACZ,aAAc2H,EACd,aAAchG,EAAI,YAAA,EAClB,OAAQ,CAAA,CAAC,EAIqBkG,GAAe,KAC7C3D,EAAK,aAAe2D,EACXC,IAAiB,SAC1B5D,EAAK,aAAe4D,GAItB,MAAME,EAAY9D,EAElBF,EAAM,IAAIG,EAAS6D,CAAS,CAC9B,CAEA,aAAMhE,EAAM,OAAA,EACLZ,CACT,CACF,EAGa6E,EAA2B,CAEtC,MAAM,0BACJzD,EACAC,EACiB,CACjB,MAAMC,EAAWpE,EAAWC,EAAI,oBAAoB,EACpD,IAAIS,EAAIC,EAAMyD,CAAQ,EAGlBF,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMkC,EAAQ,MAAM,CAAC,GAI9DxD,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCuD,IACFzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBzD,EAAIC,EAAMD,EAAG4D,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAM1D,IAAI9B,GAFkB,MAAMxB,EAAQH,CAAC,GAEX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,KAC1CE,EAAAX,EAAK,8BAAL,YAAAW,EAAkC,cAAc,SAASF,IAAU,CAEvE,CAEA,OAAOhC,CACT,EAGA,MAAM,yBAAyB5C,EAAsC,CACnE,MAAMoE,EAAU/C,EAAIb,EAAI,qBAAsBR,CAAM,EAC9CsH,EAAW,MAAM5F,EAAO0C,CAAO,EAErC,OAAIkD,EAAS,SACJ,CACL,QAASA,EAAS,GAClB,GAAGA,EAAS,KAAA,CAAK,EAGd,IACT,EAGA,MAAM,+BAA+BC,EAAyC,CAE5E,MAAMC,EAAe,MAAM,KAAK,yBAAyBD,CAAc,EACvE,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,4CAA4C,EAG9D,MAAM5F,MAAU,KACV6F,EAAY,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACvEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,MACpB,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,iBAAkB,YAClB,4BAA6BF,EAAa,6BAA+B,GACzE,eAAgBA,EAAa,eAC7B,aAAc5F,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQ4F,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQjE,GAAO,CACrCiE,EAAejE,CAAG,IAAM,QAC1B,OAAOiE,EAAejE,CAAG,CAE7B,CAAC,EAGD,MAAMU,EAAU/C,EAAIb,EAAI,qBAAsBiH,CAAS,EACvD,aAAMV,EAAO3C,EAASuD,CAAc,EAE7BF,CACT,EAGA,MAAM,4BAA4B1C,EAAoF,CACpH,MAAMJ,EAAWpE,EAAWC,EAAI,oBAAoB,EAC9CoB,MAAU,KAEVoD,EAAU,CACd,GAAGD,EACH,iBAAkBA,EAAS,kBAAoB,YAC/C,aAAcnD,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAIhC,OADe,MAAMnB,EAAOkE,EAAUK,CAAO,GAC/B,EAChB,EAGA,MAAM,4BAA4BhF,EAAgB8B,EAAuC,CACvF,MAAMsC,EAAU/C,EAAIb,EAAI,qBAAsBR,CAAM,EAE9CmF,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCrD,EAAQ,mBAAqB,SAAWqD,EAAgB,iBAAmBrD,EAAQ,kBACnFA,EAAQ,8BAAgC,SAAWqD,EAAgB,4BAA8BrD,EAAQ,6BACzGA,EAAQ,iBAAmB,SAAWqD,EAAgB,eAAiBrD,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWqD,EAAgB,cAAgBrD,EAAQ,eAC7EA,EAAQ,cAAgB,SAAWqD,EAAgB,YAAcrD,EAAQ,aACzEA,EAAQ,SAAW,SAAWqD,EAAgB,OAASrD,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWqD,EAAgB,IAAMrD,EAAQ,KACzDA,EAAQ,eAAiB,SAAWqD,EAAgB,aAAerD,EAAQ,cAC3EA,EAAQ,iBAAmB,SAAWqD,EAAgB,eAAiBrD,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWqD,EAAgB,YAAcrD,EAAQ,aACzEA,EAAQ,QAAU,SAAWqD,EAAgB,MAAQrD,EAAQ,OAC7DA,EAAQ,QAAU,SAAWqD,EAAgB,MAAQrD,EAAQ,OAC7DA,EAAQ,WAAa,SAAWqD,EAAgB,SAAWrD,EAAQ,UACnEA,EAAQ,SAAW,SAAWqD,EAAgB,OAASrD,EAAQ,QAEnE,MAAMC,EAAUqC,EAASe,CAAe,CAC1C,EAGA,MAAM,4BAA4BnF,EAA+B,CAC/D,MAAMoE,EAAU/C,EAAIb,EAAI,qBAAsBR,CAAM,EACpD,MAAMgC,EAAUoC,CAAO,CACzB,EAGA,MAAM,2BAA6D,CACjE,MAAMO,EAAWpE,EAAWC,EAAI,oBAAoB,EAC9C2B,EAAW,MAAMgG,EAAmBxD,CAAQ,EAE5CyD,EAAgBlH,EAAMyD,CAAQ,EAC9B0D,EAAe,MAAMjH,EAAQgH,CAAa,EAEhD,IAAIE,EAAiB,EACjBC,EAAiB,EACjBC,EAAY,EAEhB,OAAAH,EAAa,KAAK,QAAQhH,GAAO,CAE/B,OADaA,EAAI,KAAA,EACJ,iBAAA,CACX,IAAK,YACHiH,IACA,MACF,IAAK,YACHC,IACA,MACF,IAAK,OACHC,IACA,KAAA,CAEN,CAAC,EAEM,CACL,WAAYrG,EAAS,KAAA,EAAO,MAC5B,eAAAmG,EACA,eAAAC,EACA,UAAAC,CAAA,CAEJ,EAGA,6BACEvG,EACAwC,EACA,CACA,MAAME,EAAWpE,EAAWC,EAAI,oBAAoB,EACpD,IAAIS,EAAIC,EAAMyD,EAAUxD,EAAQ,eAAgB,MAAM,CAAC,EAEvD,OAAIsD,GAAA,MAAAA,EAAS,SACXxD,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMkC,EAAQ,MAAM,CAAC,GAGvDvC,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAIoD,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvC7B,EAAQA,EAAM,OAAOuB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASS,CAAU,GAClDT,EAAK,OAAO,YAAA,EAAc,SAASS,CAAU,GAC7CT,EAAK,IAAI,YAAA,EAAc,SAASS,CAAU,KAC1CE,EAAAX,EAAK,8BAAL,YAAAW,EAAkC,cAAc,SAASF,IAAU,CAEvE,CAEA3C,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,sBACJ5C,EACAC,EACAV,EACAgG,EACiB,CAEjB,MAAMpB,EAAO,MAAM,KAAK,yBAAyBnE,CAAM,EACvD,GAAI,CAACmE,EACH,MAAM,IAAI,MAAM,mCAAmC,EAErD,MAAMsB,EAAclG,GAAU4E,EAAK,eAAiBA,EAAK,cAAgB,OAGzE,IAAI2C,EAAc,UAClB,GAAI,CACF,MAAMD,EAAU,MAAM/F,EAAe,WAAWb,CAAS,EACzD6G,GAAcD,GAAA,YAAAA,EAAS,OAAQ,SACjC,OAAS9H,EAAO,CACd,QAAQ,KAAK,sDAAuDA,CAAK,CAC3E,CAGA,MAAMyD,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQ,YACR,iBAAkB,WAClB,eAAgB,UAChB,OAAQgG,EACR,gBAAiB,cACjB,MAAOF,GAAS,GAAGuB,CAAW,sBAC9B,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXxE,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiB,MAAMjC,EAAO6B,EAAiBE,CAAe,EAGpE,aAAM,KAAK,4BAA4BxC,EAAQ,CAC7C,iBAAkB,YAClB,eAAgB0C,EAAe,EAAA,CAChC,EAEMA,EAAe,EACxB,EAGA,MAAM,4BACJsE,EACA/G,EACAgH,EAII,CAAA,EACe,CACnB,MAAMhD,EAAQC,EAAW1D,CAAE,EACrBiI,EAA2B,CAAA,EAC3B7G,MAAU,KAGV8G,EAAmBnI,EAAWC,EAAI,oBAAoB,EACtDmI,EAAqBzH,EAAMwH,EAAkBnG,EAAM,WAAY,KAAMyE,CAAO,CAAC,EAC7E4B,EAAwB,MAAMxH,EAAQuH,CAAkB,EAE9D,GAAIC,EAAsB,MACxB,MAAM,IAAI,MAAM,mCAAmC,EAIrD,IAAI9B,EAAc,UAClB,GAAI,CACF,MAAMD,EAAU,MAAM/F,EAAe,WAAWb,CAAS,EACzD6G,GAAcD,GAAA,YAAAA,EAAS,OAAQ,SACjC,OAAS9H,EAAO,CACd,QAAQ,KAAK,sDAAuDA,CAAK,CAC3E,CAGA,MAAMyD,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiBmC,CAAG,EACtC,OAAQ,YACR,iBAAkB,WAClB,eAAgB,UAChB,OAAQqF,EAAe,QAAU,OACjC,gBAAiB,cACjB,MAAOA,EAAe,OAAS,GAAGH,CAAW,sBAC7C,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXxE,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiBrB,EAAIiB,CAAe,EAC1C2B,EAAM,IAAIvB,EAAgBF,CAAe,EACzCiG,EAAe,KAAK/F,EAAe,EAAE,EAGrCkG,EAAsB,KAAK,QAASC,GAAoB,CACtD,MAAMC,EAAmBD,EAAgB,KAAA,EAGnCE,EAAgB,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAC1EC,EAAiB3H,EAAIb,EAAI,WAAYP,EAAW,QAAS8I,CAAa,EAEtEE,EAAkB,CACtB,QAASF,EACT,YAAaD,EAAiB,YAC9B,OAAQA,EAAiB,OACzB,IAAKA,EAAiB,IACtB,cAAeA,EAAiB,cAChC,aAAcA,EAAiB,cAAgB,GAC/C,eAAgB,OAChB,YAAa,OACb,MAAOA,EAAiB,MACxB,MAAO7B,EAAe,OAAS,GAC/B,OAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACnE,SAAU,GACV,eAAgBvE,EAAe,GAC/B,WAAYzC,EACZ,aAAc6I,EAAiB,aAC/B,aAAclH,EAAI,YAAA,EAClB,OAAQkH,EAAiB,QAAU,CAAA,CAAC,EAGtC7E,EAAM,IAAI+E,EAAgBC,CAAe,CAC3C,CAAC,EAGDjC,EAAQ,QAAQhH,GAAU,CACxB,MAAMoE,EAAU/C,EAAIb,EAAI,qBAAsBR,CAAM,EACpDiE,EAAM,OAAOG,EAAS,CACpB,iBAAkB,OAClB,eAAgB1B,EAAe,GAC/B,aAAcd,EAAI,YAAA,CAAY,CAC/B,CACH,CAAC,EAED,MAAMqC,EAAM,OAAA,EAIZ,MAAMiF,GADe,MAAM5F,EAAoB,kBAAkBrD,CAAS,GACpC,OACtC,aAAMa,EAAe,cAAcb,EAAW,CAC5C,SAAU,CACR,WAAYiJ,EACZ,aAActH,CAAA,CAChB,CACmB,EAEd6G,CACT,EAGE,MAAM,sBAAsBzI,EAAgBI,EAAuBH,EAAkC,CAErG,MAAMyC,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EACnF,MAAM2B,EAAUW,EAAgB,CAC9B,OAAQ,WACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAM,KAAK,4BAA4B1C,EAAQ,CAC7C,iBAAkB,YAClB,eAAgB,MAAA,CACjB,CACH,EAGA,MAAM,eACJA,EACAI,EACAH,EACAoH,EACe,CAEf,MAAM3E,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EACnF,MAAM2B,EAAUW,EAAgB,CAC9B,OAAQ,YACR,iBAAkBjD,EAAiB,IAAI,IAAM,EAC7C,eAAgB4H,EAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAM,KAAK,4BAA4BrH,EAAQ,CAC7C,iBAAkB,OAClB,eAAgB,MAAA,CACjB,CACH,EAGA,MAAM,4BACJA,EACAC,EACAV,EACAgG,EACiB,CAEjB,MAAM4D,EAAkB5I,EAAWC,EAAI,WAAYP,EAAW,OAAO,EAC/DmJ,EAAYlI,EAAMiI,EAAiB5G,EAAM,UAAW,KAAMvC,CAAM,CAAC,EACjEsH,EAAW,MAAMlG,EAAQgI,CAAS,EAExC,GAAI9B,EAAS,MACX,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAMvC,EAAWuC,EAAS,KAAK,CAAC,EAAE,KAAA,EAG5B9E,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQ,kBACR,iBAAkB,WAClB,eAAgB,UAChB,OAAAF,EACA,gBAAiB,cACjB,MAAOgG,GAAS,oDAChB,WAAY,SACZ,OAAQ,UACR,mBAAoB,SACpB,cAAe,sBAAA,EAGXjD,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiB,MAAMjC,EAAO6B,EAAiBE,CAAe,EAG9D6G,EAAkB,CACtB,YAAatE,EAAS,YACtB,OAAQA,EAAS,OACjB,IAAKA,EAAS,IACd,MAAOA,EAAS,MAChB,aAAcA,EAAS,aACvB,eAAgBA,EAAS,eACzB,YAAaA,EAAS,aAAe,OACrC,MAAOA,EAAS,MAChB,MAAOA,EAAS,MAChB,OAAQA,EAAS,OACjB,SAAUA,EAAS,UAAY,GAC/B,iBAAkB,YAClB,4BAA6B,8BAC7B,eAAgBrC,EAAe,GAC/B,OAAQqC,EAAS,QAAU,CAAA,CAAC,EAG9B,aAAM,KAAK,4BAA4BsE,CAAe,EAGtD,MAAMrH,EAAUsF,EAAS,KAAK,CAAC,EAAE,GAAG,EAE7B5E,EAAe,EACxB,CACF,EAGa4G,EAAsB,CAEjC,MAAM,2BACJtJ,EACAC,EACAsJ,EACe,CAGf,GAFA,QAAQ,IAAI,wCAAyC,CAAE,OAAAvJ,EAAQ,UAAAC,EAAW,YAAAsJ,EAAa,EAEnFA,IAAgB,YAAa,CAC/B,QAAQ,IAAI,8CAA+CA,CAAW,EACtE,MACF,CAEA,GAAI,CACF,QAAQ,IAAI,+BAAgCvJ,CAAM,EAElD,MAAMmE,EAAO,MAAMb,EAAoB,YAAYtD,CAAM,EACzD,GAAI,CAACmE,EACH,MAAM,IAAI,MAAM,gBAAgB,EASlC,GAPA,QAAQ,IAAI,gBAAiBA,EAAK,QAAS,eAAgBA,EAAK,YAAa,cAAeA,EAAK,UAAU,EAOvGA,EAAK,gBAAkBA,EAAK,eAAe,WAAW,eAAe,GAC7CA,EAAK,eAAe,QAAQ,gBAAiB,EAAE,IAC/ClE,EAAW,CACnC,QAAQ,IAAI,uFAAuF,EAGnG,MAAMqD,EAAoB,0BAA0Ba,EAAK,QAASA,EAAK,eAAgBA,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAGxI,MAAMb,EAAoB,WAAWa,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAED,GAAI,CACF,MAAMrE,EAAa,mBAAmB,eAAgBE,EAAQ,KAAMmE,EAAK,eAAgB,CACvF,OAAQ,yBACR,SAAU,qBACV,iBAAkBA,EAAK,eACvB,UAAW,YACX,OAAQA,EAAK,eAAiBA,EAAK,cAAgB,MAAA,CACpD,CACH,OAASwB,EAAY,CACnB,QAAQ,KAAK,mEAAoEA,CAAU,CAC7F,CAEA,QAAQ,IAAI,oFAAoF,EAChG,MACF,CAIF,QAAQ,IAAI,iEAAiE,EAG7E,GAAI,CACF,MAAO7F,EAAa,mBAA2B,eAAgBE,EAAQmE,EAAK,WAAYA,EAAK,eAAgB,CAC3G,OAAQ,uBACR,cAAe,YACf,uBAAwBA,EAAK,cAAA,CAC9B,CACH,OAASwB,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CAEA,MAAMvF,EAAgB,MAAM,KAAK,sBAC/B+D,EACAlE,EACA,8EAAA,EAGF,QAAQ,IAAI,yCAAyC,EAErD,MAAMqD,EAAoB,WAAWa,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgB/D,EAChB,MAAO,GACP,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,GAAI,CACF,MAAMN,EAAa,mBAAmB,eAAgBE,EAAQ,KAAMI,EAAe,CACjF,OAAQ,yBACR,gBAAiB+D,EAAK,WACtB,eAAgB/D,EAChB,OAAQ+D,EAAK,eAAiBA,EAAK,cAAgB,MAAA,CACpD,CACH,OAASwB,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,QAAQ,IAAI,iDAAiD,EAE7D,QAAQ,IAAI,uCAAuC,CACrD,OAAS5G,EAAO,CACd,cAAQ,MAAM,0CAA2CA,CAAK,EACxDA,CACR,CACF,EAGA,MAAM,sBACJoF,EACAlE,EACAuJ,EACwB,CACxB,QAAQ,IAAI,kDAAmDrF,EAAK,OAAO,EAG3E,IAAI2C,EAAc,QAClB,GAAI,CACF,MAAMD,EAAU,MAAM/F,EAAe,WAAWb,CAAS,EACzD6G,GAAcD,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAAS9H,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAIA,GAAIoF,EAAK,gBAAkBA,EAAK,eAAe,WAAW,eAAe,GAC7CA,EAAK,eAAe,QAAQ,gBAAiB,EAAE,IAC/ClE,EACxB,eAAQ,IAAI,sIAAsI,EAGlJ,MAAMqD,EAAoB,0BAA0Ba,EAAK,QAASA,EAAK,eAAgBA,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EACxI,MAAMb,EAAoB,WAAWa,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGM,KAIX,MAAMgD,EAAyB,YAAYlH,CAAS,GACpD,QAAQ,IAAI,+BAAgCkH,CAAsB,EAGlE,MAAMzE,EAAiBrB,EAAIb,EAAI,eAAgB2G,CAAsB,EAC/DxE,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAE5B,QAAQ,IAAI,gEAAgE,EAC5E,MAAMsD,EAAetD,EAAgB,KAAA,EAC/BgE,EAAkBV,EAAa,UAAY,CAAA,EAC3CC,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGS,EAAiBxC,EAAK,OAAO,CAAC,CAAC,EAGhEQ,EAAWpE,EAAWC,EAAI,OAAO,EACjC4F,EAAalF,EAAMyD,EAAUpC,EAAM,WAAY,KAAM2D,CAAc,CAAC,EAGpEG,GAFgB,MAAMjF,EAAQgF,CAAU,GAEZ,KAC/B,IAAI/E,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAACiF,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENkD,EAAyB,CAC7B,GAAGxD,EACH,SAAUC,EACV,OAAQG,EACR,MAAOmD,GAAmB,+EAC1B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMzC,EAAOrE,EAAgB+G,EAAwB,CAAE,MAAO,GAAM,EAEpE,QAAQ,IAAI,uCAAwCvD,EAAe,OAAQ,iBAAkBG,CAAW,CAC1G,KAAO,CAEL,MAAMqD,EAAmBvF,EAAK,eAAiBA,EAAK,cAAgB,OAG9D3B,EAAkB,CACtB,WAAYvC,EACZ,aAAc,KACd,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQqH,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQ,WAAW4C,CAAuB,EAAE,QAAQ,CAAC,EACrD,gBAAiB,cACjB,MAAOF,GAAmB,+EAC1B,OAAQ,UACR,mBAAoB,SACpB,cAAe,iBACf,SAAU,CAACrF,EAAK,OAAO,EACvB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,QAAQ,IAAI,oDAAqD3B,EAAgB,MAAM,EAEvF,MAAMuE,EAAOrE,EAAgBF,EAAiB,CAAE,MAAO,GAAM,CAC/D,CAEA,eAAQ,IAAI,iDAAiD,EACtD2E,CACT,CACF,EAGawC,EAAqB,CAEhC,MAAM,mCACJ3J,EACAC,EACAV,EACAgG,EACiB,CACjB,OAAO,MAAMjC,EAAoB,sBAAsBtD,EAAQC,EAAWV,EAAQgG,CAAK,CACzF,EAGA,MAAM,8BACJvF,EACA4J,EACA3J,EACe,CAEf,MAAMqD,EAAoB,sBAAsBtD,EAAQC,CAAS,CACnE,EAGA,MAAM,2BACJ4J,EACAD,EACA3J,EACAoH,EACe,CAEf,OAAO,MAAM/D,EAAoB,2BAA2B,OAAQrD,EAAWoH,CAAa,CAC9F,EAGA,MAAM,uBACJrH,EACAC,EACAsJ,EACe,CACf,OAAO,MAAMD,EAAoB,2BAA2BtJ,EAAQC,EAAWsJ,CAAW,CAC5F,CACF"}