{"version":3,"file":"inventoryService.js","sources":["../../src/utils/dateUtils.ts","../../src/services/inventoryService.ts"],"sourcesContent":["import type { DateValue } from '@/types'\n\n/**\n * Safely converts various date representations to JavaScript Date objects\n */\nexport const toDate = (value: DateValue): Date | null => {\n  if (!value) return null\n\n  if (value instanceof Date) {\n    return value\n  }\n\n  // Handle various date formats including legacy timestamp objects\n  if (typeof value === 'object' && value) {\n    // Check if it's a legacy timestamp object with toDate method\n    if ('toDate' in value && typeof (value as any).toDate === 'function') {\n      try {\n        return (value as any).toDate()\n      } catch (error) {\n        console.warn('Failed to convert timestamp to Date:', error)\n        return null\n      }\n    }\n\n    // Check if it's a legacy timestamp object with seconds/nanoseconds\n    if ('seconds' in value && 'nanoseconds' in value) {\n      try {\n        return new Date((value as any).seconds * 1000 + (value as any).nanoseconds / 1000000)\n      } catch (error) {\n        console.warn('Failed to convert timestamp to Date:', error)\n        return null\n      }\n    }\n  }\n\n  // Handle string dates\n  if (typeof value === 'string') {\n    try {\n      // Check if it's a date-only string (YYYY-MM-DD format)\n      // This avoids timezone conversion issues by parsing as local time\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        // Parse as local date to avoid timezone conversion\n        const [year, month, day] = value.split('-').map(Number)\n        const date = new Date(year, month - 1, day) // month is 0-indexed\n        return isNaN(date.getTime()) ? null : date\n      }\n\n      // For other date formats, use the original parsing\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to parse date string:', value, error)\n      return null\n    }\n  }\n\n  // Handle number (milliseconds since epoch)\n  if (typeof value === 'number') {\n    try {\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to convert number to Date:', value, error)\n      return null\n    }\n  }\n\n  return null\n}\n\n/**\n * Safely formats a date value to a localized string\n */\nexport const formatDate = (\n  value: DateValue,\n  fallback: string = 'Unknown',\n  options?: Intl.DateTimeFormatOptions\n): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value with specific options\n */\nexport const formatDateTime = (value: DateValue, options?: Intl.DateTimeFormatOptions, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value as a time string\n */\nexport const formatTime = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  } catch (error) {\n    console.warn('Failed to format time:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Checks if a date value is valid\n */\nexport const isValidDate = (value: DateValue): boolean => {\n  return toDate(value) !== null\n}\n\n/**\n * Formats a currency amount with proper thousands separators and decimal places\n */\nexport const formatCurrency = (amount: string | number, fallback: string = '$0.00'): string => {\n  const num = typeof amount === 'string' ? parseFloat(amount) : amount\n\n  if (isNaN(num)) return fallback\n\n  return num.toLocaleString('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Formats a number with thousands separators (no currency symbol)\n */\nexport const formatNumber = (num: string | number, fallback: string = '0.00'): string => {\n  const value = typeof num === 'string' ? parseFloat(num) : num\n\n  if (isNaN(value)) return fallback\n\n  return value.toLocaleString('en-US', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Returns today's date as a date-only string in YYYY-MM-DD format (local time)\n */\nexport const getTodayDateString = (): string => {\n  const now = new Date()\n  const yyyy = now.getFullYear()\n  const mm = String(now.getMonth() + 1).padStart(2, '0')\n  const dd = String(now.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n/**\n * Converts an input date value to a date-only string (YYYY-MM-DD) if possible.\n * Returns an empty string when conversion fails or value is falsy.\n */\nexport const toDateOnlyString = (value: DateValue): string => {\n  if (!value) return ''\n  // Already a date-only string\n  if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n    return value\n  }\n  const d = toDate(value)\n  if (!d) return ''\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n","import { supabase, getCurrentUser } from './supabase'\nimport { convertTimestamps, ensureAuthenticatedForDatabase } from './databaseService'\nimport { toDateOnlyString } from '@/utils/dateUtils'\nimport { getTaxPresetById } from './taxPresetsService'\nimport { CLIENT_OWES_COMPANY, COMPANY_OWES_CLIENT } from '@/constants/company'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData } from '@/types'\n\n// Audit Logging Service for allocation/de-allocation events\nexport const auditService = {\n  // Log allocation/de-allocation events\n  async logAllocationEvent(\n    accountId: string,\n    eventType: 'allocation' | 'deallocation' | 'return',\n    itemId: string,\n    projectId: string | null,\n    transactionIdOrDetails: any,\n    detailsOrUndefined?: Record<string, any>\n  ): Promise<void> {\n    try {\n      // Handle different calling patterns\n      let transactionId: string | null | undefined = null\n      let details: Record<string, any> = {}\n\n      if (typeof transactionIdOrDetails === 'string') {\n        transactionId = transactionIdOrDetails\n        details = detailsOrUndefined || {}\n      } else {\n        transactionId = null\n        details = transactionIdOrDetails || {}\n      }\n\n      const { error } = await supabase\n        .from('audit_logs')\n        .insert({\n          account_id: accountId,\n          event_type: eventType,\n          item_id: itemId,\n          project_id: projectId,\n          transaction_id: transactionId,\n          details: details,\n          timestamp: new Date().toISOString(),\n          created_at: new Date().toISOString()\n        })\n\n      if (error) {\n        console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      } else {\n        console.log(`üìã Audit logged: ${eventType} for item ${itemId}`)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  },\n\n  // Log transaction state changes\n  async logTransactionStateChange(\n    accountId: string,\n    transactionId: string,\n    changeType: 'created' | 'updated' | 'deleted',\n    oldState?: any,\n    newState?: any\n  ): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('transaction_audit_logs')\n        .insert({\n          account_id: accountId,\n          transaction_id: transactionId,\n          change_type: changeType,\n          old_state: oldState || null,\n          new_state: newState || null,\n          timestamp: new Date().toISOString(),\n          created_at: new Date().toISOString()\n        })\n\n      if (error) {\n        console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      } else {\n        console.log(`üìã Transaction audit logged: ${changeType} for ${transactionId}`)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  }\n}\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current account\n  async getProjects(accountId: string): Promise<Project[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .select('*')\n      .eq('account_id', accountId)\n      .order('updated_at', { ascending: false })\n\n    if (error) throw error\n\n    return (data || []).map(project => {\n      const converted = convertTimestamps(project)\n      return {\n        id: converted.id,\n        accountId: converted.account_id,\n        name: converted.name,\n        description: converted.description || '',\n        clientName: converted.client_name || '',\n        budget: converted.budget ? parseFloat(converted.budget) : undefined,\n        designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n        budgetCategories: converted.budget_categories || undefined,\n        createdAt: converted.created_at,\n        updatedAt: converted.updated_at,\n        createdBy: converted.created_by,\n        settings: converted.settings || undefined,\n        metadata: converted.metadata || undefined,\n        itemCount: converted.item_count || 0,\n        transactionCount: converted.transaction_count || 0,\n        totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(accountId: string, projectId: string): Promise<Project | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .select('*')\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      description: converted.description || '',\n      clientName: converted.client_name || '',\n      budget: converted.budget ? parseFloat(converted.budget) : undefined,\n      designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n      budgetCategories: converted.budget_categories || undefined,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at,\n      createdBy: converted.created_by,\n      settings: converted.settings || undefined,\n      metadata: converted.metadata || undefined,\n      itemCount: converted.item_count || 0,\n      transactionCount: converted.transaction_count || 0,\n      totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n    } as Project\n  },\n\n  // Create new project\n  async createProject(accountId: string, projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .insert({\n        account_id: accountId,\n        name: projectData.name,\n        description: projectData.description || null,\n        client_name: projectData.clientName || null,\n        budget: projectData.budget || null,\n        design_fee: projectData.designFee || null,\n        budget_categories: projectData.budgetCategories || {},\n        settings: projectData.settings || {},\n        metadata: projectData.metadata || {},\n        created_by: projectData.createdBy,\n        item_count: 0,\n        transaction_count: 0,\n        total_value: 0,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      })\n      .select('id')\n      .single()\n\n    if (error) throw error\n    return data.id\n  },\n\n  // Update project\n  async updateProject(accountId: string, projectId: string, updates: Partial<Project>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const updateData: any = {\n      updated_at: new Date().toISOString()\n    }\n\n    if (updates.name !== undefined) updateData.name = updates.name\n    if (updates.description !== undefined) updateData.description = updates.description\n    if (updates.clientName !== undefined) updateData.client_name = updates.clientName\n    if (updates.budget !== undefined) updateData.budget = updates.budget\n    if (updates.designFee !== undefined) updateData.design_fee = updates.designFee\n    if (updates.budgetCategories !== undefined) updateData.budget_categories = updates.budgetCategories\n    if (updates.settings !== undefined) updateData.settings = updates.settings\n    if (updates.metadata !== undefined) updateData.metadata = updates.metadata\n\n    const { error } = await supabase\n      .from('projects')\n      .update(updateData)\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n\n    if (error) throw error\n  },\n\n  // Delete project\n  async deleteProject(accountId: string, projectId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const { error } = await supabase\n      .from('projects')\n      .delete()\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n\n    if (error) throw error\n  },\n\n  // Subscribe to projects with real-time updates\n  subscribeToProjects(\n    accountId: string,\n    callback: (projects: Project[]) => void,\n    initialProjects?: Project[]\n  ) {\n    let projects = [...(initialProjects || [])]\n\n    const channel = supabase\n      .channel(`projects:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'projects',\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Projects change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            const newProject = projectService._convertProjectFromDb(newRecord)\n            projects = [newProject, ...projects]\n          } else if (eventType === 'UPDATE') {\n            const updatedProject = projectService._convertProjectFromDb(newRecord)\n            projects = projects.map(p => p.id === updatedProject.id ? updatedProject : p)\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.id\n            projects = projects.filter(p => p.id !== oldId)\n          }\n          \n          callback([...projects])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to projects channel')\n        }\n        if (err) {\n          console.error('Error subscribing to projects channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Helper function to convert database project to Project type\n  _convertProjectFromDb(dbProject: any): Project {\n    const converted = convertTimestamps(dbProject)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      description: converted.description || '',\n      clientName: converted.client_name || '',\n      budget: converted.budget ? parseFloat(converted.budget) : undefined,\n      designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n      budgetCategories: converted.budget_categories || undefined,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at,\n      createdBy: converted.created_by,\n      settings: converted.settings || undefined,\n      metadata: converted.metadata || undefined,\n      itemCount: converted.item_count || 0,\n      transactionCount: converted.transaction_count || 0,\n      totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n    } as Project\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction conversion functions\nfunction _convertTransactionFromDb(dbTransaction: any): Transaction {\n  const converted = convertTimestamps(dbTransaction)\n  return {\n    transactionId: converted.transaction_id,\n    projectId: converted.project_id || undefined,\n    projectName: converted.project_name || undefined, // May be populated by enrichment function\n    transactionDate: converted.transaction_date,\n    source: converted.source || '',\n    transactionType: converted.transaction_type || '',\n    paymentMethod: converted.payment_method || '',\n    amount: converted.amount || '0.00',\n    budgetCategory: converted.budget_category || undefined,\n    notes: converted.notes || undefined,\n    transactionImages: Array.isArray(converted.transaction_images) ? converted.transaction_images : [],\n    receiptImages: Array.isArray(converted.receipt_images) ? converted.receipt_images : [],\n    otherImages: Array.isArray(converted.other_images) ? converted.other_images : [],\n    receiptEmailed: converted.receipt_emailed || false,\n    createdAt: converted.created_at,\n    createdBy: converted.created_by || '',\n    status: converted.status || 'completed',\n    reimbursementType: converted.reimbursement_type || undefined,\n    triggerEvent: converted.trigger_event || undefined,\n    itemIds: Array.isArray(converted.item_ids) ? converted.item_ids : [],\n    taxRatePreset: converted.tax_rate_preset || undefined,\n    taxRatePct: converted.tax_rate_pct ? parseFloat(converted.tax_rate_pct) : undefined,\n    subtotal: converted.subtotal || undefined\n  } as Transaction\n}\n\n/**\n * Enriches transactions with project names by looking them up from project_id\n * This ensures projectName is always available for display without storing it in the database\n */\nasync function _enrichTransactionsWithProjectNames(\n  accountId: string,\n  transactions: Transaction[],\n  projects?: Project[]\n): Promise<Transaction[]> {\n  // Extract unique project IDs (excluding null/undefined)\n  const projectIds = [...new Set(transactions\n    .map(tx => tx.projectId)\n    .filter((id): id is string => !!id)\n  )]\n\n  if (projectIds.length === 0) {\n    // No projects to look up, return as-is\n    return transactions\n  }\n\n  // Batch fetch all projects\n  const projectMap = new Map<string, string>()\n  try {\n    const projects = await projectService.getProjects(accountId)\n    projects.forEach(project => {\n      projectMap.set(project.id, project.name)\n    })\n  } catch (error) {\n    console.warn('Failed to fetch projects for transaction enrichment:', error)\n    // Continue without enrichment rather than failing\n  }\n\n  // Enrich transactions with project names\n  return transactions.map(tx => {\n    if (tx.projectId && !tx.projectName) {\n      const projectName = projectMap.get(tx.projectId)\n      if (projectName) {\n        return { ...tx, projectName }\n      }\n    }\n    return tx\n  })\n}\n\nfunction _convertTransactionToDb(transaction: Partial<Transaction>): any {\n  const dbTransaction: any = {}\n  \n  if (transaction.transactionId !== undefined) dbTransaction.transaction_id = transaction.transactionId\n  if (transaction.projectId !== undefined) dbTransaction.project_id = transaction.projectId ?? null\n  if (transaction.transactionDate !== undefined) dbTransaction.transaction_date = transaction.transactionDate\n  if (transaction.source !== undefined) dbTransaction.source = transaction.source\n  if (transaction.transactionType !== undefined) dbTransaction.transaction_type = transaction.transactionType\n  if (transaction.paymentMethod !== undefined) dbTransaction.payment_method = transaction.paymentMethod\n  if (transaction.amount !== undefined) dbTransaction.amount = transaction.amount\n  if (transaction.budgetCategory !== undefined) dbTransaction.budget_category = transaction.budgetCategory\n  if (transaction.notes !== undefined) dbTransaction.notes = transaction.notes\n  if (transaction.transactionImages !== undefined) dbTransaction.transaction_images = transaction.transactionImages\n  if (transaction.receiptImages !== undefined) dbTransaction.receipt_images = transaction.receiptImages\n  if (transaction.otherImages !== undefined) dbTransaction.other_images = transaction.otherImages\n  if (transaction.receiptEmailed !== undefined) dbTransaction.receipt_emailed = transaction.receiptEmailed\n  if (transaction.createdAt !== undefined) dbTransaction.created_at = transaction.createdAt\n  if (transaction.createdBy !== undefined) dbTransaction.created_by = transaction.createdBy\n  if (transaction.status !== undefined) dbTransaction.status = transaction.status\n  if (transaction.reimbursementType !== undefined) dbTransaction.reimbursement_type = transaction.reimbursementType\n  if (transaction.triggerEvent !== undefined) dbTransaction.trigger_event = transaction.triggerEvent\n  if (transaction.itemIds !== undefined) dbTransaction.item_ids = transaction.itemIds\n  if (transaction.taxRatePreset !== undefined) dbTransaction.tax_rate_preset = transaction.taxRatePreset\n  if (transaction.taxRatePct !== undefined) dbTransaction.tax_rate_pct = transaction.taxRatePct\n  if (transaction.subtotal !== undefined) dbTransaction.subtotal = transaction.subtotal\n  \n  return dbTransaction\n}\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project (account-scoped)\n  async getTransactions(accountId: string, projectId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Get transactions for multiple projects (account-scoped)\n  async getTransactionsForProjects(accountId: string, projectIds: string[], projects?: Project[]): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    if (projectIds.length === 0) {\n      return []\n    }\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('project_id', projectIds)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions, projects)\n  },\n\n  // Get single transaction (account-scoped)\n  async getTransaction(accountId: string, _projectId: string, transactionId: string): Promise<Transaction | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    const transaction = _convertTransactionFromDb(data)\n    const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n    return enriched[0] || null\n  },\n\n  // Get transaction by ID across all projects (for business inventory) - account-scoped\n  async getTransactionById(accountId: string, transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (error || !data) {\n      return { transaction: null, projectId: null }\n    }\n\n    const converted = convertTimestamps(data)\n    const transaction = _convertTransactionFromDb(data)\n    const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n\n    return {\n      transaction: enriched[0] || transaction,\n      projectId: converted.project_id || null\n    }\n  },\n\n  // Create new transaction (account-scoped)\n  async createTransaction(\n    accountId: string,\n    projectId: string | null | undefined,\n    transactionData: Omit<Transaction, 'transactionId' | 'createdAt'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      await ensureAuthenticatedForDatabase()\n\n      // Get current user ID for created_by field\n      const currentUser = await getCurrentUser()\n      const userId = transactionData.createdBy || currentUser?.id || null\n      \n      if (!userId) {\n        throw new Error('User must be authenticated to create transactions')\n      }\n\n      const now = new Date()\n      // Generate a unique transaction_id (UUID format)\n      const transactionId = crypto.randomUUID()\n\n      // Convert camelCase transactionData to database format\n      const dbTransaction = _convertTransactionToDb({\n        ...transactionData,\n        transactionId,\n        createdAt: now.toISOString()\n      })\n\n      // Set account_id and timestamps\n      dbTransaction.account_id = accountId\n      dbTransaction.created_at = now.toISOString()\n      dbTransaction.updated_at = now.toISOString()\n      if (!dbTransaction.status) dbTransaction.status = 'completed'\n\n      console.log('Creating transaction:', dbTransaction)\n      console.log('Transaction items:', items)\n\n      // Apply tax calculation from presets or compute from subtotal when Other\n      if (dbTransaction.tax_rate_preset) {\n        if (dbTransaction.tax_rate_preset === 'Other') {\n          // Validate subtotal presence and calculate rate\n          const amountNum = parseFloat(dbTransaction.amount || '0')\n          const subtotalNum = parseFloat(dbTransaction.subtotal || '0')\n          if (isNaN(subtotalNum) || subtotalNum <= 0) {\n            throw new Error('Subtotal must be greater than 0 when Tax Rate Preset is Other.')\n          }\n          if (isNaN(amountNum) || amountNum < subtotalNum) {\n            throw new Error('Subtotal cannot exceed the total amount.')\n          }\n          const rate = ((amountNum - subtotalNum) / subtotalNum) * 100\n          dbTransaction.tax_rate_pct = Math.round(rate * 10000) / 10000 // 4 decimal places\n        } else {\n          // Look up preset by ID\n          const preset = await getTaxPresetById(accountId, dbTransaction.tax_rate_preset)\n          if (!preset) {\n            throw new Error(`Tax preset with ID '${dbTransaction.tax_rate_preset}' not found.`)\n          }\n          dbTransaction.tax_rate_pct = preset.rate\n          // Remove subtotal for preset selections\n          dbTransaction.subtotal = null\n        }\n      }\n\n      const { error } = await supabase\n        .from('transactions')\n        .insert(dbTransaction)\n\n      if (error) throw error\n\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        // Propagate tax_rate_pct to created items if present on transaction\n        const itemsToCreate = items.map(i => ({ ...i }))\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          accountId,\n          projectId || '',\n          transactionId,\n          transactionData.transactionDate,\n          transactionData.source, // Pass transaction source to items\n          itemsToCreate,\n          dbTransaction.tax_rate_pct\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction (account-scoped)\n  async updateTransaction(accountId: string, _projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Apply business rules for reimbursement type and status (using camelCase)\n    const finalUpdates: Partial<Transaction> = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursementType\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursementType !== undefined) {\n      finalUpdates.reimbursementType = null\n    }\n\n    // If reimbursementType is being set to empty string, also clear it\n    if (finalUpdates.reimbursementType === '') {\n      finalUpdates.reimbursementType = null\n    }\n\n    // If reimbursementType is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursementType && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursementType is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    // Apply tax mapping / computation before save (using camelCase)\n    if (finalUpdates.taxRatePreset !== undefined) {\n      if (finalUpdates.taxRatePreset === 'Other') {\n        // Compute from provided subtotal and amount if present in updates or existing doc\n        const { data: existing } = await supabase\n          .from('transactions')\n          .select('amount, subtotal')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n\n        const existingData = existing as { amount?: string; subtotal?: string } | null\n        const amountVal = finalUpdates.amount !== undefined ? parseFloat(finalUpdates.amount) : parseFloat(existingData?.amount || '0')\n        const subtotalVal = finalUpdates.subtotal !== undefined ? parseFloat(finalUpdates.subtotal) : parseFloat(existingData?.subtotal || '0')\n        if (!isNaN(amountVal) && !isNaN(subtotalVal) && subtotalVal > 0 && amountVal >= subtotalVal) {\n          const rate = ((amountVal - subtotalVal) / subtotalVal) * 100\n          finalUpdates.taxRatePct = Math.round(rate * 10000) / 10000\n        }\n      } else {\n        // Look up preset by ID\n        try {\n          const preset = await getTaxPresetById(accountId, finalUpdates.taxRatePreset)\n          if (preset) {\n            finalUpdates.taxRatePct = preset.rate\n            // Remove subtotal when using presets\n            finalUpdates.subtotal = undefined\n          } else {\n            console.warn(`Tax preset with ID '${finalUpdates.taxRatePreset}' not found during update`)\n          }\n        } catch (e) {\n          console.warn('Tax preset lookup failed during update:', e)\n        }\n      }\n    }\n\n    // Convert camelCase updates to database format\n    const dbUpdates = _convertTransactionToDb(finalUpdates)\n    // Add updated_at timestamp for database\n    dbUpdates.updated_at = new Date().toISOString()\n\n    const { error } = await supabase\n      .from('transactions')\n      .update(dbUpdates)\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n\n    // If taxRatePct is set in updates, propagate to items\n    if (finalUpdates.taxRatePct !== undefined) {\n      try {\n        const items = await unifiedItemsService.getItemsForTransaction(accountId, _projectId, transactionId)\n        if (items && items.length > 0) {\n          // Update each item individually (Supabase batch operations)\n          for (const item of items) {\n            await unifiedItemsService.updateItem(accountId, item.itemId, {\n              taxRatePct: finalUpdates.taxRatePct\n            })\n          }\n        }\n      } catch (e) {\n        console.warn('Failed to propagate tax_rate_pct to items:', e)\n      }\n    }\n  },\n\n  // Delete transaction (account-scoped)\n  async deleteTransaction(accountId: string, _projectId: string, transactionId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const { error } = await supabase\n      .from('transactions')\n      .delete()\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n  },\n\n  // Subscribe to transactions with real-time updates\n  subscribeToTransactions(\n    accountId: string,\n    projectId: string,\n    callback: (transactions: Transaction[]) => void,\n    initialTransactions?: Transaction[]\n  ) {\n    let transactions = [...(initialTransactions || [])]\n\n    const channel = supabase\n      .channel(`transactions:${accountId}:${projectId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          // Listen at account scope so we receive updates when project_id changes\n          filter: `account_id=eq.${accountId}`\n        },\n        async (payload) => {\n          console.log('Transactions change received (account scope)!', payload)\n\n          const { eventType, new: newRecord, old: oldRecord } = payload\n          const newProjectId = newRecord?.project_id ?? null\n          const oldProjectId = oldRecord?.project_id ?? null\n\n          const matchesProject = (candidate: string | null | undefined) => candidate === projectId\n\n          if (eventType === 'INSERT') {\n            if (matchesProject(newProjectId)) {\n              const newTransaction = _convertTransactionFromDb(newRecord)\n              const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [newTransaction])\n              // Ensure no duplicates before adding\n              transactions = [enrichedTransaction, ...transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [updatedTransaction])\n\n            const wasInProject = transactions.some(t => t.transactionId === enrichedTransaction.transactionId)\n            const isInProject = matchesProject(newProjectId)\n\n            if (isInProject && !wasInProject) {\n              // Transaction moved into this project\n              transactions = [enrichedTransaction, ...transactions]\n            } else if (!isInProject && wasInProject) {\n              // Transaction moved out of this project (or deleted project_id)\n              transactions = transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)\n            } else if (isInProject && wasInProject) {\n              // Transaction updated within this project\n              transactions = transactions.map(t => t.transactionId === enrichedTransaction.transactionId ? enrichedTransaction : t)\n            }\n            // If !isInProject && !wasInProject ‚Üí change unrelated to this project, ignore\n          } else if (eventType === 'DELETE') {\n            if (matchesProject(oldProjectId)) {\n              const oldId = oldRecord.transaction_id\n              transactions = transactions.filter(t => t.transactionId !== oldId)\n            }\n          }\n\n          const sortedTransactions = [...transactions].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n          callback(sortedTransactions)\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to transactions channel')\n        }\n        if (err) {\n          console.error('Error subscribing to transactions channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  subscribeToAllTransactions(\n    accountId: string,\n    callback: (transactions: Transaction[]) => void,\n    initialTransactions?: Transaction[]\n  ) {\n    let transactions = [...(initialTransactions || [])]\n\n    const channel = supabase\n      .channel(`transactions:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          filter: `account_id=eq.${accountId}`\n        },\n        async (payload) => {\n          console.log('All transactions change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            const newTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [newTransaction])\n            transactions = [enrichedTransaction, ...transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)]\n          } else if (eventType === 'UPDATE') {\n            const updatedTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [updatedTransaction])\n            transactions = transactions.map(t => t.transactionId === enrichedTransaction.transactionId ? enrichedTransaction : t)\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.transaction_id\n            transactions = transactions.filter(t => t.transactionId !== oldId)\n          }\n          \n          const sortedTransactions = [...transactions].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n          callback(sortedTransactions)\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to all transactions channel')\n        }\n        if (err) {\n          console.error('Error subscribing to all transactions channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Subscribe to single transaction for real-time updates\n  subscribeToTransaction(\n    accountId: string,\n    _projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const channel = supabase\n      .channel(`transaction:${accountId}:${transactionId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          filter: `account_id=eq.${accountId} AND transaction_id=eq.${transactionId}`\n        },\n        async () => {\n          // Refetch transaction on any change\n          try {\n            const { data, error } = await supabase\n              .from('transactions')\n              .select('*')\n              .eq('account_id', accountId)\n              .eq('transaction_id', transactionId)\n              .single()\n            \n            if (error) {\n              if (error.code === 'PGRST116') {\n                // Not found - transaction was deleted\n                callback(null)\n                return\n              }\n              console.error('Error fetching transaction in subscription:', error)\n              return\n            }\n            \n            if (data) {\n              const transaction = _convertTransactionFromDb(data)\n              const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n              callback(enriched[0] || null)\n            } else {\n              callback(null)\n            }\n          } catch (error) {\n            console.error('Error in transaction subscription callback:', error)\n          }\n        }\n      )\n      .subscribe()\n\n    // Initial fetch\n    const fetchTransaction = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('transactions')\n          .select('*')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n        \n        if (error) {\n          if (error.code === 'PGRST116') {\n            callback(null)\n            return\n          }\n          console.error('Error fetching initial transaction:', error)\n          return\n        }\n        \n        if (data) {\n          const transaction = _convertTransactionFromDb(data)\n          const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n          callback(enriched[0] || null)\n        } else {\n          callback(null)\n        }\n      } catch (error) {\n        console.error('Error in initial transaction fetch:', error)\n      }\n    }\n    \n    fetchTransaction()\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Get pending transactions for a project (account-scoped)\n  async getPendingTransactions(accountId: string, projectId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions) (account-scoped)\n  async updateTransactionStatus(\n    accountId: string,\n    _projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'canceled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const updateData: any = {\n      status: status,\n      updated_at: new Date().toISOString()\n    }\n\n    if (updates) {\n      if (updates.transactionDate !== undefined) updateData.transaction_date = updates.transactionDate\n      if (updates.paymentMethod !== undefined) updateData.payment_method = updates.paymentMethod\n      if (updates.amount !== undefined) updateData.amount = updates.amount\n      if (updates.notes !== undefined) updateData.notes = updates.notes\n      // Add other fields as needed\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transactionDate) {\n      updateData.transaction_date = toDateOnlyString(new Date())\n    }\n\n    const { error } = await supabase\n      .from('transactions')\n      .update(updateData)\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n  },\n\n  // Utility queries for Business Inventory and reporting (account-scoped)\n  async getInventoryRelatedTransactions(accountId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('reimbursement_type', [CLIENT_OWES_COMPANY, COMPANY_OWES_CLIENT])\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Get business inventory transactions (project_id == null) (account-scoped)\n  async getBusinessInventoryTransactions(accountId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .is('project_id', null)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Helper function to convert database item (snake_case) to app format (camelCase)\n  _convertItemFromDb(dbItem: any): Item {\n    const converted = convertTimestamps(dbItem)\n    return {\n      itemId: converted.item_id,\n      accountId: converted.account_id,\n      projectId: converted.project_id || undefined,\n      transactionId: converted.transaction_id || undefined,\n      name: converted.name || undefined,\n      description: converted.description || '',\n      sku: converted.sku || '',\n      source: converted.source || '',\n      purchasePrice: converted.purchase_price || undefined,\n      projectPrice: converted.project_price || undefined,\n      marketValue: converted.market_value || undefined,\n      paymentMethod: converted.payment_method || '',\n      disposition: converted.disposition || undefined,\n      notes: converted.notes || undefined,\n      space: converted.space || undefined,\n      qrKey: converted.qr_key || '',\n      bookmark: converted.bookmark || false,\n      dateCreated: converted.date_created || '',\n      lastUpdated: converted.last_updated ? (typeof converted.last_updated === 'string' ? converted.last_updated : converted.last_updated.toISOString()) : '',\n      images: Array.isArray(converted.images) ? converted.images : [],\n      inventoryStatus: converted.inventory_status || undefined,\n      businessInventoryLocation: converted.business_inventory_location || undefined,\n      taxRatePct: converted.tax_rate_pct ? parseFloat(converted.tax_rate_pct) : undefined,\n      taxAmount: converted.tax_amount || undefined,\n      createdBy: converted.created_by || undefined,\n      createdAt: converted.created_at\n    } as Item\n  },\n\n  // Helper function to convert app format (camelCase) to database format (snake_case)\n  _convertItemToDb(item: Partial<Item>): any {\n    const dbItem: any = {}\n    \n    if (item.itemId !== undefined) dbItem.item_id = item.itemId\n    if (item.accountId !== undefined) dbItem.account_id = item.accountId\n    if (item.projectId !== undefined) dbItem.project_id = item.projectId ?? null\n    if (item.transactionId !== undefined) dbItem.transaction_id = item.transactionId ?? null\n    if (item.name !== undefined) dbItem.name = item.name\n    if (item.description !== undefined) dbItem.description = item.description\n    if (item.sku !== undefined) dbItem.sku = item.sku\n    if (item.source !== undefined) dbItem.source = item.source\n    if (item.purchasePrice !== undefined) dbItem.purchase_price = item.purchasePrice\n    if (item.projectPrice !== undefined) dbItem.project_price = item.projectPrice\n    if (item.marketValue !== undefined) dbItem.market_value = item.marketValue\n    if (item.paymentMethod !== undefined) dbItem.payment_method = item.paymentMethod\n    if (item.disposition !== undefined) dbItem.disposition = item.disposition\n    if (item.notes !== undefined) dbItem.notes = item.notes\n    if (item.space !== undefined) dbItem.space = item.space\n    if (item.qrKey !== undefined) dbItem.qr_key = item.qrKey\n    if (item.bookmark !== undefined) dbItem.bookmark = item.bookmark\n    if (item.dateCreated !== undefined) dbItem.date_created = item.dateCreated\n    if (item.lastUpdated !== undefined) dbItem.last_updated = item.lastUpdated\n    if (item.images !== undefined) dbItem.images = item.images\n    if (item.inventoryStatus !== undefined) dbItem.inventory_status = item.inventoryStatus\n    if (item.businessInventoryLocation !== undefined) dbItem.business_inventory_location = item.businessInventoryLocation\n    if (item.taxRatePct !== undefined) dbItem.tax_rate_pct = item.taxRatePct\n    if (item.taxAmount !== undefined) dbItem.tax_amount = item.taxAmount\n    if (item.createdBy !== undefined) dbItem.created_by = item.createdBy\n    if (item.createdAt !== undefined) dbItem.created_at = item.createdAt\n    \n    return dbItem\n  },\n\n  // Get items for a project (project_id == projectId) (account-scoped)\n  async getItemsByProject(\n    accountId: string,\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    let query = supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n\n    // Apply filters\n    if (filters?.status) {\n      query = query.eq('disposition', filters.status)\n    }\n\n    if (filters?.category) {\n      query = query.eq('source', filters.category)\n    }\n\n    if (filters?.priceRange) {\n      query = query.gte('project_price', filters.priceRange.min.toString())\n      query = query.lte('project_price', filters.priceRange.max.toString())\n    }\n\n    // Apply search (using ilike for case-insensitive search)\n    if (filters?.searchQuery) {\n      query = query.or(`description.ilike.%${filters.searchQuery}%,source.ilike.%${filters.searchQuery}%,sku.ilike.%${filters.searchQuery}%,payment_method.ilike.%${filters.searchQuery}%`)\n    }\n\n    // Apply sorting\n    query = query.order('last_updated', { ascending: false })\n\n    // Apply pagination\n    if (pagination) {\n      const offset = pagination.page > 0 ? (pagination.page - 1) * pagination.limit : 0\n      query = query.range(offset, offset + pagination.limit - 1)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  // Subscribe to items for a project with real-time updates\n  subscribeToProjectItems(\n    accountId: string,\n    projectId: string,\n    callback: (items: Item[]) => void,\n    initialItems?: Item[]\n  ) {\n    let items = [...(initialItems || [])]\n\n    const channel = supabase\n      .channel(`project-items:${accountId}:${projectId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'items',\n          // Broaden filter to account-level to catch updates where project_id changes\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Project items change received (broad filter)!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            // Add item only if it belongs to the current project\n            if (newRecord.project_id === projectId) {\n              const newItem = this._convertItemFromDb(newRecord)\n              items = [newItem, ...items]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedItem = this._convertItemFromDb(newRecord)\n            const wasInProject = items.some(i => i.itemId === updatedItem.itemId)\n            const isInProject = updatedItem.projectId === projectId\n\n            if (isInProject && !wasInProject) {\n              // Item moved INTO this project\n              items = [updatedItem, ...items]\n            } else if (!isInProject && wasInProject) {\n              // Item moved OUT of this project\n              items = items.filter(i => i.itemId !== updatedItem.itemId)\n            } else if (isInProject && wasInProject) {\n              // Item updated WITHIN this project\n              items = items.map(i => i.itemId === updatedItem.itemId ? updatedItem : i)\n            }\n            // If !isInProject and !wasInProject, do nothing (change between other projects)\n            \n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.item_id\n            items = items.filter(i => i.itemId !== oldId)\n          }\n          \n          callback([...items])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to project items channel')\n        }\n        if (err) {\n          console.error('Error subscribing to project items channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n\n  // Get business inventory items (project_id == null) (account-scoped)\n  async getBusinessInventoryItems(\n    accountId: string,\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    let query = supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .is('project_id', null)\n\n    // Apply filters\n    if (filters?.status) {\n      query = query.eq('inventory_status', filters.status)\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      query = query.or(`description.ilike.%${filters.searchQuery}%,source.ilike.%${filters.searchQuery}%,sku.ilike.%${filters.searchQuery}%,business_inventory_location.ilike.%${filters.searchQuery}%`)\n    }\n\n    // Apply sorting\n    query = query.order('last_updated', { ascending: false })\n\n    // Apply pagination\n    if (pagination) {\n      const offset = pagination.page > 0 ? (pagination.page - 1) * pagination.limit : 0\n      query = query.range(offset, offset + pagination.limit - 1)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  subscribeToBusinessInventory(\n    accountId: string,\n    callback: (items: Item[]) => void,\n    _filters: any,\n    initialItems?: Item[]\n  ) {\n    let items = [...(initialItems || [])]\n\n    const channel = supabase\n      .channel(`business-inventory:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'items',\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Business inventory change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            // Check raw DB record (snake_case)\n            if (!newRecord.project_id) {\n              const newItem = this._convertItemFromDb(newRecord)\n              items = [newItem, ...items]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedItem = this._convertItemFromDb(newRecord)\n            // Check converted item (camelCase) - if projectId is null/undefined, it's business inventory\n            if (!updatedItem.projectId) {\n              // It's a business inventory item, update it\n              items = items.map(i => i.itemId === updatedItem.itemId ? updatedItem : i)\n            } else {\n              // It's no longer a business inventory item (moved to a project), remove it\n              items = items.filter(i => i.itemId !== updatedItem.itemId)\n            }\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.item_id\n            items = items.filter(i => i.itemId !== oldId)\n          }\n          \n          callback([...items])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to business inventory channel')\n        }\n        if (err) {\n          console.error('Error subscribing to business inventory channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Create new item (account-scoped)\n  async createItem(accountId: string, itemData: Omit<Item, 'itemId' | 'dateCreated' | 'lastUpdated'>): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    const now = new Date()\n    // Generate a unique item_id (using timestamp + random string format like the original)\n    const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Convert camelCase itemData to database format\n    const dbItem = this._convertItemToDb({\n      ...itemData,\n      itemId,\n      qrKey: itemData.qrKey || qrKey\n    } as Item)\n    \n    // Set dateCreated and lastUpdated separately since they're omitted from the type\n    dbItem.date_created = toDateOnlyString(now)\n    dbItem.last_updated = now.toISOString()\n\n    // Set account_id and timestamps\n    dbItem.account_id = accountId\n    dbItem.created_at = now.toISOString()\n    if (!dbItem.date_created) dbItem.date_created = toDateOnlyString(now)\n    if (!dbItem.last_updated) dbItem.last_updated = now.toISOString()\n    if (!dbItem.inventory_status) dbItem.inventory_status = 'available'\n\n    // If item is being created with a transaction_id but missing tax_rate_pct,\n    // attempt to read the transaction and inherit its tax_rate_pct.\n    try {\n      if (dbItem.transaction_id && dbItem.tax_rate_pct === null) {\n        const { data: txData } = await supabase\n          .from('transactions')\n          .select('tax_rate_pct')\n          .eq('account_id', accountId)\n          .eq('transaction_id', dbItem.transaction_id)\n          .single()\n\n        if (txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n          dbItem.tax_rate_pct = txData.tax_rate_pct\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when creating item:', e)\n    }\n\n    const { error } = await supabase\n      .from('items')\n      .insert(dbItem)\n\n    if (error) throw error\n\n    return itemId\n  },\n\n  // Update item (account-scoped)\n  async updateItem(accountId: string, itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Convert camelCase updates to database format\n    const dbUpdates = this._convertItemToDb({\n      ...updates,\n      lastUpdated: new Date().toISOString()\n    })\n\n    // If transaction_id is being set/changed and caller did not provide tax_rate_pct,\n    // attempt to inherit the transaction's tax_rate_pct and include it in the update.\n    try {\n      const willSetTransaction = updates.transactionId !== undefined && updates.transactionId !== null\n      const missingTax = updates.taxRatePct === undefined || updates.taxRatePct === null\n      if (willSetTransaction && missingTax) {\n        const txId = updates.transactionId as string\n        if (txId) {\n          const { data: txData } = await supabase\n            .from('transactions')\n            .select('tax_rate_pct')\n            .eq('account_id', accountId)\n            .eq('transaction_id', txId)\n            .single()\n\n          if (txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n            dbUpdates.tax_rate_pct = txData.tax_rate_pct\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when updating item:', e)\n    }\n\n    const { error } = await supabase\n      .from('items')\n      .update(dbUpdates)\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n\n    if (error) throw error\n  },\n\n  // Delete item (account-scoped)\n  async deleteItem(accountId: string, itemId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const { error } = await supabase\n      .from('items')\n      .delete()\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n\n    if (error) throw error\n  },\n\n  // Get items for a transaction (by transaction_id) (account-scoped)\n  async getItemsForTransaction(accountId: string, _projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .order('date_created', { ascending: true })\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  // Allocate single item to project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows) (account-scoped)\n  async allocateItemToProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the item to determine current state and calculate amount\n    const item = await this.getItemById(accountId, itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.projectPrice || item.marketValue || '0.00'\n    const currentTransactionId: string | null = item.transactionId || null\n\n    console.log('üîÑ Starting allocation process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.projectId,\n      finalAmount\n    })\n\n    // Log allocation start (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, item.projectId ?? null, currentTransactionId ?? null, {\n        action: 'allocation_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC from ALLOCATION_TRANSACTION_LOGIC.md\n\n    // Scenario A: Item currently in a Sale (Project X)\n    if (currentTransactionId?.startsWith('INV_SALE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n      if (currentProjectId === projectId) {\n        // A.1: Remove item from Sale and move to Inventory (delete Sale if empty)\n        console.log('üìã Scenario A.1: Item in Sale, allocating to same project ‚Üí move to inventory')\n        return await this.handleSaleToInventoryMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // A.2: Allocate to different project - remove from Sale, add to Purchase (Project Y)\n        console.log('üìã Scenario A.2: Item in Sale, allocating to different project')\n        return await this.handleSaleToDifferentProjectMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario B: Item currently in a Purchase (Project X)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // B.1: Allocate to same project - remove from Purchase, update amount, delete if empty\n        console.log('üìã Scenario B.1: Item in Purchase, allocating to same project')\n        return await this.handlePurchaseToInventoryMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // B.2: Allocate to different project - remove from Purchase, add to Sale (Project Y)\n        console.log('üìã Scenario B.2: Item in Purchase, allocating to different project')\n        return await this.handlePurchaseToDifferentProjectMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario C: Item in Inventory (no transaction)\n    // Only treat as inventory when there is no transaction_id. Previously this\n    // branch also treated items with a null project_id as inventory which\n    // incorrectly bypassed removal from existing INV_SALE_/INV_PURCHASE_\n    // transactions. Require absence of currentTransactionId to follow the\n    // inventory -> purchase flow.\n    if (!currentTransactionId) {\n      console.log('üìã Scenario C: Item in inventory, allocating to project')\n      return await this.handleInventoryToPurchaseMove(accountId, itemId, projectId, finalAmount, notes, space)\n    }\n\n    // Fallback: Unknown scenario, treat as new allocation\n    console.log('üìã Fallback: Unknown scenario, treating as new allocation')\n    return await this.handleInventoryToPurchaseMove(accountId, itemId, projectId, finalAmount, notes, space)\n  },\n\n  // Helper: Handle A.1 - Remove item from Sale (same project)\n  async handleSaleToPurchaseMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: projectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Purchase (same project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle A.1 (authoritative) - Remove item from Sale and move to Inventory (same project)\n  async handleSaleToInventoryMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    // Per A.1: allocate back to the same project without creating an INV_PURCHASE\n    // i.e. set the item's project and mark as allocated, but do not attach a\n    // purchase transaction.\n    await this.updateItem(accountId, itemId, {\n      projectId: _projectId,\n      inventoryStatus: 'allocated',\n      transactionId: null,\n      disposition: 'keep',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Inventory (same project)')\n\n    // Log successful move (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, _projectId, null, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_status: 'allocated',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion (A.1):', auditError)\n    }\n\n    // Return original sale transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle A.2 - Remove item from Sale, add to Purchase (different project)\n  async handleSaleToDifferentProjectMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${newProjectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction for new project (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: newProjectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.2 completed: Sale ‚Üí Purchase (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, newProjectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.2',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle B.1 - Remove item from Purchase (same project)\n  async handlePurchaseToInventoryMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      disposition: 'inventory',\n      notes: _notes,\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.1 completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful deallocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, 'inventory', {\n        action: 'deallocation_completed',\n        scenario: 'B.1',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n    }\n\n    return currentTransactionId // Return the original transaction ID since item is now in inventory\n  },\n\n  // Helper: Handle B.2 - Remove item from Purchase, add to Sale (different project)\n  async handlePurchaseToDifferentProjectMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const saleTransactionId = `INV_SALE_${newProjectId}`\n\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Sale transaction for new project (create if none)\n    await this.addItemToTransaction(accountId, itemId, saleTransactionId, finalAmount, 'To Inventory', 'Inventory sale', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: saleTransactionId,\n      disposition: 'inventory',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.2 completed: Purchase ‚Üí Sale (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, null, saleTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'B.2',\n        from_transaction: currentTransactionId,\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Helper: Handle C - Add item to Purchase (new allocation)\n  async handleInventoryToPurchaseMove(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: projectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ C completed: Inventory ‚Üí Purchase (new allocation)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'C',\n        from_status: 'inventory',\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Remove item from transaction and update amounts\n  async removeItemFromTransaction(accountId: string, itemId: string, transactionId: string, _itemAmount: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the transaction\n    const { data: transactionData, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (fetchError || !transactionData) {\n      console.warn('‚ö†Ô∏è Transaction not found for removal:', transactionId)\n      return\n    }\n\n    const existingItemIds = transactionData.item_ids || []\n    const updatedItemIds = existingItemIds.filter((id: string) => id !== itemId)\n\n    if (updatedItemIds.length === 0) {\n      // No items left - delete transaction\n      try {\n        const { error: deleteError } = await supabase\n          .from('transactions')\n          .delete()\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (deleteError) throw deleteError\n\n        console.log('üóëÔ∏è Deleted empty transaction:', transactionId)\n\n        // Log transaction deletion (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'deleted', transactionData, null)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction deletion:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to delete empty transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue even if deletion fails\n      }\n    } else {\n      // Recalculate amount from remaining items\n      try {\n        // Get all items to recalculate amount\n        const { data: itemsData, error: itemsError } = await supabase\n          .from('items')\n          .select('project_price, market_value')\n          .eq('account_id', accountId)\n          .in('item_id', updatedItemIds)\n\n        if (itemsError) throw itemsError\n\n        const totalAmount = (itemsData || [])\n          .map(item => item.project_price || item.market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          updated_at: new Date().toISOString()\n        }\n\n        const { error: updateError } = await supabase\n          .from('transactions')\n          .update(updateData)\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (updateError) throw updateError\n\n        console.log('üîÑ Updated transaction after removal:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'updated', transactionData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update transaction after removal:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Helper: Add item to transaction (create if none exists)\n  async addItemToTransaction(\n    accountId: string,\n    itemId: string,\n    transactionId: string,\n    amount: string,\n    transactionType: 'Purchase' | 'Sale' | 'To Inventory',\n    triggerEvent: string,\n    notes?: string\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Check if transaction exists\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - add item and recalculate amount\n      try {\n        const existingItemIds = existingTransaction.item_ids || []\n        const updatedItemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n        // Get all items to recalculate amount\n        const { data: itemsData, error: itemsError } = await supabase\n          .from('items')\n          .select('project_price, market_value')\n          .eq('account_id', accountId)\n          .in('item_id', updatedItemIds)\n\n        if (itemsError) throw itemsError\n\n        const totalAmount = (itemsData || [])\n          .map(item => item.project_price || item.market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          updated_at: new Date().toISOString()\n        }\n\n        const { error: updateError } = await supabase\n          .from('transactions')\n          .update(updateData)\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (updateError) throw updateError\n\n        console.log('üîÑ Added item to existing transaction:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'updated', existingTransaction, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n\n        // If the transaction has a tax rate, propagate it to the added item\n        try {\n          const txTax = existingTransaction.tax_rate_pct\n          if (txTax !== undefined && txTax !== null) {\n            await this.updateItem(accountId, itemId, {\n              tax_rate_pct: txTax\n            })\n          }\n        } catch (e) {\n          console.warn('Failed to set tax_rate_pct on added item:', itemId, e)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update existing transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    } else {\n      // Create new transaction\n      try {\n        // Get current user ID for created_by field\n        const currentUser = await getCurrentUser()\n        if (!currentUser?.id) {\n          throw new Error('User must be authenticated to create transactions')\n        }\n\n        const projectId = transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', '')\n        const project = await projectService.getProject(accountId, projectId)\n        const projectName = project?.name || 'Other'\n\n        const now = new Date()\n        const transactionData = {\n          account_id: accountId,\n          transaction_id: transactionId,\n          project_id: projectId,\n          transaction_date: toDateOnlyString(now),\n          source: transactionType === 'Purchase' ? 'Inventory' : projectName,\n          transaction_type: transactionType,\n          payment_method: 'Pending',\n          amount: amount,\n          budget_category: 'Furnishings',\n          notes: notes || `Transaction for items ${transactionType === 'Purchase' ? 'purchased from' : 'sold to'} ${transactionType === 'Purchase' ? 'inventory' : 'project'}`,\n          status: 'pending' as const,\n          reimbursement_type: transactionType === 'Purchase' ? CLIENT_OWES_COMPANY : COMPANY_OWES_CLIENT,\n          trigger_event: triggerEvent,\n          item_ids: [itemId],\n          created_by: currentUser.id,\n          created_at: now.toISOString(),\n          updated_at: now.toISOString()\n        }\n\n        const { error: insertError } = await supabase\n          .from('transactions')\n          .insert(transactionData)\n\n        if (insertError) throw insertError\n\n        console.log('üÜï Created new transaction:', transactionId, 'amount:', amount)\n\n        // Log transaction creation (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'created', null, transactionData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction creation:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to create new transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Batch allocate multiple items to project (updates INV_PURCHASE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    accountId: string,\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Fetch the requested items by id (inspect transaction_id per-item to\n    // implement A.1 vs A.2 decisions). Do NOT rely solely on project_id.\n    const { data: itemsData, error: itemsError } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('item_id', itemIds)\n\n    if (itemsError || !itemsData || itemsData.length === 0) {\n      throw new Error('No items found for allocation')\n    }\n\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Process each item individually so we can apply A.1/A.2 rules per item.\n    for (const itemData of itemsData) {\n      const itemId = itemData.item_id\n      const finalAmount = allocationData.amount || itemData.project_price || itemData.market_value || '0.00'\n      const currentTransactionId: string | null = itemData.transaction_id || null\n\n      // Scenario A: Item currently in a Sale (Project X)\n      if (currentTransactionId?.startsWith('INV_SALE_')) {\n        const saleProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n        if (saleProjectId === projectId) {\n          // A.1: Remove item from Sale and DO NOT add to Purchase. Assign back to\n          // the same project (mark allocated) but do not create an INV_PURCHASE.\n          console.log('üìã Batch A.1: Item in sale for target project ‚Äî removing from sale and assigning to project', itemId)\n          await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n          await this.updateItem(accountId, itemId, {\n            projectId: projectId,\n            inventoryStatus: 'allocated',\n            transactionId: null,\n            disposition: 'keep',\n            notes: allocationData.notes,\n            space: allocationData.space || ''\n          })\n          continue\n        } else {\n          // A.2: Remove from Sale then add to Purchase for target project\n          console.log('üìã Batch A.2: Item in sale for different project ‚Äî moving to purchase for target project', itemId)\n          await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n          await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n          await this.updateItem(accountId, itemId, {\n            projectId: projectId,\n            inventoryStatus: 'allocated',\n            transactionId: canonicalTransactionId,\n            disposition: 'keep',\n            space: allocationData.space || ''\n          })\n          continue\n        }\n      }\n\n      // Scenario C: Item in Inventory (no transaction_id) ‚Äî add to Purchase\n      if (!currentTransactionId) {\n        console.log('üìã Batch C: Item in inventory ‚Äî adding to purchase', itemId)\n        await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n        await this.updateItem(accountId, itemId, {\n          projectId: projectId,\n          inventoryStatus: 'allocated',\n          transactionId: canonicalTransactionId,\n          disposition: 'keep',\n          space: allocationData.space || ''\n        })\n        continue\n      }\n\n      // Fallback: other transaction types ‚Äî add to purchase and update item\n      console.log('üìã Batch Fallback: Item in other transaction ‚Äî adding to purchase', itemId, currentTransactionId)\n      await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n      await this.updateItem(accountId, itemId, {\n        projectId: projectId,\n        inventoryStatus: 'allocated',\n        transactionId: canonicalTransactionId,\n        disposition: 'keep',\n        space: allocationData.space || ''\n      })\n    }\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async returnItemFromProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the item to determine current state\n    const item = await this.getItemById(accountId, itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.projectPrice || item.marketValue || '0.00'\n    const currentTransactionId: string | null = item.transactionId || null\n\n    console.log('üîÑ Starting return process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.projectId,\n      finalAmount\n    })\n\n    // Log return start (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', itemId, item.projectId ?? null, currentTransactionId ?? null, {\n        action: 'return_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC for returns (reverse of allocation)\n\n    // If item is in a Purchase transaction, this is a return (Scenario B reverse)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // Returning from same project - remove from Purchase, move to inventory\n        console.log('üìã Return Scenario: Item in Purchase, returning from same project')\n        return await this.handleReturnFromPurchase(accountId, itemId, currentTransactionId, projectId, finalAmount, notes)\n      }\n    }\n\n    // If item is not in any transaction or is in inventory, this is a new return\n    console.log('üìã Return Scenario: Item not in transaction or new return')\n    return await this.handleNewReturn(accountId, itemId, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle return from Purchase transaction (same project)\n  async handleReturnFromPurchase(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction and return it to inventory.\n    // Per allocation rules, do NOT create an INV_SALE when the item was part of\n    // an INV_PURCHASE for the same project. Simply remove the item from the\n    // purchase (the helper will delete the purchase if empty), then update the\n    // item to reflect that it's back in business inventory.\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory and clear transaction linkage for canonical state\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: null,\n      disposition: 'inventory',\n      notes: notes\n    })\n\n    console.log('‚úÖ Return completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', itemId, null, currentTransactionId, {\n        action: 'return_completed',\n        scenario: 'return_from_purchase',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    // Return the original purchase transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle new return (item was already in inventory or no transaction)\n  async handleNewReturn(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get current user ID for created_by field\n    const currentUser = await getCurrentUser()\n    if (!currentUser?.id) {\n      throw new Error('User must be authenticated to create transactions')\n    }\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(accountId, projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Create Sale transaction (project selling TO us)\n    const saleTransactionId = `INV_SALE_${projectId}`\n\n    // Check if the canonical transaction already exists (account-scoped)\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', saleTransactionId)\n      .single()\n\n    const now = new Date()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingItemIds = existingTransaction.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const { data: itemsData, error: itemsError } = await supabase\n        .from('items')\n        .select('project_price, market_value')\n        .eq('account_id', accountId)\n        .in('item_id', updatedItemIds)\n\n      if (itemsError) throw itemsError\n\n      const totalAmount = (itemsData || [])\n        .map(item => item.project_price || item.market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n        updated_at: now.toISOString()\n      }\n\n      const { error: updateError } = await supabase\n        .from('transactions')\n        .update(updatedTransactionData)\n        .eq('account_id', accountId)\n        .eq('transaction_id', saleTransactionId)\n\n      if (updateError) throw updateError\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // Transaction doesn't exist - create new one\n      const transactionData = {\n        account_id: accountId,\n        transaction_id: saleTransactionId,\n        project_id: projectId,\n        transaction_date: toDateOnlyString(now),\n        source: projectName,\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: finalAmount,\n        budget_category: 'Furnishings',\n        notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: COMPANY_OWES_CLIENT,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [itemId],\n        created_by: currentUser.id,\n        created_at: now.toISOString(),\n        updated_at: now.toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      // Insert the transaction (we've already checked it doesn't exist above)\n      const { error: insertError } = await supabase\n        .from('transactions')\n        .insert(transactionData)\n\n      if (insertError) throw insertError\n    }\n\n    // Update item status to inventory\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: saleTransactionId,\n      disposition: 'inventory'\n    })\n\n    console.log('‚úÖ New return completed: Inventory ‚Üí Sale')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', itemId, null, saleTransactionId, {\n        action: 'return_completed',\n        scenario: 'new_return',\n        from_status: 'inventory',\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    accountId: string,\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_PURCHASE_${projectId}`\n\n    // Get the transaction\n    const { data: transactionData, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n      .single()\n\n    if (fetchError || !transactionData) {\n      throw new Error('Transaction not found')\n    }\n\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    const now = new Date()\n    const { error: updateError } = await supabase\n      .from('transactions')\n      .update({\n        status: 'completed',\n        payment_method: paymentMethod,\n        transaction_date: toDateOnlyString(now),\n        updated_at: now.toISOString()\n      })\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n\n    if (updateError) throw updateError\n\n    // Clear transaction_id from all linked items (update sequentially since Supabase doesn't have batch updates)\n    for (const itemId of itemIds) {\n      if (transactionType === 'sale') {\n        // For sales, keep project_id but clear transaction_id and set status to sold\n        await this.updateItem(accountId, itemId, {\n          transactionId: null,\n          inventoryStatus: 'sold'\n        })\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        await this.updateItem(accountId, itemId, {\n          projectId: null,\n          transactionId: null,\n          inventoryStatus: 'available'\n        })\n      }\n    }\n  },\n\n  // Helper function to get item by ID (account-scoped)\n  async getItemById(accountId: string, itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    return this._convertItemFromDb(data)\n  },\n\n  // Duplicate an existing item (unified collection version) (account-scoped)\n  async duplicateItem(accountId: string, projectId: string, originalItemId: string): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the original item first\n    const originalItem = await this.getItemById(accountId, originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    const duplicatedItem: any = {\n      account_id: accountId,\n      item_id: newItemId,\n      description: originalItem.description || '',\n      source: originalItem.source || '',\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchasePrice || null,\n      project_price: originalItem.projectPrice || null,\n      market_value: originalItem.marketValue || null,\n      payment_method: originalItem.paymentMethod || '',\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || null,\n      space: originalItem.space || null,\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transactionId || null,\n      project_id: projectId,\n      inventory_status: originalItem.inventoryStatus || 'available',\n      business_inventory_location: originalItem.businessInventoryLocation || null,\n      date_created: originalItem.dateCreated || toDateOnlyString(now),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [], // Copy images from original item\n      tax_rate_pct: originalItem.taxRatePct || null,\n      tax_amount: originalItem.taxAmount || null,\n      created_by: originalItem.createdBy || null,\n      created_at: now.toISOString()\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const { error } = await supabase\n      .from('items')\n      .insert(duplicatedItem)\n\n    if (error) throw error\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version) (account-scoped)\n  async createTransactionItems(\n    accountId: string,\n    projectId: string,\n    transactionId: string,\n    transaction_date: string,\n    transactionSource: string,\n    items: TransactionItemFormData[],\n    taxRatePct?: number\n  ): Promise<string[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    // Attempt to read the transaction's tax rate once (avoid per-item reads)\n    let inheritedTax: number | undefined = undefined\n    try {\n      if ((taxRatePct === undefined || taxRatePct === null) && transactionId) {\n        const { data: txData, error: txError } = await supabase\n          .from('transactions')\n          .select('tax_rate_pct')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n\n        if (!txError && txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n          inheritedTax = txData.tax_rate_pct\n        }\n      }\n    } catch (e) {\n      // non-fatal - continue without inherited tax\n    }\n\n    // Prepare all items for batch insert\n    const itemsToInsert: any[] = []\n\n    for (const itemData of items) {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item: any = {\n        account_id: accountId,\n        item_id: itemId,\n        description: itemData.description || '',\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchasePrice || null,\n        project_price: itemData.projectPrice || null,\n        market_value: itemData.marketValue || null,\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || null,\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        inventory_status: 'allocated',\n        date_created: transaction_date,\n        last_updated: now.toISOString(),\n        images: [], // Start with empty images array, will be populated after upload\n        created_at: now.toISOString()\n      }\n\n      // Attach tax rate from explicit arg, otherwise inherited transaction value\n      if (taxRatePct !== undefined && taxRatePct !== null) {\n        item.tax_rate_pct = taxRatePct\n      } else if (inheritedTax !== undefined) {\n        item.tax_rate_pct = inheritedTax\n      }\n\n      itemsToInsert.push(item)\n    }\n\n    // Insert all items in a single batch operation\n    if (itemsToInsert.length > 0) {\n      const { error } = await supabase\n        .from('items')\n        .insert(itemsToInsert)\n\n      if (error) throw error\n    }\n\n    return createdItemIds\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('üîÑ handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('‚è≠Ô∏è Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('üîç Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(accountId, itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('‚úÖ Item found:', item.itemId, 'disposition:', item.disposition, 'projectId:', item.projectId)\n\n      // If the item is currently linked to an INV_PURCHASE for the same project,\n      // this is a purchase-reversion: remove it from the purchase and return it\n      // to inventory instead of creating an INV_SALE. This prevents creating\n      // both INV_PURCHASE and INV_SALE canonical transactions for the same\n      // item/project.\n      if (item.transactionId && item.transactionId.startsWith('INV_PURCHASE_')) {\n        const purchaseProjectId = item.transactionId.replace('INV_PURCHASE_', '')\n        if (purchaseProjectId === projectId) {\n          console.log('üîÅ Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory')\n\n          // Remove item from the existing purchase (will delete if empty)\n          await unifiedItemsService.removeItemFromTransaction(accountId, item.itemId, item.transactionId, item.projectPrice || item.marketValue || '0.00')\n\n          // Update the item to reflect it's back in business inventory\n          await unifiedItemsService.updateItem(accountId, item.itemId, {\n            projectId: null,\n            inventoryStatus: 'available',\n            transactionId: null,\n            lastUpdated: new Date().toISOString()\n          })\n\n          try {\n            await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, item.transactionId, {\n              action: 'deallocation_completed',\n              scenario: 'purchase_reversion',\n              from_transaction: item.transactionId,\n              to_status: 'inventory',\n              amount: item.projectPrice || item.marketValue || '0.00'\n            })\n          } catch (auditError) {\n            console.warn('‚ö†Ô∏è Failed to log deallocation completion for purchase-reversion:', auditError)\n          }\n\n          console.log('‚úÖ Purchase-reversion handled: item returned to inventory without creating INV_SALE')\n          return\n        }\n      }\n\n      // Unified approach: Always create/update a \"Sale\" transaction for inventory designation (project selling TO us)\n      console.log('üè¶ Creating/updating Sale transaction for inventory designation')\n\n      // Log deallocation start (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent(accountId, 'deallocation', itemId, item.projectId ?? null, item.transactionId ?? null, {\n          action: 'deallocation_started',\n          target_status: 'inventory',\n          current_transaction_id: item.transactionId\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation start:', auditError)\n      }\n\n      const transactionId = await this.ensureSaleTransaction(\n        accountId,\n        item,\n        projectId,\n        'Transaction for items purchased from project and moved to business inventory'\n      )\n\n      console.log('üì¶ Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(accountId, item.itemId, {\n        projectId: null,\n        inventoryStatus: 'available',\n        transactionId: transactionId,\n        space: '', // Clear space field when moving to business inventory\n        lastUpdated: new Date().toISOString()\n      })\n\n      // Log successful deallocation (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, transactionId, {\n          action: 'deallocation_completed',\n          from_project_id: item.projectId,\n          to_transaction: transactionId,\n          amount: item.projectPrice || item.marketValue || '0.00'\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n      }\n\n      console.log('‚úÖ Item moved to business inventory successfully')\n\n      console.log('‚úÖ Deallocation completed successfully')\n    } catch (error) {\n      console.error('‚ùå Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a sale transaction exists for inventory designation (follows ALLOCATION_TRANSACTION_LOGIC.md)\n  async ensureSaleTransaction(\n    accountId: string,\n    item: Item,\n    projectId: string,\n    additionalNotes?: string\n  ): Promise<string | null> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get current user ID for created_by field\n    const currentUser = await getCurrentUser()\n    if (!currentUser?.id) {\n      throw new Error('User must be authenticated to create transactions')\n    }\n\n    console.log('üè¶ Creating/updating sale transaction for item:', item.itemId)\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(accountId, projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Defensive check: if the item is still linked to a purchase for this\n    // project, treat as purchase-reversion and do not create an INV_SALE.\n    if (item.transactionId && item.transactionId.startsWith('INV_PURCHASE_')) {\n      const purchaseProjectId = item.transactionId.replace('INV_PURCHASE_', '')\n      if (purchaseProjectId === projectId) {\n        console.log('‚ÑπÔ∏è ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE')\n\n        // Remove the item from the purchase and return to inventory\n        await unifiedItemsService.removeItemFromTransaction(accountId, item.itemId, item.transactionId, item.projectPrice || item.marketValue || '0.00')\n        await unifiedItemsService.updateItem(accountId, item.itemId, {\n          projectId: null,\n          inventoryStatus: 'available',\n          transactionId: null\n        })\n\n        // Return null to indicate no INV_SALE was created\n        return null\n      }\n    }\n\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n    console.log('üîë Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists (account-scoped)\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n      .single()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingItemIds = existingTransaction.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.itemId])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const { data: itemsData, error: itemsError } = await supabase\n        .from('items')\n        .select('project_price, market_value')\n        .eq('account_id', accountId)\n        .in('item_id', updatedItemIds)\n\n      if (itemsError) throw itemsError\n\n      const totalAmount = (itemsData || [])\n        .map(item => item.project_price || item.market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const now = new Date()\n      const updatedTransactionData = {\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        updated_at: now.toISOString()\n      }\n\n      const { error: updateError } = await supabase\n        .from('transactions')\n        .update(updatedTransactionData)\n        .eq('account_id', accountId)\n        .eq('transaction_id', canonicalTransactionId)\n\n      if (updateError) throw updateError\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // Calculate amount from item for new transaction\n      const calculatedAmount = item.projectPrice || item.marketValue || '0.00'\n\n      // New transaction - create Sale transaction (project moving item TO inventory)\n      const now = new Date()\n      const transactionData = {\n        account_id: accountId,\n        transaction_id: canonicalTransactionId,\n        project_id: projectId,\n        transaction_date: toDateOnlyString(now),\n        source: projectName,  // Project name as source (project moving to inventory)\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: parseFloat(calculatedAmount || '0').toFixed(2),\n        budget_category: 'Furnishings',\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: COMPANY_OWES_CLIENT,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [item.itemId],\n        created_by: currentUser.id,\n        created_at: now.toISOString(),\n        updated_at: now.toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      // Insert the transaction (we've already checked it doesn't exist above)\n      const { error: insertError } = await supabase\n        .from('transactions')\n        .insert(transactionData)\n\n      if (insertError) throw insertError\n    }\n\n    console.log('‚úÖ Sale transaction created/updated successfully')\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(accountId, itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    accountId: string,\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(accountId, itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    accountId: string,\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction(accountId, 'sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(accountId, itemId, projectId, disposition)\n  }\n}\n"],"names":["toDate","value","error","year","month","day","date","formatDate","fallback","options","mergedOptions","formatCurrency","amount","num","toDateOnlyString","d","yyyy","mm","dd","auditService","accountId","eventType","itemId","projectId","transactionIdOrDetails","detailsOrUndefined","transactionId","details","supabase","changeType","oldState","newState","projectService","ensureAuthenticatedForDatabase","data","project","converted","convertTimestamps","projectData","updates","updateData","callback","initialProjects","projects","channel","payload","newRecord","oldRecord","updatedProject","p","oldId","status","err","dbProject","_convertTransactionFromDb","dbTransaction","_enrichTransactionsWithProjectNames","transactions","tx","id","projectMap","projectName","_convertTransactionToDb","transaction","transactionService","projectIds","_projectId","transactionData","items","currentUser","getCurrentUser","now","amountNum","subtotalNum","rate","preset","getTaxPresetById","itemsToCreate","i","createdItemIds","unifiedItemsService","finalUpdates","existing","existingData","amountVal","subtotalVal","e","dbUpdates","item","initialTransactions","newProjectId","oldProjectId","matchesProject","candidate","newTransaction","enrichedTransaction","t","updatedTransaction","wasInProject","isInProject","sortedTransactions","a","b","enriched","CLIENT_OWES_COMPANY","COMPANY_OWES_CLIENT","dbItem","filters","pagination","query","offset","initialItems","updatedItem","_filters","itemData","qrKey","txData","willSetTransaction","missingTax","txId","notes","space","finalAmount","currentTransactionId","auditError","purchaseTransactionId","_notes","saleTransactionId","_itemAmount","fetchError","updatedItemIds","deleteError","itemsData","itemsError","totalAmount","sum","price","safeAmount","updateError","transactionType","triggerEvent","existingTransaction","existingItemIds","txTax","insertError","itemIds","allocationData","canonicalTransactionId","updatedTransactionData","paymentMethod","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","key","transaction_date","transactionSource","taxRatePct","inheritedTax","txError","itemsToInsert","deallocationService","disposition","additionalNotes","calculatedAmount","integrationService","_transactionId","_itemId"],"mappings":"6GAKO,MAAMA,EAAUC,GAAkC,CACvD,GAAI,CAACA,EAAO,OAAO,KAEnB,GAAIA,aAAiB,KACnB,OAAOA,EAIT,GAAI,OAAOA,GAAU,UAAYA,EAAO,CAEtC,GAAI,WAAYA,GAAS,OAAQA,EAAc,QAAW,WACxD,GAAI,CACF,OAAQA,EAAc,OAAA,CACxB,OAASC,EAAO,CACd,eAAQ,KAAK,uCAAwCA,CAAK,EACnD,IACT,CAIF,GAAI,YAAaD,GAAS,gBAAiBA,EACzC,GAAI,CACF,OAAO,IAAI,KAAMA,EAAc,QAAU,IAAQA,EAAc,YAAc,GAAO,CACtF,OAASC,EAAO,CACd,eAAQ,KAAK,uCAAwCA,CAAK,EACnD,IACT,CAEJ,CAGA,GAAI,OAAOD,GAAU,SACnB,GAAI,CAGF,GAAI,sBAAsB,KAAKA,CAAK,EAAG,CAErC,KAAM,CAACE,EAAMC,EAAOC,CAAG,EAAIJ,EAAM,MAAM,GAAG,EAAE,IAAI,MAAM,EAChDK,EAAO,IAAI,KAAKH,EAAMC,EAAQ,EAAGC,CAAG,EAC1C,OAAO,MAAMC,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,CAGA,MAAMA,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,+BAAgCD,EAAOC,CAAK,EAClD,IACT,CAIF,GAAI,OAAOD,GAAU,SACnB,GAAI,CACF,MAAMK,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,oCAAqCD,EAAOC,CAAK,EACvD,IACT,CAGF,OAAO,IACT,EAKaK,EAAa,CACxBN,EACAO,EAAmB,UACnBC,IACW,CACX,MAAMH,EAAON,EAAOC,CAAK,EACzB,GAAI,CAACK,EAAM,OAAOE,EAElB,GAAI,CAOF,MAAME,EAAgB,CAAE,GAN2B,CACjD,KAAM,UACN,MAAO,QACP,IAAK,SAAA,EAGoC,GAAGD,CAAA,EAC9C,OAAOH,EAAK,mBAAmB,QAASI,CAAa,CACvD,OAASR,EAAO,CACd,eAAQ,KAAK,yBAA0BD,EAAOC,CAAK,EAC5CM,CACT,CACF,EAsDaG,EAAiB,CAACC,EAAyBJ,EAAmB,UAAoB,CAC7F,MAAMK,EAAM,OAAOD,GAAW,SAAW,WAAWA,CAAM,EAAIA,EAE9D,OAAI,MAAMC,CAAG,EAAUL,EAEhBK,EAAI,eAAe,QAAS,CACjC,MAAO,WACP,SAAU,MACV,sBAAuB,EACvB,sBAAuB,CAAA,CACxB,CACH,EA+BaC,EAAoBb,GAA6B,CAC5D,GAAI,CAACA,EAAO,MAAO,GAEnB,GAAI,OAAOA,GAAU,UAAY,sBAAsB,KAAKA,CAAK,EAC/D,OAAOA,EAET,MAAMc,EAAIf,EAAOC,CAAK,EACtB,GAAI,CAACc,EAAG,MAAO,GACf,MAAMC,EAAOD,EAAE,YAAA,EACTE,EAAK,OAAOF,EAAE,SAAA,EAAa,CAAC,EAAE,SAAS,EAAG,GAAG,EAC7CG,EAAK,OAAOH,EAAE,QAAA,CAAS,EAAE,SAAS,EAAG,GAAG,EAC9C,MAAO,GAAGC,CAAI,IAAIC,CAAE,IAAIC,CAAE,EAC5B,EClMaC,EAAe,CAE1B,MAAM,mBACJC,EACAC,EACAC,EACAC,EACAC,EACAC,EACe,CACf,GAAI,CAEF,IAAIC,EAA2C,KAC3CC,EAA+B,CAAA,EAE/B,OAAOH,GAA2B,UACpCE,EAAgBF,EAChBG,EAAUF,GAAsB,CAAA,IAEhCC,EAAgB,KAChBC,EAAUH,GAA0B,CAAA,GAGtC,KAAM,CAAE,MAAAtB,GAAU,MAAM0B,EACrB,KAAK,YAAY,EACjB,OAAO,CACN,WAAYR,EACZ,WAAYC,EACZ,QAASC,EACT,WAAYC,EACZ,eAAgBG,EAChB,QAAAC,EACA,UAAW,IAAI,KAAA,EAAO,YAAA,EACtB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EAECzB,EACF,QAAQ,KAAK,+CAAgDA,CAAK,EAElE,QAAQ,IAAI,oBAAoBmB,CAAS,aAAaC,CAAM,EAAE,CAElE,OAASpB,EAAO,CACd,QAAQ,KAAK,+CAAgDA,CAAK,CAEpE,CACF,EAGA,MAAM,0BACJkB,EACAM,EACAG,EACAC,EACAC,EACe,CACf,GAAI,CACF,KAAM,CAAE,MAAA7B,GAAU,MAAM0B,EACrB,KAAK,wBAAwB,EAC7B,OAAO,CACN,WAAYR,EACZ,eAAgBM,EAChB,YAAaG,EACb,UAAWC,GAAY,KACvB,UAAWC,GAAY,KACvB,UAAW,IAAI,KAAA,EAAO,YAAA,EACtB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EAEC7B,EACF,QAAQ,KAAK,qDAAsDA,CAAK,EAExE,QAAQ,IAAI,gCAAgC2B,CAAU,QAAQH,CAAa,EAAE,CAEjF,OAASxB,EAAO,CACd,QAAQ,KAAK,qDAAsDA,CAAK,CAE1E,CACF,CACF,EAGa8B,EAAiB,CAE5B,MAAM,YAAYZ,EAAuC,CACvD,MAAMa,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,GAAU,MAAM0B,EAC3B,KAAK,UAAU,EACf,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAIlB,EAAO,MAAMA,EAEjB,OAAQgC,GAAQ,CAAA,GAAI,IAAIC,GAAW,CACjC,MAAMC,EAAYC,EAAkBF,CAAO,EAC3C,MAAO,CACL,GAAIC,EAAU,GACd,UAAWA,EAAU,WACrB,KAAMA,EAAU,KAChB,YAAaA,EAAU,aAAe,GACtC,WAAYA,EAAU,aAAe,GACrC,OAAQA,EAAU,OAAS,WAAWA,EAAU,MAAM,EAAI,OAC1D,UAAWA,EAAU,WAAa,WAAWA,EAAU,UAAU,EAAI,OACrE,iBAAkBA,EAAU,mBAAqB,OACjD,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,SAAUA,EAAU,UAAY,OAChC,SAAUA,EAAU,UAAY,OAChC,UAAWA,EAAU,YAAc,EACnC,iBAAkBA,EAAU,mBAAqB,EACjD,WAAYA,EAAU,YAAc,WAAWA,EAAU,WAAW,EAAI,CAAA,CAE5E,CAAC,CACH,EAGA,MAAM,WAAWhB,EAAmBG,EAA4C,CAC9E,MAAMU,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,UAAU,EACf,OAAO,GAAG,EACV,GAAG,KAAML,CAAS,EAClB,GAAG,aAAcH,CAAS,EAC1B,OAAA,EAEH,GAAIlB,EAAO,CACT,GAAIA,EAAM,OAAS,WACjB,OAAO,KAET,MAAMA,CACR,CAEA,GAAI,CAACgC,EAAM,OAAO,KAElB,MAAME,EAAYC,EAAkBH,CAAI,EACxC,MAAO,CACL,GAAIE,EAAU,GACd,UAAWA,EAAU,WACrB,KAAMA,EAAU,KAChB,YAAaA,EAAU,aAAe,GACtC,WAAYA,EAAU,aAAe,GACrC,OAAQA,EAAU,OAAS,WAAWA,EAAU,MAAM,EAAI,OAC1D,UAAWA,EAAU,WAAa,WAAWA,EAAU,UAAU,EAAI,OACrE,iBAAkBA,EAAU,mBAAqB,OACjD,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,SAAUA,EAAU,UAAY,OAChC,SAAUA,EAAU,UAAY,OAChC,UAAWA,EAAU,YAAc,EACnC,iBAAkBA,EAAU,mBAAqB,EACjD,WAAYA,EAAU,YAAc,WAAWA,EAAU,WAAW,EAAI,CAAA,CAE5E,EAGA,MAAM,cAAchB,EAAmBkB,EAA+E,CACpH,MAAML,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,GAAU,MAAM0B,EAC3B,KAAK,UAAU,EACf,OAAO,CACN,WAAYR,EACZ,KAAMkB,EAAY,KAClB,YAAaA,EAAY,aAAe,KACxC,YAAaA,EAAY,YAAc,KACvC,OAAQA,EAAY,QAAU,KAC9B,WAAYA,EAAY,WAAa,KACrC,kBAAmBA,EAAY,kBAAoB,CAAA,EACnD,SAAUA,EAAY,UAAY,CAAA,EAClC,SAAUA,EAAY,UAAY,CAAA,EAClC,WAAYA,EAAY,UACxB,WAAY,EACZ,kBAAmB,EACnB,YAAa,EACb,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACA,OAAO,IAAI,EACX,OAAA,EAEH,GAAIpC,EAAO,MAAMA,EACjB,OAAOgC,EAAK,EACd,EAGA,MAAM,cAAcd,EAAmBG,EAAmBgB,EAA0C,CAClG,MAAMN,EAAA,EAEN,MAAMO,EAAkB,CACtB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAGjCD,EAAQ,OAAS,SAAWC,EAAW,KAAOD,EAAQ,MACtDA,EAAQ,cAAgB,SAAWC,EAAW,YAAcD,EAAQ,aACpEA,EAAQ,aAAe,SAAWC,EAAW,YAAcD,EAAQ,YACnEA,EAAQ,SAAW,SAAWC,EAAW,OAASD,EAAQ,QAC1DA,EAAQ,YAAc,SAAWC,EAAW,WAAaD,EAAQ,WACjEA,EAAQ,mBAAqB,SAAWC,EAAW,kBAAoBD,EAAQ,kBAC/EA,EAAQ,WAAa,SAAWC,EAAW,SAAWD,EAAQ,UAC9DA,EAAQ,WAAa,SAAWC,EAAW,SAAWD,EAAQ,UAElE,KAAM,CAAE,MAAArC,CAAA,EAAU,MAAM0B,EACrB,KAAK,UAAU,EACf,OAAOY,CAAU,EACjB,GAAG,KAAMjB,CAAS,EAClB,GAAG,aAAcH,CAAS,EAE7B,GAAIlB,EAAO,MAAMA,CACnB,EAGA,MAAM,cAAckB,EAAmBG,EAAkC,CACvE,MAAMU,EAAA,EAEN,KAAM,CAAE,MAAA/B,CAAA,EAAU,MAAM0B,EACrB,KAAK,UAAU,EACf,OAAA,EACA,GAAG,KAAML,CAAS,EAClB,GAAG,aAAcH,CAAS,EAE7B,GAAIlB,EAAO,MAAMA,CACnB,EAGA,oBACEkB,EACAqB,EACAC,EACA,CACA,IAAIC,EAAW,CAAC,GAAID,GAAmB,EAAG,EAE1C,MAAME,EAAUhB,EACb,QAAQ,YAAYR,CAAS,EAAE,EAC/B,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,WACP,OAAQ,iBAAiBA,CAAS,EAAA,EAEnCyB,GAAY,CACX,QAAQ,IAAI,4BAA6BA,CAAO,EAChD,KAAM,CAAE,UAAAxB,EAAW,IAAKyB,EAAW,IAAKC,GAAcF,EAEtD,GAAIxB,IAAc,SAEhBsB,EAAW,CADQX,EAAe,sBAAsBc,CAAS,EACzC,GAAGH,CAAQ,UAC1BtB,IAAc,SAAU,CACjC,MAAM2B,EAAiBhB,EAAe,sBAAsBc,CAAS,EACrEH,EAAWA,EAAS,IAAIM,GAAKA,EAAE,KAAOD,EAAe,GAAKA,EAAiBC,CAAC,CAC9E,SAAW5B,IAAc,SAAU,CACjC,MAAM6B,EAAQH,EAAU,GACxBJ,EAAWA,EAAS,OAAOM,GAAKA,EAAE,KAAOC,CAAK,CAChD,CAEAT,EAAS,CAAC,GAAGE,CAAQ,CAAC,CACxB,CAAA,EAED,UAAU,CAACQ,EAAQC,IAAQ,CACtBD,IAAW,cACb,QAAQ,IAAI,gCAAgC,EAE1CC,GACF,QAAQ,MAAM,yCAA0CA,CAAG,CAE/D,CAAC,EAEH,MAAO,IAAM,CACXR,EAAQ,YAAA,CACV,CACF,EAGA,sBAAsBS,EAAyB,CAC7C,MAAMjB,EAAYC,EAAkBgB,CAAS,EAC7C,MAAO,CACL,GAAIjB,EAAU,GACd,UAAWA,EAAU,WACrB,KAAMA,EAAU,KAChB,YAAaA,EAAU,aAAe,GACtC,WAAYA,EAAU,aAAe,GACrC,OAAQA,EAAU,OAAS,WAAWA,EAAU,MAAM,EAAI,OAC1D,UAAWA,EAAU,WAAa,WAAWA,EAAU,UAAU,EAAI,OACrE,iBAAkBA,EAAU,mBAAqB,OACjD,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,UAAWA,EAAU,WACrB,SAAUA,EAAU,UAAY,OAChC,SAAUA,EAAU,UAAY,OAChC,UAAWA,EAAU,YAAc,EACnC,iBAAkBA,EAAU,mBAAqB,EACjD,WAAYA,EAAU,YAAc,WAAWA,EAAU,WAAW,EAAI,CAAA,CAE5E,CACF,EAMA,SAASkB,EAA0BC,EAAiC,CAClE,MAAMnB,EAAYC,EAAkBkB,CAAa,EACjD,MAAO,CACL,cAAenB,EAAU,eACzB,UAAWA,EAAU,YAAc,OACnC,YAAaA,EAAU,cAAgB,OACvC,gBAAiBA,EAAU,iBAC3B,OAAQA,EAAU,QAAU,GAC5B,gBAAiBA,EAAU,kBAAoB,GAC/C,cAAeA,EAAU,gBAAkB,GAC3C,OAAQA,EAAU,QAAU,OAC5B,eAAgBA,EAAU,iBAAmB,OAC7C,MAAOA,EAAU,OAAS,OAC1B,kBAAmB,MAAM,QAAQA,EAAU,kBAAkB,EAAIA,EAAU,mBAAqB,CAAA,EAChG,cAAe,MAAM,QAAQA,EAAU,cAAc,EAAIA,EAAU,eAAiB,CAAA,EACpF,YAAa,MAAM,QAAQA,EAAU,YAAY,EAAIA,EAAU,aAAe,CAAA,EAC9E,eAAgBA,EAAU,iBAAmB,GAC7C,UAAWA,EAAU,WACrB,UAAWA,EAAU,YAAc,GACnC,OAAQA,EAAU,QAAU,YAC5B,kBAAmBA,EAAU,oBAAsB,OACnD,aAAcA,EAAU,eAAiB,OACzC,QAAS,MAAM,QAAQA,EAAU,QAAQ,EAAIA,EAAU,SAAW,CAAA,EAClE,cAAeA,EAAU,iBAAmB,OAC5C,WAAYA,EAAU,aAAe,WAAWA,EAAU,YAAY,EAAI,OAC1E,SAAUA,EAAU,UAAY,MAAA,CAEpC,CAMA,eAAeoB,EACbpC,EACAqC,EACAd,EACwB,CAOxB,GALmB,CAAC,GAAG,IAAI,IAAIc,EAC5B,IAAIC,GAAMA,EAAG,SAAS,EACtB,OAAQC,GAAqB,CAAC,CAACA,CAAE,CAAA,CACnC,EAEc,SAAW,EAExB,OAAOF,EAIT,MAAMG,MAAiB,IACvB,GAAI,EACe,MAAM5B,EAAe,YAAYZ,CAAS,GAClD,QAAQe,GAAW,CAC1ByB,EAAW,IAAIzB,EAAQ,GAAIA,EAAQ,IAAI,CACzC,CAAC,CACH,OAASjC,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAE5E,CAGA,OAAOuD,EAAa,IAAIC,GAAM,CAC5B,GAAIA,EAAG,WAAa,CAACA,EAAG,YAAa,CACnC,MAAMG,EAAcD,EAAW,IAAIF,EAAG,SAAS,EAC/C,GAAIG,EACF,MAAO,CAAE,GAAGH,EAAI,YAAAG,CAAA,CAEpB,CACA,OAAOH,CACT,CAAC,CACH,CAEA,SAASI,EAAwBC,EAAwC,CACvE,MAAMR,EAAqB,CAAA,EAE3B,OAAIQ,EAAY,gBAAkB,SAAWR,EAAc,eAAiBQ,EAAY,eACpFA,EAAY,YAAc,SAAWR,EAAc,WAAaQ,EAAY,WAAa,MACzFA,EAAY,kBAAoB,SAAWR,EAAc,iBAAmBQ,EAAY,iBACxFA,EAAY,SAAW,SAAWR,EAAc,OAASQ,EAAY,QACrEA,EAAY,kBAAoB,SAAWR,EAAc,iBAAmBQ,EAAY,iBACxFA,EAAY,gBAAkB,SAAWR,EAAc,eAAiBQ,EAAY,eACpFA,EAAY,SAAW,SAAWR,EAAc,OAASQ,EAAY,QACrEA,EAAY,iBAAmB,SAAWR,EAAc,gBAAkBQ,EAAY,gBACtFA,EAAY,QAAU,SAAWR,EAAc,MAAQQ,EAAY,OACnEA,EAAY,oBAAsB,SAAWR,EAAc,mBAAqBQ,EAAY,mBAC5FA,EAAY,gBAAkB,SAAWR,EAAc,eAAiBQ,EAAY,eACpFA,EAAY,cAAgB,SAAWR,EAAc,aAAeQ,EAAY,aAChFA,EAAY,iBAAmB,SAAWR,EAAc,gBAAkBQ,EAAY,gBACtFA,EAAY,YAAc,SAAWR,EAAc,WAAaQ,EAAY,WAC5EA,EAAY,YAAc,SAAWR,EAAc,WAAaQ,EAAY,WAC5EA,EAAY,SAAW,SAAWR,EAAc,OAASQ,EAAY,QACrEA,EAAY,oBAAsB,SAAWR,EAAc,mBAAqBQ,EAAY,mBAC5FA,EAAY,eAAiB,SAAWR,EAAc,cAAgBQ,EAAY,cAClFA,EAAY,UAAY,SAAWR,EAAc,SAAWQ,EAAY,SACxEA,EAAY,gBAAkB,SAAWR,EAAc,gBAAkBQ,EAAY,eACrFA,EAAY,aAAe,SAAWR,EAAc,aAAeQ,EAAY,YAC/EA,EAAY,WAAa,SAAWR,EAAc,SAAWQ,EAAY,UAEtER,CACT,CAGO,MAAMS,EAAqB,CAEhC,MAAM,gBAAgB5C,EAAmBG,EAA2C,CAClF,MAAMU,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAcG,CAAS,EAC1B,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAIrB,EAAO,MAAMA,EAEjB,MAAMuD,GAAgBvB,GAAQ,CAAA,GAAI,IAAIwB,GAAMJ,EAA0BI,CAAE,CAAC,EACzE,OAAO,MAAMF,EAAoCpC,EAAWqC,CAAY,CAC1E,EAGA,MAAM,2BAA2BrC,EAAmB6C,EAAsBtB,EAA8C,CAGtH,GAFA,MAAMV,EAAA,EAEFgC,EAAW,SAAW,EACxB,MAAO,CAAA,EAGT,KAAM,CAAE,KAAA/B,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAc6C,CAAU,EAC3B,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAI/D,EAAO,MAAMA,EAEjB,MAAMuD,GAAgBvB,GAAQ,CAAA,GAAI,IAAIwB,GAAMJ,EAA0BI,CAAE,CAAC,EACzE,OAAO,MAAMF,EAAoCpC,EAAWqC,CAAsB,CACpF,EAGA,MAAM,eAAerC,EAAmB8C,EAAoBxC,EAAoD,CAC9G,MAAMO,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAIxB,EAAO,CACT,GAAIA,EAAM,OAAS,WACjB,OAAO,KAET,MAAMA,CACR,CAEA,GAAI,CAACgC,EAAM,OAAO,KAElB,MAAM6B,EAAcT,EAA0BpB,CAAI,EAElD,OADiB,MAAMsB,EAAoCpC,EAAW,CAAC2C,CAAW,CAAC,GACnE,CAAC,GAAK,IACxB,EAGA,MAAM,mBAAmB3C,EAAmBM,EAA+F,CACzI,MAAMO,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAIxB,GAAS,CAACgC,EACZ,MAAO,CAAE,YAAa,KAAM,UAAW,IAAA,EAGzC,MAAME,EAAYC,EAAkBH,CAAI,EAClC6B,EAAcT,EAA0BpB,CAAI,EAGlD,MAAO,CACL,aAHe,MAAMsB,EAAoCpC,EAAW,CAAC2C,CAAW,CAAC,GAG3D,CAAC,GAAKA,EAC5B,UAAW3B,EAAU,YAAc,IAAA,CAEvC,EAGA,MAAM,kBACJhB,EACAG,EACA4C,EACAC,EACiB,CACjB,GAAI,CACF,MAAMnC,EAAA,EAGN,MAAMoC,EAAc,MAAMC,EAAA,EAG1B,GAAI,EAFWH,EAAgB,YAAaE,GAAA,YAAAA,EAAa,KAAM,MAG7D,MAAM,IAAI,MAAM,mDAAmD,EAGrE,MAAME,MAAU,KAEV7C,EAAgB,OAAO,WAAA,EAGvB6B,EAAgBO,EAAwB,CAC5C,GAAGK,EACH,cAAAzC,EACA,UAAW6C,EAAI,YAAA,CAAY,CAC5B,EAYD,GATAhB,EAAc,WAAanC,EAC3BmC,EAAc,WAAagB,EAAI,YAAA,EAC/BhB,EAAc,WAAagB,EAAI,YAAA,EAC1BhB,EAAc,SAAQA,EAAc,OAAS,aAElD,QAAQ,IAAI,wBAAyBA,CAAa,EAClD,QAAQ,IAAI,qBAAsBa,CAAK,EAGnCb,EAAc,gBAChB,GAAIA,EAAc,kBAAoB,QAAS,CAE7C,MAAMiB,EAAY,WAAWjB,EAAc,QAAU,GAAG,EAClDkB,EAAc,WAAWlB,EAAc,UAAY,GAAG,EAC5D,GAAI,MAAMkB,CAAW,GAAKA,GAAe,EACvC,MAAM,IAAI,MAAM,gEAAgE,EAElF,GAAI,MAAMD,CAAS,GAAKA,EAAYC,EAClC,MAAM,IAAI,MAAM,0CAA0C,EAE5D,MAAMC,GAASF,EAAYC,GAAeA,EAAe,IACzDlB,EAAc,aAAe,KAAK,MAAMmB,EAAO,GAAK,EAAI,GAC1D,KAAO,CAEL,MAAMC,EAAS,MAAMC,EAAiBxD,EAAWmC,EAAc,eAAe,EAC9E,GAAI,CAACoB,EACH,MAAM,IAAI,MAAM,uBAAuBpB,EAAc,eAAe,cAAc,EAEpFA,EAAc,aAAeoB,EAAO,KAEpCpB,EAAc,SAAW,IAC3B,CAGF,KAAM,CAAE,MAAArD,GAAU,MAAM0B,EACrB,KAAK,cAAc,EACnB,OAAO2B,CAAa,EAEvB,GAAIrD,EAAO,MAAMA,EAKjB,GAHA,QAAQ,IAAI,oCAAqCwB,CAAa,EAG1D0C,GAASA,EAAM,OAAS,EAAG,CAC7B,QAAQ,IAAI,kCAAmC1C,CAAa,EAE5D,MAAMmD,EAAgBT,EAAM,QAAU,CAAE,GAAGU,GAAI,EACzCC,EAAiB,MAAMC,EAAoB,uBAC/C5D,EACAG,GAAa,GACbG,EACAyC,EAAgB,gBAChBA,EAAgB,OAChBU,EACAtB,EAAc,YAAA,EAEhB,QAAQ,IAAI,iBAAkBwB,CAAc,CAC9C,CAEA,OAAOrD,CACT,OAASxB,EAAO,CACd,cAAQ,MAAM,8BAA+BA,CAAK,EAC5CA,CACR,CACF,EAGA,MAAM,kBAAkBkB,EAAmB8C,EAAoBxC,EAAuBa,EAA8C,CAClI,MAAMN,EAAA,EAGN,MAAMgD,EAAqC,CAAE,GAAG1C,CAAA,EAmBhD,GAhBI0C,EAAa,SAAW,aAAeA,EAAa,oBAAsB,SAC5EA,EAAa,kBAAoB,MAI/BA,EAAa,oBAAsB,KACrCA,EAAa,kBAAoB,MAI/BA,EAAa,mBAAqBA,EAAa,SAAW,cAE5DA,EAAa,OAAS,WAIpBA,EAAa,gBAAkB,OACjC,GAAIA,EAAa,gBAAkB,QAAS,CAE1C,KAAM,CAAE,KAAMC,CAAA,EAAa,MAAMtD,EAC9B,KAAK,cAAc,EACnB,OAAO,kBAAkB,EACzB,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEGyD,EAAeD,EACfE,EAAYH,EAAa,SAAW,OAAY,WAAWA,EAAa,MAAM,EAAI,YAAWE,GAAA,YAAAA,EAAc,SAAU,GAAG,EACxHE,EAAcJ,EAAa,WAAa,OAAY,WAAWA,EAAa,QAAQ,EAAI,YAAWE,GAAA,YAAAA,EAAc,WAAY,GAAG,EACtI,GAAI,CAAC,MAAMC,CAAS,GAAK,CAAC,MAAMC,CAAW,GAAKA,EAAc,GAAKD,GAAaC,EAAa,CAC3F,MAAMX,GAASU,EAAYC,GAAeA,EAAe,IACzDJ,EAAa,WAAa,KAAK,MAAMP,EAAO,GAAK,EAAI,GACvD,CACF,KAEE,IAAI,CACF,MAAMC,EAAS,MAAMC,EAAiBxD,EAAW6D,EAAa,aAAa,EACvEN,GACFM,EAAa,WAAaN,EAAO,KAEjCM,EAAa,SAAW,QAExB,QAAQ,KAAK,uBAAuBA,EAAa,aAAa,2BAA2B,CAE7F,OAASK,EAAG,CACV,QAAQ,KAAK,0CAA2CA,CAAC,CAC3D,CAKJ,MAAMC,EAAYzB,EAAwBmB,CAAY,EAEtDM,EAAU,WAAa,IAAI,KAAA,EAAO,YAAA,EAElC,KAAM,CAAE,MAAArF,CAAA,EAAU,MAAM0B,EACrB,KAAK,cAAc,EACnB,OAAO2D,CAAS,EAChB,GAAG,aAAcnE,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIxB,EAAO,MAAMA,EAGjB,GAAI+E,EAAa,aAAe,OAC9B,GAAI,CACF,MAAMb,EAAQ,MAAMY,EAAoB,uBAAuB5D,EAAW8C,EAAYxC,CAAa,EACnG,GAAI0C,GAASA,EAAM,OAAS,EAE1B,UAAWoB,KAAQpB,EACjB,MAAMY,EAAoB,WAAW5D,EAAWoE,EAAK,OAAQ,CAC3D,WAAYP,EAAa,UAAA,CAC1B,CAGP,OAASK,EAAG,CACV,QAAQ,KAAK,6CAA8CA,CAAC,CAC9D,CAEJ,EAGA,MAAM,kBAAkBlE,EAAmB8C,EAAoBxC,EAAsC,CACnG,MAAMO,EAAA,EAEN,KAAM,CAAE,MAAA/B,CAAA,EAAU,MAAM0B,EACrB,KAAK,cAAc,EACnB,OAAA,EACA,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIxB,EAAO,MAAMA,CACnB,EAGA,wBACEkB,EACAG,EACAkB,EACAgD,EACA,CACA,IAAIhC,EAAe,CAAC,GAAIgC,GAAuB,EAAG,EAElD,MAAM7C,EAAUhB,EACb,QAAQ,gBAAgBR,CAAS,IAAIG,CAAS,EAAE,EAChD,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,eAEP,OAAQ,iBAAiBH,CAAS,EAAA,EAEpC,MAAOyB,GAAY,CACjB,QAAQ,IAAI,gDAAiDA,CAAO,EAEpE,KAAM,CAAE,UAAAxB,EAAW,IAAKyB,EAAW,IAAKC,GAAcF,EAChD6C,GAAe5C,GAAA,YAAAA,EAAW,aAAc,KACxC6C,GAAe5C,GAAA,YAAAA,EAAW,aAAc,KAExC6C,EAAkBC,GAAyCA,IAActE,EAE/E,GAAIF,IAAc,UAChB,GAAIuE,EAAeF,CAAY,EAAG,CAChC,MAAMI,EAAiBxC,EAA0BR,CAAS,EACpD,CAACiD,CAAmB,EAAI,MAAMvC,EAAoCpC,EAAW,CAAC0E,CAAc,CAAC,EAEnGrC,EAAe,CAACsC,EAAqB,GAAGtC,EAAa,UAAYuC,EAAE,gBAAkBD,EAAoB,aAAa,CAAC,CACzH,UACS1E,IAAc,SAAU,CACjC,MAAM4E,EAAqB3C,EAA0BR,CAAS,EACxD,CAACiD,CAAmB,EAAI,MAAMvC,EAAoCpC,EAAW,CAAC6E,CAAkB,CAAC,EAEjGC,EAAezC,EAAa,QAAUuC,EAAE,gBAAkBD,EAAoB,aAAa,EAC3FI,EAAcP,EAAeF,CAAY,EAE3CS,GAAe,CAACD,EAElBzC,EAAe,CAACsC,EAAqB,GAAGtC,CAAY,EAC3C,CAAC0C,GAAeD,EAEzBzC,EAAeA,EAAa,OAAOuC,GAAKA,EAAE,gBAAkBD,EAAoB,aAAa,EACpFI,GAAeD,IAExBzC,EAAeA,EAAa,IAAIuC,GAAKA,EAAE,gBAAkBD,EAAoB,cAAgBA,EAAsBC,CAAC,EAGxH,SAAW3E,IAAc,UACnBuE,EAAeD,CAAY,EAAG,CAChC,MAAMzC,EAAQH,EAAU,eACxBU,EAAeA,EAAa,OAAOuC,GAAKA,EAAE,gBAAkB9C,CAAK,CACnE,CAGF,MAAMkD,EAAqB,CAAC,GAAG3C,CAAY,EAAE,KAAK,CAAC4C,EAAGC,IAAM,IAAI,KAAKA,EAAE,SAAS,EAAE,UAAY,IAAI,KAAKD,EAAE,SAAS,EAAE,SAAS,EAC7H5D,EAAS2D,CAAkB,CAC7B,CAAA,EAED,UAAU,CAACjD,EAAQC,IAAQ,CACtBD,IAAW,cACb,QAAQ,IAAI,oCAAoC,EAE9CC,GACF,QAAQ,MAAM,6CAA8CA,CAAG,CAEnE,CAAC,EAEH,MAAO,IAAM,CACXR,EAAQ,YAAA,CACV,CACF,EAEA,2BACExB,EACAqB,EACAgD,EACA,CACA,IAAIhC,EAAe,CAAC,GAAIgC,GAAuB,EAAG,EAElD,MAAM7C,EAAUhB,EACb,QAAQ,gBAAgBR,CAAS,EAAE,EACnC,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,eACP,OAAQ,iBAAiBA,CAAS,EAAA,EAEpC,MAAOyB,GAAY,CACjB,QAAQ,IAAI,oCAAqCA,CAAO,EACxD,KAAM,CAAE,UAAAxB,EAAW,IAAKyB,EAAW,IAAKC,GAAcF,EAEtD,GAAIxB,IAAc,SAAU,CAC1B,MAAMyE,EAAiBxC,EAA0BR,CAAS,EACpD,CAACiD,CAAmB,EAAI,MAAMvC,EAAoCpC,EAAW,CAAC0E,CAAc,CAAC,EACnGrC,EAAe,CAACsC,EAAqB,GAAGtC,EAAa,UAAYuC,EAAE,gBAAkBD,EAAoB,aAAa,CAAC,CACzH,SAAW1E,IAAc,SAAU,CACjC,MAAM4E,EAAqB3C,EAA0BR,CAAS,EACxD,CAACiD,CAAmB,EAAI,MAAMvC,EAAoCpC,EAAW,CAAC6E,CAAkB,CAAC,EACvGxC,EAAeA,EAAa,IAAIuC,GAAKA,EAAE,gBAAkBD,EAAoB,cAAgBA,EAAsBC,CAAC,CACtH,SAAW3E,IAAc,SAAU,CACjC,MAAM6B,EAAQH,EAAU,eACxBU,EAAeA,EAAa,OAAOuC,GAAKA,EAAE,gBAAkB9C,CAAK,CACnE,CAEA,MAAMkD,EAAqB,CAAC,GAAG3C,CAAY,EAAE,KAAK,CAAC4C,EAAGC,IAAM,IAAI,KAAKA,EAAE,SAAS,EAAE,UAAY,IAAI,KAAKD,EAAE,SAAS,EAAE,SAAS,EAC7H5D,EAAS2D,CAAkB,CAC7B,CAAA,EAED,UAAU,CAACjD,EAAQC,IAAQ,CACtBD,IAAW,cACb,QAAQ,IAAI,wCAAwC,EAElDC,GACF,QAAQ,MAAM,iDAAkDA,CAAG,CAEvE,CAAC,EAEH,MAAO,IAAM,CACXR,EAAQ,YAAA,CACV,CACF,EAGA,uBACExB,EACA8C,EACAxC,EACAe,EACA,CACA,MAAMG,EAAUhB,EACb,QAAQ,eAAeR,CAAS,IAAIM,CAAa,EAAE,EACnD,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,eACP,OAAQ,iBAAiBN,CAAS,0BAA0BM,CAAa,EAAA,EAE3E,SAAY,CAEV,GAAI,CACF,KAAM,CAAE,KAAAQ,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAIxB,EAAO,CACT,GAAIA,EAAM,OAAS,WAAY,CAE7BuC,EAAS,IAAI,EACb,MACF,CACA,QAAQ,MAAM,8CAA+CvC,CAAK,EAClE,MACF,CAEA,GAAIgC,EAAM,CACR,MAAM6B,EAAcT,EAA0BpB,CAAI,EAC5CqE,EAAW,MAAM/C,EAAoCpC,EAAW,CAAC2C,CAAW,CAAC,EACnFtB,EAAS8D,EAAS,CAAC,GAAK,IAAI,CAC9B,MACE9D,EAAS,IAAI,CAEjB,OAASvC,EAAO,CACd,QAAQ,MAAM,8CAA+CA,CAAK,CACpE,CACF,CAAA,EAED,UAAA,EAiCH,OA9ByB,SAAY,CACnC,GAAI,CACF,KAAM,CAAE,KAAAgC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAIxB,EAAO,CACT,GAAIA,EAAM,OAAS,WAAY,CAC7BuC,EAAS,IAAI,EACb,MACF,CACA,QAAQ,MAAM,sCAAuCvC,CAAK,EAC1D,MACF,CAEA,GAAIgC,EAAM,CACR,MAAM6B,EAAcT,EAA0BpB,CAAI,EAC5CqE,EAAW,MAAM/C,EAAoCpC,EAAW,CAAC2C,CAAW,CAAC,EACnFtB,EAAS8D,EAAS,CAAC,GAAK,IAAI,CAC9B,MACE9D,EAAS,IAAI,CAEjB,OAASvC,EAAO,CACd,QAAQ,MAAM,sCAAuCA,CAAK,CAC5D,CACF,GAEA,EAEO,IAAM,CACX0C,EAAQ,YAAA,CACV,CACF,EAGA,MAAM,uBAAuBxB,EAAmBG,EAA2C,CACzF,MAAMU,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAcG,CAAS,EAC1B,GAAG,SAAU,SAAS,EACtB,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAIrB,EAAO,MAAMA,EAEjB,MAAMuD,GAAgBvB,GAAQ,CAAA,GAAI,IAAIwB,GAAMJ,EAA0BI,CAAE,CAAC,EACzE,OAAO,MAAMF,EAAoCpC,EAAWqC,CAAY,CAC1E,EAGA,MAAM,wBACJrC,EACA8C,EACAxC,EACAyB,EACAZ,EACe,CACf,MAAMN,EAAA,EAEN,MAAMO,EAAkB,CACtB,OAAAW,EACA,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAGjCZ,IACEA,EAAQ,kBAAoB,SAAWC,EAAW,iBAAmBD,EAAQ,iBAC7EA,EAAQ,gBAAkB,SAAWC,EAAW,eAAiBD,EAAQ,eACzEA,EAAQ,SAAW,SAAWC,EAAW,OAASD,EAAQ,QAC1DA,EAAQ,QAAU,SAAWC,EAAW,MAAQD,EAAQ,QAK1DY,IAAW,aAAe,EAACZ,GAAA,MAAAA,EAAS,mBACtCC,EAAW,iBAAmB1B,EAAiB,IAAI,IAAM,GAG3D,KAAM,CAAE,MAAAZ,CAAA,EAAU,MAAM0B,EACrB,KAAK,cAAc,EACnB,OAAOY,CAAU,EACjB,GAAG,aAAcpB,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIxB,EAAO,MAAMA,CACnB,EAGA,MAAM,gCAAgCkB,EAA2C,CAC/E,MAAMa,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,qBAAsB,CAACoF,EAAqBC,CAAmB,CAAC,EACnE,MAAM,aAAc,CAAE,UAAW,EAAA,CAAO,EAE3C,GAAIvG,EAAO,MAAMA,EAEjB,MAAMuD,GAAgBvB,GAAQ,CAAA,GAAI,IAAIwB,GAAMJ,EAA0BI,CAAE,CAAC,EACzE,OAAO,MAAMF,EAAoCpC,EAAWqC,CAAY,CAC1E,EAGA,MAAM,iCAAiCrC,EAA2C,CAChF,MAAMa,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAc,IAAI,EACrB,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,GAAIlB,EAAO,MAAMA,EAEjB,MAAMuD,GAAgBvB,GAAQ,CAAA,GAAI,IAAIwB,GAAMJ,EAA0BI,CAAE,CAAC,EACzE,OAAO,MAAMF,EAAoCpC,EAAWqC,CAAY,CAC1E,CACF,EAGauB,EAAsB,CAEjC,mBAAmB0B,EAAmB,CACpC,MAAMtE,EAAYC,EAAkBqE,CAAM,EAC1C,MAAO,CACL,OAAQtE,EAAU,QAClB,UAAWA,EAAU,WACrB,UAAWA,EAAU,YAAc,OACnC,cAAeA,EAAU,gBAAkB,OAC3C,KAAMA,EAAU,MAAQ,OACxB,YAAaA,EAAU,aAAe,GACtC,IAAKA,EAAU,KAAO,GACtB,OAAQA,EAAU,QAAU,GAC5B,cAAeA,EAAU,gBAAkB,OAC3C,aAAcA,EAAU,eAAiB,OACzC,YAAaA,EAAU,cAAgB,OACvC,cAAeA,EAAU,gBAAkB,GAC3C,YAAaA,EAAU,aAAe,OACtC,MAAOA,EAAU,OAAS,OAC1B,MAAOA,EAAU,OAAS,OAC1B,MAAOA,EAAU,QAAU,GAC3B,SAAUA,EAAU,UAAY,GAChC,YAAaA,EAAU,cAAgB,GACvC,YAAaA,EAAU,aAAgB,OAAOA,EAAU,cAAiB,SAAWA,EAAU,aAAeA,EAAU,aAAa,YAAA,EAAiB,GACrJ,OAAQ,MAAM,QAAQA,EAAU,MAAM,EAAIA,EAAU,OAAS,CAAA,EAC7D,gBAAiBA,EAAU,kBAAoB,OAC/C,0BAA2BA,EAAU,6BAA+B,OACpE,WAAYA,EAAU,aAAe,WAAWA,EAAU,YAAY,EAAI,OAC1E,UAAWA,EAAU,YAAc,OACnC,UAAWA,EAAU,YAAc,OACnC,UAAWA,EAAU,UAAA,CAEzB,EAGA,iBAAiBoD,EAA0B,CACzC,MAAMkB,EAAc,CAAA,EAEpB,OAAIlB,EAAK,SAAW,SAAWkB,EAAO,QAAUlB,EAAK,QACjDA,EAAK,YAAc,SAAWkB,EAAO,WAAalB,EAAK,WACvDA,EAAK,YAAc,SAAWkB,EAAO,WAAalB,EAAK,WAAa,MACpEA,EAAK,gBAAkB,SAAWkB,EAAO,eAAiBlB,EAAK,eAAiB,MAChFA,EAAK,OAAS,SAAWkB,EAAO,KAAOlB,EAAK,MAC5CA,EAAK,cAAgB,SAAWkB,EAAO,YAAclB,EAAK,aAC1DA,EAAK,MAAQ,SAAWkB,EAAO,IAAMlB,EAAK,KAC1CA,EAAK,SAAW,SAAWkB,EAAO,OAASlB,EAAK,QAChDA,EAAK,gBAAkB,SAAWkB,EAAO,eAAiBlB,EAAK,eAC/DA,EAAK,eAAiB,SAAWkB,EAAO,cAAgBlB,EAAK,cAC7DA,EAAK,cAAgB,SAAWkB,EAAO,aAAelB,EAAK,aAC3DA,EAAK,gBAAkB,SAAWkB,EAAO,eAAiBlB,EAAK,eAC/DA,EAAK,cAAgB,SAAWkB,EAAO,YAAclB,EAAK,aAC1DA,EAAK,QAAU,SAAWkB,EAAO,MAAQlB,EAAK,OAC9CA,EAAK,QAAU,SAAWkB,EAAO,MAAQlB,EAAK,OAC9CA,EAAK,QAAU,SAAWkB,EAAO,OAASlB,EAAK,OAC/CA,EAAK,WAAa,SAAWkB,EAAO,SAAWlB,EAAK,UACpDA,EAAK,cAAgB,SAAWkB,EAAO,aAAelB,EAAK,aAC3DA,EAAK,cAAgB,SAAWkB,EAAO,aAAelB,EAAK,aAC3DA,EAAK,SAAW,SAAWkB,EAAO,OAASlB,EAAK,QAChDA,EAAK,kBAAoB,SAAWkB,EAAO,iBAAmBlB,EAAK,iBACnEA,EAAK,4BAA8B,SAAWkB,EAAO,4BAA8BlB,EAAK,2BACxFA,EAAK,aAAe,SAAWkB,EAAO,aAAelB,EAAK,YAC1DA,EAAK,YAAc,SAAWkB,EAAO,WAAalB,EAAK,WACvDA,EAAK,YAAc,SAAWkB,EAAO,WAAalB,EAAK,WACvDA,EAAK,YAAc,SAAWkB,EAAO,WAAalB,EAAK,WAEpDkB,CACT,EAGA,MAAM,kBACJtF,EACAG,EACAoF,EACAC,EACiB,CACjB,MAAM3E,EAAA,EAEN,IAAI4E,EAAQjF,EACT,KAAK,OAAO,EACZ,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAcG,CAAS,EAyB7B,GAtBIoF,GAAA,MAAAA,EAAS,SACXE,EAAQA,EAAM,GAAG,cAAeF,EAAQ,MAAM,GAG5CA,GAAA,MAAAA,EAAS,WACXE,EAAQA,EAAM,GAAG,SAAUF,EAAQ,QAAQ,GAGzCA,GAAA,MAAAA,EAAS,aACXE,EAAQA,EAAM,IAAI,gBAAiBF,EAAQ,WAAW,IAAI,UAAU,EACpEE,EAAQA,EAAM,IAAI,gBAAiBF,EAAQ,WAAW,IAAI,UAAU,GAIlEA,GAAA,MAAAA,EAAS,cACXE,EAAQA,EAAM,GAAG,sBAAsBF,EAAQ,WAAW,mBAAmBA,EAAQ,WAAW,gBAAgBA,EAAQ,WAAW,2BAA2BA,EAAQ,WAAW,GAAG,GAItLE,EAAQA,EAAM,MAAM,eAAgB,CAAE,UAAW,GAAO,EAGpDD,EAAY,CACd,MAAME,EAASF,EAAW,KAAO,GAAKA,EAAW,KAAO,GAAKA,EAAW,MAAQ,EAChFC,EAAQA,EAAM,MAAMC,EAAQA,EAASF,EAAW,MAAQ,CAAC,CAC3D,CAEA,KAAM,CAAE,KAAA1E,EAAM,MAAAhC,CAAA,EAAU,MAAM2G,EAE9B,GAAI3G,EAAO,MAAMA,EAEjB,OAAQgC,GAAQ,CAAA,GAAI,OAAY,KAAK,mBAAmBsD,CAAI,CAAC,CAC/D,EAGA,wBACEpE,EACAG,EACAkB,EACAsE,EACA,CACA,IAAI3C,EAAQ,CAAC,GAAI2C,GAAgB,EAAG,EAEpC,MAAMnE,EAAUhB,EACb,QAAQ,iBAAiBR,CAAS,IAAIG,CAAS,EAAE,EACjD,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,QAEP,OAAQ,iBAAiBH,CAAS,EAAA,EAEnCyB,GAAY,CACX,QAAQ,IAAI,gDAAiDA,CAAO,EACpE,KAAM,CAAE,UAAAxB,EAAW,IAAKyB,EAAW,IAAKC,GAAcF,EAEtD,GAAIxB,IAAc,SAEZyB,EAAU,aAAevB,IAE3B6C,EAAQ,CADQ,KAAK,mBAAmBtB,CAAS,EAC/B,GAAGsB,CAAK,WAEnB/C,IAAc,SAAU,CACjC,MAAM2F,EAAc,KAAK,mBAAmBlE,CAAS,EAC/CoD,EAAe9B,EAAM,QAAUU,EAAE,SAAWkC,EAAY,MAAM,EAC9Db,EAAca,EAAY,YAAczF,EAE1C4E,GAAe,CAACD,EAElB9B,EAAQ,CAAC4C,EAAa,GAAG5C,CAAK,EACrB,CAAC+B,GAAeD,EAEzB9B,EAAQA,EAAM,OAAOU,GAAKA,EAAE,SAAWkC,EAAY,MAAM,EAChDb,GAAeD,IAExB9B,EAAQA,EAAM,IAAIU,GAAKA,EAAE,SAAWkC,EAAY,OAASA,EAAclC,CAAC,EAI5E,SAAWzD,IAAc,SAAU,CACjC,MAAM6B,EAAQH,EAAU,QACxBqB,EAAQA,EAAM,OAAOU,GAAKA,EAAE,SAAW5B,CAAK,CAC9C,CAEAT,EAAS,CAAC,GAAG2B,CAAK,CAAC,CACrB,CAAA,EAED,UAAU,CAACjB,EAAQC,IAAQ,CACtBD,IAAW,cACb,QAAQ,IAAI,qCAAqC,EAE/CC,GACF,QAAQ,MAAM,8CAA+CA,CAAG,CAEpE,CAAC,EAEH,MAAO,IAAM,CACXR,EAAQ,YAAA,CACV,CACF,EAIA,MAAM,0BACJxB,EACAuF,EACAC,EACiB,CACjB,MAAM3E,EAAA,EAEN,IAAI4E,EAAQjF,EACT,KAAK,OAAO,EACZ,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,aAAc,IAAI,EAgBxB,GAbIuF,GAAA,MAAAA,EAAS,SACXE,EAAQA,EAAM,GAAG,mBAAoBF,EAAQ,MAAM,GAIjDA,GAAA,MAAAA,EAAS,cACXE,EAAQA,EAAM,GAAG,sBAAsBF,EAAQ,WAAW,mBAAmBA,EAAQ,WAAW,gBAAgBA,EAAQ,WAAW,wCAAwCA,EAAQ,WAAW,GAAG,GAInME,EAAQA,EAAM,MAAM,eAAgB,CAAE,UAAW,GAAO,EAGpDD,EAAY,CACd,MAAME,EAASF,EAAW,KAAO,GAAKA,EAAW,KAAO,GAAKA,EAAW,MAAQ,EAChFC,EAAQA,EAAM,MAAMC,EAAQA,EAASF,EAAW,MAAQ,CAAC,CAC3D,CAEA,KAAM,CAAE,KAAA1E,EAAM,MAAAhC,CAAA,EAAU,MAAM2G,EAE9B,GAAI3G,EAAO,MAAMA,EAEjB,OAAQgC,GAAQ,CAAA,GAAI,OAAY,KAAK,mBAAmBsD,CAAI,CAAC,CAC/D,EAEA,6BACEpE,EACAqB,EACAwE,EACAF,EACA,CACA,IAAI3C,EAAQ,CAAC,GAAI2C,GAAgB,EAAG,EAEpC,MAAMnE,EAAUhB,EACb,QAAQ,sBAAsBR,CAAS,EAAE,EACzC,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,QACP,OAAQ,iBAAiBA,CAAS,EAAA,EAEnCyB,GAAY,CACX,QAAQ,IAAI,sCAAuCA,CAAO,EAC1D,KAAM,CAAE,UAAAxB,EAAW,IAAKyB,EAAW,IAAKC,GAAcF,EAEtD,GAAIxB,IAAc,SAEXyB,EAAU,aAEbsB,EAAQ,CADQ,KAAK,mBAAmBtB,CAAS,EAC/B,GAAGsB,CAAK,WAEnB/C,IAAc,SAAU,CACjC,MAAM2F,EAAc,KAAK,mBAAmBlE,CAAS,EAEhDkE,EAAY,UAKf5C,EAAQA,EAAM,OAAOU,GAAKA,EAAE,SAAWkC,EAAY,MAAM,EAHzD5C,EAAQA,EAAM,IAAIU,GAAKA,EAAE,SAAWkC,EAAY,OAASA,EAAclC,CAAC,CAK5E,SAAWzD,IAAc,SAAU,CACjC,MAAM6B,EAAQH,EAAU,QACxBqB,EAAQA,EAAM,OAAOU,GAAKA,EAAE,SAAW5B,CAAK,CAC9C,CAEAT,EAAS,CAAC,GAAG2B,CAAK,CAAC,CACrB,CAAA,EAED,UAAU,CAACjB,EAAQC,IAAQ,CACtBD,IAAW,cACb,QAAQ,IAAI,0CAA0C,EAEpDC,GACF,QAAQ,MAAM,mDAAoDA,CAAG,CAEzE,CAAC,EAEH,MAAO,IAAM,CACXR,EAAQ,YAAA,CACV,CACF,EAGA,MAAM,WAAWxB,EAAmB8F,EAAiF,CACnH,MAAMjF,EAAA,EAEN,MAAMsC,MAAU,KAEVjD,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACnE6F,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAGnET,EAAS,KAAK,iBAAiB,CACnC,GAAGQ,EACH,OAAA5F,EACA,MAAO4F,EAAS,OAASC,CAAA,CAClB,EAGTT,EAAO,aAAe5F,EAAiByD,CAAG,EAC1CmC,EAAO,aAAenC,EAAI,YAAA,EAG1BmC,EAAO,WAAatF,EACpBsF,EAAO,WAAanC,EAAI,YAAA,EACnBmC,EAAO,eAAcA,EAAO,aAAe5F,EAAiByD,CAAG,GAC/DmC,EAAO,eAAcA,EAAO,aAAenC,EAAI,YAAA,GAC/CmC,EAAO,mBAAkBA,EAAO,iBAAmB,aAIxD,GAAI,CACF,GAAIA,EAAO,gBAAkBA,EAAO,eAAiB,KAAM,CACzD,KAAM,CAAE,KAAMU,GAAW,MAAMxF,EAC5B,KAAK,cAAc,EACnB,OAAO,cAAc,EACrB,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBsF,EAAO,cAAc,EAC1C,OAAA,EAECU,GAAUA,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OACzEV,EAAO,aAAeU,EAAO,aAEjC,CACF,OAAS9B,EAAG,CACV,QAAQ,KAAK,qDAAsDA,CAAC,CACtE,CAEA,KAAM,CAAE,MAAApF,GAAU,MAAM0B,EACrB,KAAK,OAAO,EACZ,OAAO8E,CAAM,EAEhB,GAAIxG,EAAO,MAAMA,EAEjB,OAAOoB,CACT,EAGA,MAAM,WAAWF,EAAmBE,EAAgBiB,EAAuC,CACzF,MAAMN,EAAA,EAGN,MAAMsD,EAAY,KAAK,iBAAiB,CACtC,GAAGhD,EACH,YAAa,IAAI,KAAA,EAAO,YAAA,CAAY,CACrC,EAID,GAAI,CACF,MAAM8E,EAAqB9E,EAAQ,gBAAkB,QAAaA,EAAQ,gBAAkB,KACtF+E,EAAa/E,EAAQ,aAAe,QAAaA,EAAQ,aAAe,KAC9E,GAAI8E,GAAsBC,EAAY,CACpC,MAAMC,EAAOhF,EAAQ,cACrB,GAAIgF,EAAM,CACR,KAAM,CAAE,KAAMH,CAAA,EAAW,MAAMxF,EAC5B,KAAK,cAAc,EACnB,OAAO,cAAc,EACrB,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBmG,CAAI,EACzB,OAAA,EAECH,GAAUA,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OACzE7B,EAAU,aAAe6B,EAAO,aAEpC,CACF,CACF,OAAS9B,EAAG,CACV,QAAQ,KAAK,qDAAsDA,CAAC,CACtE,CAEA,KAAM,CAAE,MAAApF,CAAA,EAAU,MAAM0B,EACrB,KAAK,OAAO,EACZ,OAAO2D,CAAS,EAChB,GAAG,aAAcnE,CAAS,EAC1B,GAAG,UAAWE,CAAM,EAEvB,GAAIpB,EAAO,MAAMA,CACnB,EAGA,MAAM,WAAWkB,EAAmBE,EAA+B,CACjE,MAAMW,EAAA,EAEN,KAAM,CAAE,MAAA/B,CAAA,EAAU,MAAM0B,EACrB,KAAK,OAAO,EACZ,OAAA,EACA,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAWE,CAAM,EAEvB,GAAIpB,EAAO,MAAMA,CACnB,EAGA,MAAM,uBAAuBkB,EAAmB8C,EAAoBxC,EAAwC,CAC1G,MAAMO,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,OAAO,EACZ,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,MAAM,eAAgB,CAAE,UAAW,GAAM,EAE5C,GAAIxB,EAAO,MAAMA,EAEjB,OAAQgC,GAAQ,CAAA,GAAI,OAAY,KAAK,mBAAmBsD,CAAI,CAAC,CAC/D,EAGA,MAAM,sBACJpE,EACAE,EACAC,EACAX,EACA4G,EACAC,EACiB,CACjB,MAAMxF,EAAA,EAGN,MAAMuD,EAAO,MAAM,KAAK,YAAYpE,EAAWE,CAAM,EACrD,GAAI,CAACkE,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMkC,EAAc9G,GAAU4E,EAAK,cAAgBA,EAAK,aAAe,OACjEmC,EAAsCnC,EAAK,eAAiB,KAElE,QAAQ,IAAI,kCAAmC,CAC7C,OAAAlE,EACA,UAAAC,EACA,qBAAAoG,EACA,cAAenC,EAAK,UACpB,YAAAkC,CAAA,CACD,EAGD,GAAI,CACF,MAAMvG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQkE,EAAK,WAAa,KAAMmC,GAAwB,KAAM,CAC3H,OAAQ,qBACR,kBAAmBpG,EACnB,uBAAwBoG,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,qCAAsCA,CAAU,CAC/D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,aACVA,EAAqB,QAAQ,YAAa,EAAE,IAE5CpG,GAEvB,QAAQ,IAAI,+EAA+E,EACpF,MAAM,KAAK,0BAA0BH,EAAWE,EAAQqG,EAAsBpG,EAAWmG,EAAaF,EAAOC,CAAK,IAGzH,QAAQ,IAAI,gEAAgE,EACrE,MAAM,KAAK,iCAAiCrG,EAAWE,EAAQqG,EAAsBpG,EAAWmG,EAAaF,EAAOC,CAAK,GAKhIE,GAAA,MAAAA,EAAsB,WAAW,iBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDpG,GAEvB,QAAQ,IAAI,+DAA+D,EACpE,MAAM,KAAK,8BAA8BH,EAAWE,EAAQqG,EAAsBpG,EAAWmG,EAAaF,EAAOC,CAAK,IAG7H,QAAQ,IAAI,oEAAoE,EACzE,MAAM,KAAK,qCAAqCrG,EAAWE,EAAQqG,EAAsBpG,EAAWmG,EAAaF,EAAOC,CAAK,GAUnIE,GAML,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,8BAA8BvG,EAAWE,EAAQC,EAAWmG,EAAaF,EAAOC,CAAK,IANrG,QAAQ,IAAI,yDAAyD,EAC9D,MAAM,KAAK,8BAA8BrG,EAAWE,EAAQC,EAAWmG,EAAaF,EAAOC,CAAK,EAM3G,EAGA,MAAM,yBACJrG,EACAE,EACAqG,EACApG,EACAmG,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBtG,CAAS,GAGvD,MAAM,KAAK,0BAA0BH,EAAWE,EAAQqG,EAAsBD,CAAW,EAGzF,MAAM,KAAK,qBAAqBtG,EAAWE,EAAQuG,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGhI,MAAM,KAAK,WAAWpG,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAesG,EACf,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,iDAAiD,EAG7D,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQC,EAAWsG,EAAuB,CACvG,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BACJzG,EACAE,EACAqG,EACAzD,EACAwD,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BrG,EAAWE,EAAQqG,EAAsBD,CAAW,EAMzF,MAAM,KAAK,WAAWtG,EAAWE,EAAQ,CACvC,UAAW4C,EACX,gBAAiB,YACjB,cAAe,KACf,YAAa,OACb,MAAOuD,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,kDAAkD,EAG9D,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQ4C,EAAY,KAAM,CACvF,OAAQ,uBACR,SAAU,MACV,iBAAkByD,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,gDAAiDA,CAAU,CAC1E,CAGA,OAAOD,CACT,EAGA,MAAM,iCACJvG,EACAE,EACAqG,EACAjC,EACAgC,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBnC,CAAY,GAG1D,MAAM,KAAK,0BAA0BtE,EAAWE,EAAQqG,EAAsBD,CAAW,EAGzF,MAAM,KAAK,qBAAqBtG,EAAWE,EAAQuG,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGhI,MAAM,KAAK,WAAWpG,EAAWE,EAAQ,CACvC,UAAWoE,EACX,gBAAiB,YACjB,cAAemC,EACf,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQoE,EAAcmC,EAAuB,CAC1G,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,8BACJzG,EACAE,EACAqG,EACAzD,EACAwD,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BrG,EAAWE,EAAQqG,EAAsBD,CAAW,EAGzF,MAAM,KAAK,WAAWtG,EAAWE,EAAQ,CACvC,UAAW,KACX,gBAAiB,YACjB,YAAa,YACb,MAAOwG,EACP,MAAOL,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,eAAgBE,EAAQ,KAAM,YAAa,CAC1F,OAAQ,yBACR,SAAU,MACV,iBAAkBqG,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,OAAOD,CACT,EAGA,MAAM,qCACJvG,EACAE,EACAqG,EACAjC,EACAgC,EACAF,EACAC,EACiB,CACjB,MAAMM,EAAoB,YAAYrC,CAAY,GAGlD,MAAM,KAAK,0BAA0BtE,EAAWE,EAAQqG,EAAsBD,CAAW,EAGzF,MAAM,KAAK,qBAAqBtG,EAAWE,EAAQyG,EAAmBL,EAAa,eAAgB,iBAAkBF,CAAK,EAG1H,MAAM,KAAK,WAAWpG,EAAWE,EAAQ,CACvC,UAAW,KACX,gBAAiB,YACjB,cAAeyG,EACf,YAAa,YACb,MAAON,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQ,KAAMyG,EAAmB,CAC9F,OAAQ,uBACR,SAAU,MACV,iBAAkBJ,EAClB,eAAgBI,EAChB,OAAQL,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOG,CACT,EAGA,MAAM,8BACJ3G,EACAE,EACAC,EACAmG,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBtG,CAAS,GAGvD,MAAM,KAAK,qBAAqBH,EAAWE,EAAQuG,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGhI,MAAM,KAAK,WAAWpG,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAesG,EACf,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtG,EAAa,mBAAmBC,EAAW,aAAcE,EAAQC,EAAWsG,EAAuB,CACvG,OAAQ,uBACR,SAAU,IACV,YAAa,YACb,eAAgBA,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BAA0BzG,EAAmBE,EAAgBI,EAAuBsG,EAAoC,CAC5H,MAAM/F,EAAA,EAGN,KAAM,CAAE,KAAMkC,EAAiB,MAAO8D,GAAe,MAAMrG,EACxD,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAIuG,GAAc,CAAC9D,EAAiB,CAClC,QAAQ,KAAK,wCAAyCzC,CAAa,EACnE,MACF,CAGA,MAAMwG,GADkB/D,EAAgB,UAAY,CAAA,GACb,OAAQR,GAAeA,IAAOrC,CAAM,EAE3E,GAAI4G,EAAe,SAAW,EAE5B,GAAI,CACF,KAAM,CAAE,MAAOC,CAAA,EAAgB,MAAMvG,EAClC,KAAK,cAAc,EACnB,OAAA,EACA,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIyG,EAAa,MAAMA,EAEvB,QAAQ,IAAI,iCAAkCzG,CAAa,EAG3D,GAAI,CACF,MAAMP,EAAa,0BAA0BC,EAAWM,EAAe,UAAWyC,EAAiB,IAAI,CACzG,OAASyD,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAAS1H,EAAO,CACd,QAAQ,MAAM,wCAAyCwB,EAAexB,CAAK,CAE7E,KAGA,IAAI,CAEF,KAAM,CAAE,KAAMkI,EAAW,MAAOC,GAAe,MAAMzG,EAClD,KAAK,OAAO,EACZ,OAAO,6BAA6B,EACpC,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAW8G,CAAc,EAE/B,GAAIG,EAAY,MAAMA,EAEtB,MAAMC,GAAeF,GAAa,CAAA,GAC/B,OAAY5C,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAC7D,OAAO,CAAC+C,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD9F,EAAa,CACjB,SAAU0F,EACV,OAAQO,EACR,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAG/B,CAAE,MAAOC,CAAA,EAAgB,MAAM9G,EAClC,KAAK,cAAc,EACnB,OAAOY,CAAU,EACjB,GAAG,aAAcpB,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIgH,EAAa,MAAMA,EAEvB,QAAQ,IAAI,wCAAyChH,EAAe,cAAe+G,CAAU,EAG7F,GAAI,CACF,MAAMtH,EAAa,0BAA0BC,EAAWM,EAAe,UAAWyC,EAAiB3B,CAAU,CAC/G,OAASoF,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CACF,OAAS1H,EAAO,CACd,QAAQ,MAAM,gDAAiDwB,EAAexB,CAAK,CAErF,CAEJ,EAGA,MAAM,qBACJkB,EACAE,EACAI,EACAd,EACA+H,EACAC,EACApB,EACe,CACf,MAAMvF,EAAA,EAGN,KAAM,CAAE,KAAM4G,EAAqB,MAAOZ,GAAe,MAAMrG,EAC5D,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEH,GAAImH,GAAuB,CAACZ,EAE1B,GAAI,CACF,MAAMa,EAAkBD,EAAoB,UAAY,CAAA,EAClDX,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGY,EAAiBxH,CAAM,CAAC,CAAC,EAG1D,CAAE,KAAM8G,EAAW,MAAOC,GAAe,MAAMzG,EAClD,KAAK,OAAO,EACZ,OAAO,6BAA6B,EACpC,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAW8G,CAAc,EAE/B,GAAIG,EAAY,MAAMA,EAEtB,MAAMC,GAAeF,GAAa,CAAA,GAC/B,OAAY5C,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAC7D,OAAO,CAAC+C,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD9F,EAAa,CACjB,SAAU0F,EACV,OAAQO,EACR,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAG/B,CAAE,MAAOC,CAAA,EAAgB,MAAM9G,EAClC,KAAK,cAAc,EACnB,OAAOY,CAAU,EACjB,GAAG,aAAcpB,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAErC,GAAIgH,EAAa,MAAMA,EAEvB,QAAQ,IAAI,yCAA0ChH,EAAe,cAAe+G,CAAU,EAG9F,GAAI,CACF,MAAMtH,EAAa,0BAA0BC,EAAWM,EAAe,UAAWmH,EAAqBrG,CAAU,CACnH,OAASoF,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CAGA,GAAI,CACF,MAAMmB,EAAQF,EAAoB,aACPE,GAAU,MACnC,MAAM,KAAK,WAAW3H,EAAWE,EAAQ,CACvC,aAAcyH,CAAA,CACf,CAEL,OAASzD,EAAG,CACV,QAAQ,KAAK,4CAA6ChE,EAAQgE,CAAC,CACrE,CACF,OAASpF,EAAO,CACd,QAAQ,MAAM,2CAA4CwB,EAAexB,CAAK,CAEhF,KAGA,IAAI,CAEF,MAAMmE,EAAc,MAAMC,EAAA,EAC1B,GAAI,EAACD,GAAA,MAAAA,EAAa,IAChB,MAAM,IAAI,MAAM,mDAAmD,EAGrE,MAAM9C,EAAYG,EAAc,QAAQiH,IAAoB,WAAa,gBAAkB,YAAa,EAAE,EACpGxG,EAAU,MAAMH,EAAe,WAAWZ,EAAWG,CAAS,EAC9DsC,GAAc1B,GAAA,YAAAA,EAAS,OAAQ,QAE/BoC,MAAU,KACVJ,EAAkB,CACtB,WAAY/C,EACZ,eAAgBM,EAChB,WAAYH,EACZ,iBAAkBT,EAAiByD,CAAG,EACtC,OAAQoE,IAAoB,WAAa,YAAc9E,EACvD,iBAAkB8E,EAClB,eAAgB,UAChB,OAAA/H,EACA,gBAAiB,cACjB,MAAO4G,GAAS,yBAAyBmB,IAAoB,WAAa,iBAAmB,SAAS,IAAIA,IAAoB,WAAa,YAAc,SAAS,GAClK,OAAQ,UACR,mBAAoBA,IAAoB,WAAanC,EAAsBC,EAC3E,cAAemC,EACf,SAAU,CAACtH,CAAM,EACjB,WAAY+C,EAAY,GACxB,WAAYE,EAAI,YAAA,EAChB,WAAYA,EAAI,YAAA,CAAY,EAGxB,CAAE,MAAOyE,CAAA,EAAgB,MAAMpH,EAClC,KAAK,cAAc,EACnB,OAAOuC,CAAe,EAEzB,GAAI6E,EAAa,MAAMA,EAEvB,QAAQ,IAAI,8BAA+BtH,EAAe,UAAWd,CAAM,EAG3E,GAAI,CACF,MAAMO,EAAa,0BAA0BC,EAAWM,EAAe,UAAW,KAAMyC,CAAe,CACzG,OAASyD,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAAS1H,EAAO,CACd,QAAQ,MAAM,sCAAuCwB,EAAexB,CAAK,CAE3E,CAEJ,EAGA,MAAM,4BACJkB,EACA6H,EACA1H,EACA2H,EAII,CAAA,EACa,CACjB,MAAMjH,EAAA,EAIN,KAAM,CAAE,KAAMmG,EAAW,MAAOC,GAAe,MAAMzG,EAClD,KAAK,OAAO,EACZ,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAW6H,CAAO,EAExB,GAAIZ,GAAc,CAACD,GAAaA,EAAU,SAAW,EACnD,MAAM,IAAI,MAAM,+BAA+B,EAGjD,MAAMe,EAAyB,gBAAgB5H,CAAS,GAGxD,UAAW2F,KAAYkB,EAAW,CAChC,MAAM9G,EAAS4F,EAAS,QAClBQ,EAAcwB,EAAe,QAAUhC,EAAS,eAAiBA,EAAS,cAAgB,OAC1FS,EAAsCT,EAAS,gBAAkB,KAGvE,GAAIS,GAAA,MAAAA,EAAsB,WAAW,aAGnC,GAFsBA,EAAqB,QAAQ,YAAa,EAAE,IAE5CpG,EAAW,CAG/B,QAAQ,IAAI,8FAA+FD,CAAM,EACjH,MAAM,KAAK,0BAA0BF,EAAWE,EAAQqG,EAAsBD,CAAW,EACzF,MAAM,KAAK,WAAWtG,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAe,KACf,YAAa,OACb,MAAO2H,EAAe,MACtB,MAAOA,EAAe,OAAS,EAAA,CAChC,EACD,QACF,KAAO,CAEL,QAAQ,IAAI,2FAA4F5H,CAAM,EAC9G,MAAM,KAAK,0BAA0BF,EAAWE,EAAQqG,EAAsBD,CAAW,EACzF,MAAM,KAAK,qBAAqBtG,EAAWE,EAAQ6H,EAAwBzB,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EAChJ,MAAM,KAAK,WAAW9H,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAe4H,EACf,YAAa,OACb,MAAOD,EAAe,OAAS,EAAA,CAChC,EACD,QACF,CAIF,GAAI,CAACvB,EAAsB,CACzB,QAAQ,IAAI,qDAAsDrG,CAAM,EACxE,MAAM,KAAK,qBAAqBF,EAAWE,EAAQ6H,EAAwBzB,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EAChJ,MAAM,KAAK,WAAW9H,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAe4H,EACf,YAAa,OACb,MAAOD,EAAe,OAAS,EAAA,CAChC,EACD,QACF,CAGA,QAAQ,IAAI,oEAAqE5H,EAAQqG,CAAoB,EAC7G,MAAM,KAAK,qBAAqBvG,EAAWE,EAAQ6H,EAAwBzB,EAAa,WAAY,uBAAwBwB,EAAe,KAAK,EAChJ,MAAM,KAAK,WAAW9H,EAAWE,EAAQ,CACvC,UAAAC,EACA,gBAAiB,YACjB,cAAe4H,EACf,YAAa,OACb,MAAOD,EAAe,OAAS,EAAA,CAChC,CACH,CAEA,OAAOC,CACT,EAGA,MAAM,sBACJ/H,EACAE,EACAC,EACAX,EACA4G,EACiB,CACjB,MAAMvF,EAAA,EAGN,MAAMuD,EAAO,MAAM,KAAK,YAAYpE,EAAWE,CAAM,EACrD,GAAI,CAACkE,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMkC,EAAc9G,GAAU4E,EAAK,cAAgBA,EAAK,aAAe,OACjEmC,EAAsCnC,EAAK,eAAiB,KAElE,QAAQ,IAAI,8BAA+B,CACzC,OAAAlE,EACA,UAAAC,EACA,qBAAAoG,EACA,cAAenC,EAAK,UACpB,YAAAkC,CAAA,CACD,EAGD,GAAI,CACF,MAAMvG,EAAa,mBAAmBC,EAAW,SAAUE,EAAQkE,EAAK,WAAa,KAAMmC,GAAwB,KAAM,CACvH,OAAQ,iBACR,kBAAmBpG,EACnB,uBAAwBoG,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,iCAAkCA,CAAU,CAC3D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,kBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDpG,GAEvB,QAAQ,IAAI,mEAAmE,EACxE,MAAM,KAAK,yBAAyBH,EAAWE,EAAQqG,EAAsBpG,EAAWmG,EAAaF,CAAK,IAKrH,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,gBAAgBpG,EAAWE,EAAQC,EAAWmG,EAAaF,CAAK,EACpF,EAGA,MAAM,yBACJpG,EACAE,EACAqG,EACAzD,EACAwD,EACAF,EACiB,CAMjB,MAAM,KAAK,0BAA0BpG,EAAWE,EAAQqG,EAAsBD,CAAW,EAGzF,MAAM,KAAK,WAAWtG,EAAWE,EAAQ,CACvC,UAAW,KACX,gBAAiB,YACjB,cAAe,KACf,YAAa,YACb,MAAAkG,CAAA,CACD,EAED,QAAQ,IAAI,yDAAyD,EAGrE,GAAI,CACF,MAAMrG,EAAa,mBAAmBC,EAAW,SAAUE,EAAQ,KAAMqG,EAAsB,CAC7F,OAAQ,mBACR,SAAU,uBACV,iBAAkBA,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAGA,OAAOD,CACT,EAGA,MAAM,gBACJvG,EACAE,EACAC,EACAmG,EACAF,EACiB,CACjB,MAAMvF,EAAA,EAGN,MAAMoC,EAAc,MAAMC,EAAA,EAC1B,GAAI,EAACD,GAAA,MAAAA,EAAa,IAChB,MAAM,IAAI,MAAM,mDAAmD,EAIrE,IAAIR,EAAc,QAClB,GAAI,CACF,MAAM1B,EAAU,MAAMH,EAAe,WAAWZ,EAAWG,CAAS,EACpEsC,GAAc1B,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAASjC,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAGA,MAAM6H,EAAoB,YAAYxG,CAAS,GAGzC,CAAE,KAAMsH,EAAqB,MAAOZ,GAAe,MAAMrG,EAC5D,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkB2G,CAAiB,EACtC,OAAA,EAEGxD,MAAU,KAEhB,GAAIsE,GAAuB,CAACZ,EAAY,CAEtC,QAAQ,IAAI,gEAAgE,EAC5E,MAAMa,EAAkBD,EAAoB,UAAY,CAAA,EAClDX,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGY,EAAiBxH,CAAM,CAAC,CAAC,EAG1D,CAAE,KAAM8G,EAAW,MAAOC,GAAe,MAAMzG,EAClD,KAAK,OAAO,EACZ,OAAO,6BAA6B,EACpC,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAW8G,CAAc,EAE/B,GAAIG,EAAY,MAAMA,EAEtB,MAAMC,GAAeF,GAAa,CAAA,GAC/B,OAAY5C,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAC7D,OAAO,CAAC+C,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENY,EAAyB,CAC7B,SAAUlB,EACV,OAAQI,EACR,MAAOd,GAAS,+EAChB,WAAYjD,EAAI,YAAA,CAAY,EAGxB,CAAE,MAAOmE,CAAA,EAAgB,MAAM9G,EAClC,KAAK,cAAc,EACnB,OAAOwH,CAAsB,EAC7B,GAAG,aAAchI,CAAS,EAC1B,GAAG,iBAAkB2G,CAAiB,EAEzC,GAAIW,EAAa,MAAMA,EAEvB,QAAQ,IAAI,uCAAwCR,EAAe,OAAQ,iBAAkBI,CAAW,CAC1G,KAAO,CAEL,MAAMnE,EAAkB,CACtB,WAAY/C,EACZ,eAAgB2G,EAChB,WAAYxG,EACZ,iBAAkBT,EAAiByD,CAAG,EACtC,OAAQV,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQ6D,EACR,gBAAiB,cACjB,MAAOF,GAAS,+EAChB,OAAQ,UACR,mBAAoBf,EACpB,cAAe,iBACf,SAAU,CAACnF,CAAM,EACjB,WAAY+C,EAAY,GACxB,WAAYE,EAAI,YAAA,EAChB,WAAYA,EAAI,YAAA,CAAY,EAG9B,QAAQ,IAAI,oDAAqDJ,EAAgB,MAAM,EAGvF,KAAM,CAAE,MAAO6E,CAAA,EAAgB,MAAMpH,EAClC,KAAK,cAAc,EACnB,OAAOuC,CAAe,EAEzB,GAAI6E,EAAa,MAAMA,CACzB,CAGA,MAAM,KAAK,WAAW5H,EAAWE,EAAQ,CACvC,UAAW,KACX,gBAAiB,YACjB,cAAeyG,EACf,YAAa,WAAA,CACd,EAED,QAAQ,IAAI,0CAA0C,EAGtD,GAAI,CACF,MAAM5G,EAAa,mBAAmBC,EAAW,SAAUE,EAAQ,KAAMyG,EAAmB,CAC1F,OAAQ,mBACR,SAAU,aACV,YAAa,YACb,eAAgBA,EAChB,OAAQL,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAEA,OAAOG,CACT,EAGA,MAAM,2BACJ3G,EACAuH,EACApH,EACA8H,EACe,CACf,MAAMpH,EAAA,EAGN,MAAMkH,EAAyBR,IAAoB,OAC/C,YAAYpH,CAAS,GACrB,gBAAgBA,CAAS,GAGvB,CAAE,KAAM4C,EAAiB,MAAO8D,GAAe,MAAMrG,EACxD,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkB+H,CAAsB,EAC3C,OAAA,EAEH,GAAIlB,GAAc,CAAC9D,EACjB,MAAM,IAAI,MAAM,uBAAuB,EAGzC,MAAM8E,EAAU9E,EAAgB,UAAY,CAAA,EAGtCI,MAAU,KACV,CAAE,MAAOmE,GAAgB,MAAM9G,EAClC,KAAK,cAAc,EACnB,OAAO,CACN,OAAQ,YACR,eAAgByH,EAChB,iBAAkBvI,EAAiByD,CAAG,EACtC,WAAYA,EAAI,YAAA,CAAY,CAC7B,EACA,GAAG,aAAcnD,CAAS,EAC1B,GAAG,iBAAkB+H,CAAsB,EAE9C,GAAIT,EAAa,MAAMA,EAGvB,UAAWpH,KAAU2H,EACfN,IAAoB,OAEtB,MAAM,KAAK,WAAWvH,EAAWE,EAAQ,CACvC,cAAe,KACf,gBAAiB,MAAA,CAClB,EAGD,MAAM,KAAK,WAAWF,EAAWE,EAAQ,CACvC,UAAW,KACX,cAAe,KACf,gBAAiB,WAAA,CAClB,CAGP,EAGA,MAAM,YAAYF,EAAmBE,EAAsC,CACzE,MAAMW,EAAA,EAEN,KAAM,CAAE,KAAAC,EAAM,MAAAhC,CAAA,EAAU,MAAM0B,EAC3B,KAAK,OAAO,EACZ,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAWE,CAAM,EACpB,OAAA,EAEH,GAAIpB,EAAO,CACT,GAAIA,EAAM,OAAS,WACjB,OAAO,KAET,MAAMA,CACR,CAEA,OAAKgC,EAEE,KAAK,mBAAmBA,CAAI,EAFjB,IAGpB,EAGA,MAAM,cAAcd,EAAmBG,EAAmB+H,EAAyC,CACjG,MAAMrH,EAAA,EAGN,MAAMsH,EAAe,MAAM,KAAK,YAAYnI,EAAWkI,CAAc,EACrE,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,MAAMhF,MAAU,KACViF,EAAY,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACtEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAGtEC,EAAsB,CAC1B,WAAYtI,EACZ,QAASoI,EACT,YAAaD,EAAa,aAAe,GACzC,OAAQA,EAAa,QAAU,GAC/B,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,eAAiB,KAC9C,cAAeA,EAAa,cAAgB,KAC5C,aAAcA,EAAa,aAAe,KAC1C,eAAgBA,EAAa,eAAiB,GAC9C,YAAa,OACb,MAAOA,EAAa,OAAS,KAC7B,MAAOA,EAAa,OAAS,KAC7B,OAAQE,EACR,SAAU,GACV,eAAgBF,EAAa,eAAiB,KAC9C,WAAYhI,EACZ,iBAAkBgI,EAAa,iBAAmB,YAClD,4BAA6BA,EAAa,2BAA6B,KACvE,aAAcA,EAAa,aAAezI,EAAiByD,CAAG,EAC9D,aAAcA,EAAI,YAAA,EAClB,OAAQgF,EAAa,QAAU,CAAA,EAC/B,aAAcA,EAAa,YAAc,KACzC,WAAYA,EAAa,WAAa,KACtC,WAAYA,EAAa,WAAa,KACtC,WAAYhF,EAAI,YAAA,CAAY,EAI9B,OAAO,KAAKmF,CAAc,EAAE,QAAQC,GAAO,CACrCD,EAAeC,CAAG,IAAM,QAC1B,OAAOD,EAAeC,CAAG,CAE7B,CAAC,EAGD,KAAM,CAAE,MAAAzJ,GAAU,MAAM0B,EACrB,KAAK,OAAO,EACZ,OAAO8H,CAAc,EAExB,GAAIxJ,EAAO,MAAMA,EAEjB,OAAOsJ,CACT,EAGA,MAAM,uBACJpI,EACAG,EACAG,EACAkI,EACAC,EACAzF,EACA0F,EACmB,CACnB,MAAM7H,EAAA,EAEN,MAAM8C,EAA2B,CAAA,EAC3BR,MAAU,KAGhB,IAAIwF,EACJ,GAAI,CACF,GAAiCD,GAAe,MAASpI,EAAe,CACtE,KAAM,CAAE,KAAM0F,EAAQ,MAAO4C,GAAY,MAAMpI,EAC5C,KAAK,cAAc,EACnB,OAAO,cAAc,EACrB,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkBM,CAAa,EAClC,OAAA,EAEC,CAACsI,GAAW5C,GAAUA,EAAO,eAAiB,QAAaA,EAAO,eAAiB,OACrF2C,EAAe3C,EAAO,aAE1B,CACF,MAAY,CAEZ,CAGA,MAAM6C,EAAuB,CAAA,EAE7B,UAAW/C,KAAY9C,EAAO,CAC5B,MAAM9C,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACzEyD,EAAe,KAAKzD,CAAM,EAE1B,MAAM6F,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEnE3B,EAAY,CAChB,WAAYpE,EACZ,QAASE,EACT,YAAa4F,EAAS,aAAe,GACrC,OAAQ2C,EACR,IAAK3C,EAAS,KAAO,GACrB,eAAgBA,EAAS,eAAiB,KAC1C,cAAeA,EAAS,cAAgB,KACxC,aAAcA,EAAS,aAAe,KACtC,eAAgB,cAChB,YAAa,OACb,MAAOA,EAAS,OAAS,KACzB,OAAQC,EACR,SAAU,GACV,eAAgBzF,EAChB,WAAYH,EACZ,iBAAkB,YAClB,aAAcqI,EACd,aAAcrF,EAAI,YAAA,EAClB,OAAQ,CAAA,EACR,WAAYA,EAAI,YAAA,CAAY,EAIEuF,GAAe,KAC7CtE,EAAK,aAAesE,EACXC,IAAiB,SAC1BvE,EAAK,aAAeuE,GAGtBE,EAAc,KAAKzE,CAAI,CACzB,CAGA,GAAIyE,EAAc,OAAS,EAAG,CAC5B,KAAM,CAAE,MAAA/J,GAAU,MAAM0B,EACrB,KAAK,OAAO,EACZ,OAAOqI,CAAa,EAEvB,GAAI/J,EAAO,MAAMA,CACnB,CAEA,OAAO6E,CACT,CACF,EAGamF,EAAsB,CAEjC,MAAM,2BACJ9I,EACAE,EACAC,EACA4I,EACe,CAGf,GAFA,QAAQ,IAAI,wCAAyC,CAAE,OAAA7I,EAAQ,UAAAC,EAAW,YAAA4I,EAAa,EAEnFA,IAAgB,YAAa,CAC/B,QAAQ,IAAI,8CAA+CA,CAAW,EACtE,MACF,CAEA,GAAI,CACF,QAAQ,IAAI,+BAAgC7I,CAAM,EAElD,MAAMkE,EAAO,MAAMR,EAAoB,YAAY5D,EAAWE,CAAM,EACpE,GAAI,CAACkE,EACH,MAAM,IAAI,MAAM,gBAAgB,EASlC,GAPA,QAAQ,IAAI,gBAAiBA,EAAK,OAAQ,eAAgBA,EAAK,YAAa,aAAcA,EAAK,SAAS,EAOpGA,EAAK,eAAiBA,EAAK,cAAc,WAAW,eAAe,GAC3CA,EAAK,cAAc,QAAQ,gBAAiB,EAAE,IAC9CjE,EAAW,CACnC,QAAQ,IAAI,uFAAuF,EAGnG,MAAMyD,EAAoB,0BAA0B5D,EAAWoE,EAAK,OAAQA,EAAK,cAAeA,EAAK,cAAgBA,EAAK,aAAe,MAAM,EAG/I,MAAMR,EAAoB,WAAW5D,EAAWoE,EAAK,OAAQ,CAC3D,UAAW,KACX,gBAAiB,YACjB,cAAe,KACf,YAAa,IAAI,KAAA,EAAO,YAAA,CAAY,CACrC,EAED,GAAI,CACF,MAAMrE,EAAa,mBAAmBC,EAAW,eAAgBE,EAAQ,KAAMkE,EAAK,cAAe,CACjG,OAAQ,yBACR,SAAU,qBACV,iBAAkBA,EAAK,cACvB,UAAW,YACX,OAAQA,EAAK,cAAgBA,EAAK,aAAe,MAAA,CAClD,CACH,OAASoC,EAAY,CACnB,QAAQ,KAAK,mEAAoEA,CAAU,CAC7F,CAEA,QAAQ,IAAI,oFAAoF,EAChG,MACF,CAIF,QAAQ,IAAI,iEAAiE,EAG7E,GAAI,CACF,MAAMzG,EAAa,mBAAmBC,EAAW,eAAgBE,EAAQkE,EAAK,WAAa,KAAMA,EAAK,eAAiB,KAAM,CAC3H,OAAQ,uBACR,cAAe,YACf,uBAAwBA,EAAK,aAAA,CAC9B,CACH,OAASoC,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CAEA,MAAMlG,EAAgB,MAAM,KAAK,sBAC/BN,EACAoE,EACAjE,EACA,8EAAA,EAGF,QAAQ,IAAI,yCAAyC,EAErD,MAAMyD,EAAoB,WAAW5D,EAAWoE,EAAK,OAAQ,CAC3D,UAAW,KACX,gBAAiB,YACjB,cAAA9D,EACA,MAAO,GACP,YAAa,IAAI,KAAA,EAAO,YAAA,CAAY,CACrC,EAGD,GAAI,CACF,MAAMP,EAAa,mBAAmBC,EAAW,eAAgBE,EAAQ,KAAMI,EAAe,CAC5F,OAAQ,yBACR,gBAAiB8D,EAAK,UACtB,eAAgB9D,EAChB,OAAQ8D,EAAK,cAAgBA,EAAK,aAAe,MAAA,CAClD,CACH,OAASoC,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,QAAQ,IAAI,iDAAiD,EAE7D,QAAQ,IAAI,uCAAuC,CACrD,OAAS1H,EAAO,CACd,cAAQ,MAAM,0CAA2CA,CAAK,EACxDA,CACR,CACF,EAGA,MAAM,sBACJkB,EACAoE,EACAjE,EACA6I,EACwB,CACxB,MAAMnI,EAAA,EAGN,MAAMoC,EAAc,MAAMC,EAAA,EAC1B,GAAI,EAACD,GAAA,MAAAA,EAAa,IAChB,MAAM,IAAI,MAAM,mDAAmD,EAGrE,QAAQ,IAAI,kDAAmDmB,EAAK,MAAM,EAG1E,IAAI3B,EAAc,QAClB,GAAI,CACF,MAAM1B,EAAU,MAAMH,EAAe,WAAWZ,EAAWG,CAAS,EACpEsC,GAAc1B,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAASjC,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAIA,GAAIsF,EAAK,eAAiBA,EAAK,cAAc,WAAW,eAAe,GAC3CA,EAAK,cAAc,QAAQ,gBAAiB,EAAE,IAC9CjE,EACxB,eAAQ,IAAI,sIAAsI,EAGlJ,MAAMyD,EAAoB,0BAA0B5D,EAAWoE,EAAK,OAAQA,EAAK,cAAeA,EAAK,cAAgBA,EAAK,aAAe,MAAM,EAC/I,MAAMR,EAAoB,WAAW5D,EAAWoE,EAAK,OAAQ,CAC3D,UAAW,KACX,gBAAiB,YACjB,cAAe,IAAA,CAChB,EAGM,KAIX,MAAM2D,EAAyB,YAAY5H,CAAS,GACpD,QAAQ,IAAI,+BAAgC4H,CAAsB,EAGlE,KAAM,CAAE,KAAMN,EAAqB,MAAOZ,GAAe,MAAMrG,EAC5D,KAAK,cAAc,EACnB,OAAO,GAAG,EACV,GAAG,aAAcR,CAAS,EAC1B,GAAG,iBAAkB+H,CAAsB,EAC3C,OAAA,EAEH,GAAIN,GAAuB,CAACZ,EAAY,CAEtC,QAAQ,IAAI,gEAAgE,EAC5E,MAAMa,EAAkBD,EAAoB,UAAY,CAAA,EAClDX,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGY,EAAiBtD,EAAK,MAAM,CAAC,CAAC,EAG/D,CAAE,KAAM4C,EAAW,MAAOC,GAAe,MAAMzG,EAClD,KAAK,OAAO,EACZ,OAAO,6BAA6B,EACpC,GAAG,aAAcR,CAAS,EAC1B,GAAG,UAAW8G,CAAc,EAE/B,GAAIG,EAAY,MAAMA,EAEtB,MAAMC,GAAeF,GAAa,CAAA,GAC/B,IAAI5C,GAAQA,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAC7D,OAAO,CAAC+C,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAGNY,EAAyB,CAC7B,SAAUlB,EACV,OAAQI,EACR,MAAO8B,GAAmB,+EAC1B,eALc,KAAA,EAKE,YAAA,CAAY,EAGxB,CAAE,MAAO1B,CAAA,EAAgB,MAAM9G,EAClC,KAAK,cAAc,EACnB,OAAOwH,CAAsB,EAC7B,GAAG,aAAchI,CAAS,EAC1B,GAAG,iBAAkB+H,CAAsB,EAE9C,GAAIT,EAAa,MAAMA,EAEvB,QAAQ,IAAI,uCAAwCR,EAAe,OAAQ,iBAAkBI,CAAW,CAC1G,KAAO,CAEL,MAAM+B,EAAmB7E,EAAK,cAAgBA,EAAK,aAAe,OAG5DjB,MAAU,KACVJ,EAAkB,CACtB,WAAY/C,EACZ,eAAgB+H,EAChB,WAAY5H,EACZ,iBAAkBT,EAAiByD,CAAG,EACtC,OAAQV,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQ,WAAWwG,CAAuB,EAAE,QAAQ,CAAC,EACrD,gBAAiB,cACjB,MAAOD,GAAmB,+EAC1B,OAAQ,UACR,mBAAoB3D,EACpB,cAAe,iBACf,SAAU,CAACjB,EAAK,MAAM,EACtB,WAAYnB,EAAY,GACxB,WAAYE,EAAI,YAAA,EAChB,WAAYA,EAAI,YAAA,CAAY,EAG9B,QAAQ,IAAI,oDAAqDJ,EAAgB,MAAM,EAGvF,KAAM,CAAE,MAAO6E,CAAA,EAAgB,MAAMpH,EAClC,KAAK,cAAc,EACnB,OAAOuC,CAAe,EAEzB,GAAI6E,EAAa,MAAMA,CACzB,CAEA,eAAQ,IAAI,iDAAiD,EACtDG,CACT,CACF,EAGamB,EAAqB,CAEhC,MAAM,mCACJlJ,EACAE,EACAC,EACAX,EACA4G,EACiB,CACjB,OAAO,MAAMxC,EAAoB,sBAAsB5D,EAAWE,EAAQC,EAAWX,EAAQ4G,CAAK,CACpG,EAGA,MAAM,8BACJpG,EACAE,EACAiJ,EACAhJ,EACe,CAEf,MAAMyD,EAAoB,sBAAsB5D,EAAWE,EAAQC,CAAS,CAC9E,EAGA,MAAM,2BACJH,EACAoJ,EACAD,EACAhJ,EACA8H,EACe,CAEf,OAAO,MAAMrE,EAAoB,2BAA2B5D,EAAW,OAAQG,EAAW8H,CAAa,CACzG,EAGA,MAAM,uBACJjI,EACAE,EACAC,EACA4I,EACe,CACf,OAAO,MAAMD,EAAoB,2BAA2B9I,EAAWE,EAAQC,EAAW4I,CAAW,CACvG,CACF"}