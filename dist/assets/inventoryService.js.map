{"version":3,"file":"inventoryService.js","sources":["../../src/services/inventoryService.ts"],"sourcesContent":["import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField\n} from 'firebase/firestore'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, BusinessInventoryStats } from '@/types'\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction\n  async getTransaction(projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory)\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    // Get all projects first\n    const projects = await projectService.getProjects()\n\n    // Search through each project's transactions\n    for (const project of projects) {\n      try {\n        const transaction = await this.getTransaction(project.id, transactionId)\n        if (transaction) {\n          return { transaction, projectId: project.id }\n        }\n      } catch (error) {\n        console.error(`Error searching for transaction ${transactionId} in project ${project.id}:`, error)\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction\n  async createTransaction(\n    projectId: string,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      const docRef = await addDoc(transactionsRef, newTransaction)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          projectId,\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          items\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction\n  async updateTransaction(projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    await updateDoc(transactionRef, finalUpdates)\n  },\n\n  // Delete transaction\n  async deleteTransaction(projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions\n  subscribeToTransactions(projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates\n  subscribeToTransaction(\n    projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'cancelled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = new Date().toISOString()\n    }\n\n    await updateDoc(transactionRef, updateData)\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Get items for a project (project_id == projectId)\n  async getItemsByProject(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('project_price', '>=', filters.priceRange.min),\n        where('project_price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery && items.length > 0) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.payment_method.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to items for a project\n  subscribeToItemsByProject(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Get business inventory items (project_id == null)\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Create new item\n  async createItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.project_id !== undefined) firebaseUpdates.project_id = updates.project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.transaction_id !== undefined) firebaseUpdates.transaction_id = updates.transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete item\n  async deleteItem(itemId: string): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get items for a transaction (by transaction_id)\n  async getItemsForTransaction(_projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n  },\n\n  // Allocate single item to project (creates/updates INV_SALE_<projectId> transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine the amount if not provided\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Use canonical transaction ID for inventory sales\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n\n    // Upsert the canonical transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', canonicalTransactionId)\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Item allocated from business inventory',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const,\n      item_ids: [itemId], // Initialize with this item\n      created_by: 'system',\n      last_updated: new Date().toISOString()\n    }\n\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update the item in the unified collection\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'pending',\n      transaction_id: canonicalTransactionId\n    })\n\n    return canonicalTransactionId\n  },\n\n  // Batch allocate multiple items to project (updates INV_SALE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the business inventory items first\n    const itemsRef = collection(db, 'items')\n    const itemsQuery = query(itemsRef, where('__name__', 'in', itemIds), where('project_id', '==', null))\n    const itemsSnapshot = await getDocs(itemsQuery)\n\n    if (itemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Use canonical transaction ID for inventory sales\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n\n    // Calculate total amount from items\n    const totalAmount = allocationData.amount || itemsSnapshot.docs\n      .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n      .reduce((sum, price) => sum + parseFloat(price || '0'), 0)\n      .toFixed(2)\n\n    // Upsert the canonical transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', canonicalTransactionId)\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Batch Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: totalAmount,\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `Batch allocation of ${itemIds.length} items from business inventory`,\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const,\n      item_ids: itemIds,\n      created_by: 'system',\n      last_updated: new Date().toISOString()\n    }\n\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update all items in the unified collection\n    const batch = writeBatch(db)\n    itemsSnapshot.docs.forEach((itemDoc) => {\n      const itemId = itemDoc.id\n      batch.update(doc(db, 'items', itemId), {\n        project_id: projectId,\n        inventory_status: 'pending',\n        transaction_id: canonicalTransactionId,\n        last_updated: new Date().toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (creates/updates INV_BUY_<projectId> transaction)\n  async returnItemFromProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    // Use canonical transaction ID for inventory purchases\n    const canonicalTransactionId = `INV_BUY_${projectId}`\n\n    // Calculate amount (use purchase_price for buy transactions)\n    const finalAmount = amount || item.purchase_price || item.market_value || '0.00'\n\n    // Upsert the canonical transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', canonicalTransactionId)\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Return',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Item returned to business inventory',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Inventory return' as const,\n      item_ids: [itemId],\n      created_by: 'system',\n      last_updated: new Date().toISOString()\n    }\n\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update the item in the unified collection\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: canonicalTransactionId\n    })\n\n    return canonicalTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_BUY_${projectId}`\n\n    // Get the transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      throw new Error('Transaction not found')\n    }\n\n    const transactionData = transactionSnap.data()\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      payment_method: paymentMethod,\n      transaction_date: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    })\n\n    // Clear transaction_id from all linked items\n    const batch = writeBatch(db)\n    for (const itemId of itemIds) {\n      const itemRef = doc(db, 'items', itemId)\n      if (transactionType === 'sale') {\n        // For sales, keep project_id but clear transaction_id and set status to sold\n        batch.update(itemRef, {\n          transaction_id: null,\n          inventory_status: 'sold',\n          last_updated: new Date().toISOString()\n        })\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        batch.update(itemRef, {\n          project_id: null,\n          transaction_id: null,\n          inventory_status: 'available',\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    await batch.commit()\n  },\n\n  // Helper function to get item by ID\n  async getItemById(itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate an existing item (unified collection version)\n  async duplicateItem(projectId: string, originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getItemById(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transaction_id,\n      project_id: projectId,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'items', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version)\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    items: TransactionItemFormData[]\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    items.forEach((itemData) => {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        project_price: itemData.project_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || '',\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transactionDate,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      } as Item\n\n      batch.set(itemRef, item)\n    })\n\n    await batch.commit()\n    return createdItemIds\n  }\n}\n\n// Business Inventory Services (DEPRECATED - use unifiedItemsService instead)\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<Item | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate a business inventory item\n  async duplicateBusinessInventoryItem(originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getBusinessInventoryItem(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original business inventory item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `BI-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      inventory_status: 'available', // Default status for duplicates\n      business_inventory_location: originalItem.business_inventory_location || '',\n      transaction_id: originalItem.transaction_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'business_inventory', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let pendingItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'pending':\n          pendingItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      pendingItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item to determine the amount if not provided\n    const item = await this.getBusinessInventoryItem(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Item allocated from business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to pending and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'pending',\n      transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: now.toISOString(),\n      source: 'Batch Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `Batch allocation of ${itemIds.length} items from business inventory`,\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        project_price: businessItemData.project_price, // 1584 design project price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes || '',\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItems = await unifiedItemsService.getItemsByProject(projectId)\n    const currentItemCount = currentItems.length\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n  async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'cancelled'\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: new Date().toISOString(),\n      payment_method: paymentMethod\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Client Purchase',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('🔄 handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('⏭️ Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('🔍 Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('✅ Item found:', item.item_id, 'disposition:', item.disposition, 'project_id:', item.project_id)\n\n      // Unified approach: Always create/update a \"We Owe\" transaction for inventory designation\n      console.log('🏦 Creating/updating We Owe transaction for inventory designation')\n      const transactionId = await this.ensurePurchaseTransaction(\n        item,\n        projectId,\n        `Item designated for inventory: ${item.description}`\n      )\n\n      console.log('📦 Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(item.item_id, {\n        project_id: null,\n        inventory_status: 'available',\n        transaction_id: transactionId,\n        last_updated: new Date().toISOString()\n      })\n      console.log('✅ Item moved to business inventory successfully')\n\n      console.log('✅ Deallocation completed successfully')\n    } catch (error) {\n      console.error('❌ Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a purchase transaction exists for inventory designation\n  async ensurePurchaseTransaction(\n    item: Item,\n    projectId: string,\n    additionalNotes?: string\n  ): Promise<string> {\n    console.log('🏦 Creating/updating purchase transaction for item:', item.item_id)\n\n    const canonicalTransactionId = `INV_BUY_${projectId}`\n    console.log('🔑 Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    let transactionData: any = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Return',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      budget_category: 'Furnishings',\n      notes: additionalNotes || 'Item returned to business inventory',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Inventory return' as const,\n      item_ids: [item.item_id], // Start with current item\n      created_by: 'system',\n      created_at: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    }\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('📋 Existing transaction found, updating with new item')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.item_id])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const itemsRef = collection(db, 'items')\n      const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n      const itemsSnapshot = await getDocs(itemsQuery)\n\n      const totalAmount = itemsSnapshot.docs\n        .map(doc => doc.data().purchase_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      transactionData = {\n        ...existingData,\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: existingData.notes || 'Multiple items returned to business inventory',\n        last_updated: new Date().toISOString()\n      }\n\n      console.log('🔄 Updated transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // New transaction - calculate amount from current item\n      const itemAmount = item.purchase_price || item.market_value || '0.00'\n      transactionData.amount = parseFloat(itemAmount || '0').toFixed(2)\n\n      console.log('🆕 Creating new transaction with amount:', transactionData.amount)\n    }\n\n    console.log('💾 Creating/updating transaction document...')\n    await setDoc(transactionRef, transactionData, { merge: true })\n    console.log('✅ Transaction created/updated successfully')\n\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction('sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(itemId, projectId, disposition)\n  }\n}\n"],"names":["projectService","ensureAuthenticatedForStorage","projectsRef","collection","db","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectId","projectRef","projectSnap","getDoc","projectData","now","newProject","addDoc","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","transactionService","transactionsRef","transactionData","transactionId","transactionRef","transactionSnap","project","transaction","error","items","newTransaction","createdItemIds","unifiedItemsService","finalUpdates","deleteField","transactions","where","status","updateData","filters","pagination","itemsRef","searchTerm","limit","item","_a","itemData","newItem","itemId","itemRef","firebaseUpdates","_projectId","amount","notes","finalAmount","canonicalTransactionId","setDoc","itemIds","allocationData","itemsQuery","itemsSnapshot","totalAmount","sum","price","batch","writeBatch","itemDoc","transactionType","paymentMethod","itemSnap","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","key","transactionDate","transactionSource","qrKey","businessInventoryService","getCountFromServer","allItemsQuery","allItemsSnap","availableItems","pendingItems","soldItems","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","projectItemsRef","itemQuery","newBusinessItem","deallocationService","disposition","additionalNotes","existingData","existingItemIds","updatedItemIds","itemAmount","integrationService","_transactionId","_itemId"],"mappings":"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"}