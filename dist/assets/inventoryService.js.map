{"version":3,"file":"inventoryService.js","sources":["../../src/services/inventoryService.ts"],"sourcesContent":["import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField\n} from 'firebase/firestore'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, ItemImage, BusinessInventoryItem, BusinessInventoryStats } from '@/types'\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services\nexport const itemService = {\n  // Get items for a project with filtering and pagination\n  async getItems(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('price', '>=', filters.priceRange.min),\n        where('price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        // This is a simplified pagination - in production you'd use cursor-based pagination\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery && items.length > 0) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n    return items\n  },\n\n\n  // Get single item\n  async getItem(projectId: string, itemId: string): Promise<Item | null> {\n    console.log('getItem called with:', { projectId, itemId })\n\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    console.log('Document path:', itemRef.path)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      const data = itemSnap.data()\n      console.log('Raw Firebase data:', data)\n      console.log('Images in Firebase:', data.images?.length || 0, 'images')\n\n      const mappedItem = {\n        item_id: itemSnap.id,\n        description: data.description,\n        source: data.source,\n        sku: data.sku,\n        purchase_price: data.purchase_price,\n        project_price: data.project_price,\n        market_value: data.market_value, // Direct mapping\n        payment_method: data.payment_method,\n        disposition: data.disposition,\n        notes: data.notes,\n        space: data.space, // Add space field\n        qr_key: data.qr_key,\n        bookmark: data.bookmark,\n        transaction_id: data.transaction_id,\n        project_id: data.project_id,\n        date_created: data.date_created,\n        last_updated: data.last_updated,\n        images: data.images || [] // Include images from Firebase\n      } as Item\n\n      console.log('Mapped item data:', mappedItem)\n      console.log('Mapped images:', mappedItem.images?.length || 0, 'images')\n      return mappedItem\n    }\n    console.log('Document does not exist at path:', itemRef.path)\n    console.log('itemSnap.exists():', itemSnap.exists())\n    console.log('Item not found')\n    return null\n  },\n\n  // Create new item\n  async createItem(projectId: string, itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const now = new Date()\n\n    // Map form fields to Firebase fields\n    const newItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      purchase_price: itemData.purchase_price,\n      project_price: itemData.project_price,\n      market_value: itemData.market_value, // Direct mapping\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep', // Default to 'keep' if not provided\n      notes: itemData.notes,\n      space: itemData.space, // Add space field\n      qr_key: itemData.qr_key || `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`,\n      bookmark: itemData.bookmark,\n      transaction_id: itemData.transaction_id,\n      project_id: itemData.project_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n\n    // Update project metadata\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: await itemService.getItemCount(projectId) + 1,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(projectId: string, itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n\n    // Map form fields to Firebase fields for updates\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.market_value !== undefined) {\n      firebaseUpdates.market_value = updates.market_value // Direct mapping\n    }\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space // Add space field\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) {\n      console.log('Updating item images:', updates.images?.length, 'images')\n      firebaseUpdates.images = updates.images\n    }\n\n    console.log('Updating item in database:', itemId, 'with updates:', Object.keys(firebaseUpdates))\n    await updateDoc(itemRef, firebaseUpdates)\n    console.log('Item updated successfully in database')\n  },\n\n  // Add image to item\n  async addItemImage(projectId: string, itemId: string, image: ItemImage): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n    const updatedImages = [...currentImages, image]\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Update item images\n  async updateItemImages(projectId: string, itemId: string, images: ItemImage[]): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await updateDoc(itemRef, {\n      images: images,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Remove image from item\n  async removeItemImage(projectId: string, itemId: string, imageUrl: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n    const updatedImages = currentImages.filter((img: ItemImage) => img.url !== imageUrl)\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Set primary image\n  async setPrimaryImage(projectId: string, itemId: string, imageUrl: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n\n    const updatedImages = currentImages.map((img: ItemImage) => ({\n      ...img,\n      isPrimary: img.url === imageUrl\n    }))\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Delete item\n  async deleteItem(projectId: string, itemId: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await deleteDoc(itemRef)\n\n    // Update project metadata\n    const now = new Date()\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: Math.max(0, await itemService.getItemCount(projectId) - 1),\n        lastActivity: now\n      }\n    } as Partial<Project>)\n  },\n\n  // Get item count for a project\n  async getItemCount(projectId: string): Promise<number> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const snapshot = await getCountFromServer(itemsRef)\n    return snapshot.data().count\n  },\n\n  // Subscribe to items\n  subscribeToItems(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    // Apply server-side filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      console.log('Real-time items snapshot received:', snapshot.docs.length, 'documents')\n      let items = snapshot.docs.map(doc => {\n        const data = doc.data()\n        const item = {\n          item_id: doc.id,\n          description: data.description,\n          source: data.source,\n          sku: data.sku,\n          purchase_price: data.purchase_price,\n          project_price: data.project_price,\n          market_value: data.market_value, // Direct mapping\n          payment_method: data.payment_method,\n          disposition: data.disposition,\n          notes: data.notes,\n          space: data.space, // Add space field\n          qr_key: data.qr_key,\n          bookmark: data.bookmark,\n          transaction_id: data.transaction_id,\n          project_id: data.project_id,\n          date_created: data.date_created,\n          last_updated: data.last_updated,\n          images: data.images || [] // Include images from Firebase\n        } as Item\n        return item\n      })\n\n      // Apply client-side filters\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      console.log('Real-time items callback with', items.length, 'items')\n      callback(items)\n    })\n  },\n\n  // Search items\n  async searchItems(projectId: string, searchQuery: string): Promise<Item[]> {\n    if (searchQuery.length < 2) return []\n\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const q = query(\n      itemsRef,\n      where('description', '>=', searchQuery.toLowerCase()),\n      where('description', '<=', searchQuery.toLowerCase() + '\\uf8ff'),\n      orderBy('description'),\n      limit(20)\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => {\n      const data = doc.data()\n      return {\n        item_id: doc.id,\n        description: data.description,\n        source: data.source,\n        sku: data.sku,\n        purchase_price: data.purchase_price,\n        project_price: data.project_price,\n        market_value: data.market_value, // Direct mapping\n        payment_method: data.payment_method,\n        disposition: data.disposition,\n        notes: data.notes,\n        space: data.space, // Add space field\n        qr_key: data.qr_key,\n        bookmark: data.bookmark,\n        transaction_id: data.transaction_id,\n        project_id: data.project_id,\n        date_created: data.date_created,\n        last_updated: data.last_updated\n      } as Item\n    })\n  },\n\n  // Batch operations\n  async batchUpdateItems(projectId: string, itemUpdates: Array<{ id: string; updates: Partial<Item> }>): Promise<void> {\n    const batch = writeBatch(db)\n\n    itemUpdates.forEach(({ id, updates }) => {\n      const itemRef = doc(db, 'projects', projectId, 'items', id)\n\n      // Map form fields to Firebase fields for batch updates\n      const firebaseUpdates: any = {\n        last_updated: new Date().toISOString()\n      }\n\n      if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n      if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n      if (updates.market_value !== undefined) {\n        firebaseUpdates.market_value = updates.market_value // Direct mapping\n      }\n      if (updates.description !== undefined) firebaseUpdates.description = updates.description\n      if (updates.source !== undefined) firebaseUpdates.source = updates.source\n      if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n      if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n      if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n      if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n      if (updates.space !== undefined) firebaseUpdates.space = updates.space // Add space field\n      if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n\n      batch.update(itemRef, firebaseUpdates)\n    })\n\n    await batch.commit()\n  },\n\n  // Duplicate an existing item\n  async duplicateItem(projectId: string, originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getItem(projectId, originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transaction_id,\n      project_id: projectId,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'projects', projectId, 'items', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    // Update project metadata\n    const itemCount = await this.getItemCount(projectId)\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: itemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    items: TransactionItemFormData[]\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    items.forEach((itemData) => {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        project_price: itemData.project_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || '',\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transactionDate,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      } as Item\n\n      batch.set(itemRef, item)\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const itemCount = await this.getItemCount(projectId)\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: itemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return createdItemIds\n  },\n\n  // Get items for a transaction\n  async getTransactionItems(projectId: string, transactionId: string): Promise<string[]> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => doc.id)\n  },\n\n  // Add single item to existing transaction\n  async addItemToTransaction(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    itemData: TransactionItemFormData\n  ): Promise<string> {\n    const now = new Date()\n\n    const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    const item = {\n      item_id: itemId,\n      description: itemData.description,\n      source: transactionSource,\n      sku: itemData.sku || '',\n      purchase_price: itemData.purchase_price,\n      project_price: itemData.project_price,\n      market_value: itemData.market_value || '',\n      payment_method: 'Client Card', // Default payment method\n      disposition: 'keep',\n      notes: itemData.notes || '',\n      space: '', // Add space field\n      qr_key: qrKey,\n      bookmark: false,\n      transaction_id: transactionId,\n      project_id: projectId,\n      date_created: transactionDate,\n      last_updated: now.toISOString(),\n      images: [] // Start with empty images array, will be populated after upload\n    } as Item\n\n    // Create the document with the itemId as the document ID\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await setDoc(itemRef, item)\n\n    // Update project metadata\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: await itemService.getItemCount(projectId) + 1,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return itemId\n  }\n}\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction\n  async getTransaction(projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory)\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    // Get all projects first\n    const projects = await projectService.getProjects()\n\n    // Search through each project's transactions\n    for (const project of projects) {\n      try {\n        const transaction = await this.getTransaction(project.id, transactionId)\n        if (transaction) {\n          return { transaction, projectId: project.id }\n        }\n      } catch (error) {\n        console.error(`Error searching for transaction ${transactionId} in project ${project.id}:`, error)\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction\n  async createTransaction(\n    projectId: string,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      const docRef = await addDoc(transactionsRef, newTransaction)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        const createdItemIds = await itemService.createTransactionItems(\n          projectId,\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          items\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction\n  async updateTransaction(projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    await updateDoc(transactionRef, finalUpdates)\n  },\n\n  // Delete transaction\n  async deleteTransaction(projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions\n  subscribeToTransactions(projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates\n  subscribeToTransaction(\n    projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'cancelled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = new Date().toISOString()\n    }\n\n    await updateDoc(transactionRef, updateData)\n  }\n}\n\n// Business Inventory Services\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<BusinessInventoryItem[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as BusinessInventoryItem))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<BusinessInventoryItem | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as BusinessInventoryItem\n    }\n    return null\n  },\n\n  // Duplicate a business inventory item\n  async duplicateBusinessInventoryItem(originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getBusinessInventoryItem(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original business inventory item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `BI-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      inventory_status: 'available', // Default status for duplicates\n      current_project_id: undefined, // Clear project allocation for duplicates\n      business_inventory_location: originalItem.business_inventory_location || '',\n      pending_transaction_id: undefined, // Clear pending transaction for duplicates\n      transaction_id: originalItem.transaction_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'business_inventory', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<BusinessInventoryItem, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<BusinessInventoryItem>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.current_project_id !== undefined) firebaseUpdates.current_project_id = updates.current_project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.pending_transaction_id !== undefined) firebaseUpdates.pending_transaction_id = updates.pending_transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let pendingItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'pending':\n          pendingItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      pendingItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: BusinessInventoryItem[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as BusinessInventoryItem))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Item allocated from business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to pending and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'pending',\n      current_project_id: projectId,\n      pending_transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: now.toISOString(),\n      source: 'Batch Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `Batch allocation of ${itemIds.length} items from business inventory`,\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        project_price: businessItemData.project_price, // 1584 design project price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes || '',\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        current_project_id: projectId,\n        pending_transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItemCount = await itemService.getItemCount(projectId)\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n  async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'cancelled'\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      current_project_id: undefined,\n      pending_transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: new Date().toISOString(),\n      payment_method: paymentMethod\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      current_project_id: undefined,\n      pending_transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Client Purchase',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    return await businessInventoryService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory\n  async returnItemToBusinessInventory(\n    itemId: string,\n    transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    return await businessInventoryService.returnItemFromProject(itemId, transactionId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold\n  async completePendingTransaction(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    return await businessInventoryService.markItemAsSold(itemId, transactionId, projectId, paymentMethod)\n  }\n}\n"],"names":["projectService","ensureAuthenticatedForStorage","projectsRef","collection","db","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectId","projectRef","projectSnap","getDoc","projectData","now","newProject","addDoc","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","itemService","filters","pagination","itemsRef","where","searchTerm","limit","items","item","itemId","itemRef","itemSnap","_a","mappedItem","_b","itemData","newItem","docRef","firebaseUpdates","image","updatedImages","images","imageUrl","img","getCountFromServer","searchQuery","itemUpdates","batch","writeBatch","id","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","key","setDoc","itemCount","transactionId","transactionDate","transactionSource","createdItemIds","qrKey","transactionService","transactionsRef","transactionData","transactionRef","transactionSnap","project","transaction","error","newTransaction","finalUpdates","deleteField","transactions","status","updateData","businessInventoryService","allItemsQuery","allItemsSnap","availableItems","pendingItems","soldItems","amount","notes","itemIds","allocationData","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","paymentMethod","projectItemsRef","itemQuery","newBusinessItem"],"mappings":"2OAsBO,MAAMA,EAAiB,CAE5B,MAAM,aAAkC,CAEtC,MAAMC,EAAA,EAEN,MAAMC,EAAcC,EAAWC,EAAI,UAAU,EACvCC,EAAIC,EAAMJ,EAAaK,EAAQ,YAAa,MAAM,CAAC,EAGzD,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,WAAWE,EAA4C,CAE3D,MAAMX,EAAA,EAEN,MAAMY,EAAaJ,EAAIL,EAAI,WAAYQ,CAAS,EAC1CE,EAAc,MAAMC,EAAOF,CAAU,EAE3C,GAAIC,EAAY,SAAU,CACxB,MAAMJ,EAAOC,EAAkBG,EAAY,KAAA,CAAM,EACjD,MAAO,CACL,GAAIA,EAAY,GAChB,GAAGJ,CAAA,CAEP,CACA,OAAO,IACT,EAGA,MAAM,cAAcM,EAA+E,CACjG,MAAMd,EAAcC,EAAWC,EAAI,UAAU,EACvCa,MAAU,KAEVC,EAAa,CACjB,GAAGF,EACH,UAAWC,EACX,UAAWA,CAAA,EAIb,OADe,MAAME,EAAOjB,EAAagB,CAAU,GACrC,EAChB,EAGA,MAAM,cAAcN,EAAmBQ,EAA0C,CAC/E,MAAMP,EAAaJ,EAAIL,EAAI,WAAYQ,CAAS,EAChD,MAAMS,EAAUR,EAAY,CAC1B,GAAGO,EACH,cAAe,IAAK,CACrB,CACH,EAGA,MAAM,cAAcR,EAAkC,CACpD,MAAMC,EAAaJ,EAAIL,EAAI,WAAYQ,CAAS,EAChD,MAAMU,EAAUT,CAAU,CAC5B,EAGA,oBAAoBU,EAAyC,CAC3D,MAAMrB,EAAcC,EAAWC,EAAI,UAAU,EACvCC,EAAIC,EAAMJ,EAAaK,EAAQ,YAAa,MAAM,CAAC,EAEzD,OAAOiB,EAAWnB,EAAIoB,GAAa,CACjC,MAAMC,EAAWD,EAAS,KAAK,IAAIhB,GAAO,CACxC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,EACDa,EAASG,CAAQ,CACnB,CAAC,CACH,CACF,EAGaC,EAAc,CAEzB,MAAM,SACJf,EACAgB,EACAC,EACiB,CACjB,MAAMC,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EAC9D,IAAIP,EAAIC,EAAMwB,CAAQ,EAwBtB,GArBIF,GAAA,MAAAA,EAAS,SACXvB,EAAIC,EAAMD,EAAG0B,EAAM,cAAe,KAAMH,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXvB,EAAIC,EAAMD,EAAG0B,EAAM,SAAU,KAAMH,EAAQ,QAAQ,CAAC,GAGlDA,GAAA,MAAAA,EAAS,MAAQA,EAAQ,KAAK,OAAS,IACzCvB,EAAIC,EAAMD,EAAG0B,EAAM,OAAQ,qBAAsBH,EAAQ,IAAI,CAAC,GAG5DA,GAAA,MAAAA,EAAS,aACXvB,EAAIC,EACFD,EACA0B,EAAM,QAAS,KAAMH,EAAQ,WAAW,GAAG,EAC3CG,EAAM,QAAS,KAAMH,EAAQ,WAAW,GAAG,CAAA,GAK3CA,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMI,EAAaJ,EAAQ,YAAY,YAAA,EACvCvB,EAAIC,EACFD,EACA0B,EAAM,cAAe,KAAMC,CAAU,EACrCD,EAAM,cAAe,KAAMC,EAAa,GAAQ,CAAA,CAEpD,CAGA3B,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCsB,IACFxB,EAAIC,EAAMD,EAAG4B,EAAMJ,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IAEpBxB,EAAIC,EAAMD,EAAG4B,EAAMJ,EAAW,KAAOA,EAAW,KAAK,CAAC,IAO1D,IAAIK,GAHkB,MAAM1B,EAAQH,CAAC,GAGX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGR,GAAImB,GAAA,MAAAA,EAAS,aAAeM,EAAM,OAAS,EAAG,CAC5C,MAAMF,EAAaJ,EAAQ,YAAY,YAAA,EACvCM,EAAQA,EAAM,OAAOC,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASH,CAAU,GAClDG,EAAK,OAAO,YAAA,EAAc,SAASH,CAAU,GAC7CG,EAAK,IAAI,YAAA,EAAc,SAASH,CAAU,GAC1CG,EAAK,eAAe,YAAA,EAAc,SAASH,CAAU,CAAA,CAEzD,CAEF,OAAOE,CACT,EAIA,MAAM,QAAQtB,EAAmBwB,EAAsC,SACrE,QAAQ,IAAI,uBAAwB,CAAE,UAAAxB,EAAW,OAAAwB,EAAQ,EAGzD,MAAMnC,EAAA,EAEN,MAAMoC,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EAC9D,QAAQ,IAAI,iBAAkBC,EAAQ,IAAI,EAC1C,MAAMC,EAAW,MAAMvB,EAAOsB,CAAO,EAErC,GAAIC,EAAS,SAAU,CACrB,MAAM5B,EAAO4B,EAAS,KAAA,EACtB,QAAQ,IAAI,qBAAsB5B,CAAI,EACtC,QAAQ,IAAI,wBAAuB6B,EAAA7B,EAAK,SAAL,YAAA6B,EAAa,SAAU,EAAG,QAAQ,EAErE,MAAMC,EAAa,CACjB,QAASF,EAAS,GAClB,YAAa5B,EAAK,YAClB,OAAQA,EAAK,OACb,IAAKA,EAAK,IACV,eAAgBA,EAAK,eACrB,cAAeA,EAAK,cACpB,aAAcA,EAAK,aACnB,eAAgBA,EAAK,eACrB,YAAaA,EAAK,YAClB,MAAOA,EAAK,MACZ,MAAOA,EAAK,MACZ,OAAQA,EAAK,OACb,SAAUA,EAAK,SACf,eAAgBA,EAAK,eACrB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,aAAcA,EAAK,aACnB,OAAQA,EAAK,QAAU,CAAA,CAAC,EAG1B,eAAQ,IAAI,oBAAqB8B,CAAU,EAC3C,QAAQ,IAAI,mBAAkBC,EAAAD,EAAW,SAAX,YAAAC,EAAmB,SAAU,EAAG,QAAQ,EAC/DD,CACT,CACA,eAAQ,IAAI,mCAAoCH,EAAQ,IAAI,EAC5D,QAAQ,IAAI,qBAAsBC,EAAS,OAAA,CAAQ,EACnD,QAAQ,IAAI,gBAAgB,EACrB,IACT,EAGA,MAAM,WAAW1B,EAAmB8B,EAAoF,CACtH,MAAMZ,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EACxDK,MAAU,KAGV0B,EAAU,CACd,YAAaD,EAAS,YACtB,OAAQA,EAAS,OACjB,IAAKA,EAAS,IACd,eAAgBA,EAAS,eACzB,cAAeA,EAAS,cACxB,aAAcA,EAAS,aACvB,eAAgBA,EAAS,eACzB,YAAaA,EAAS,aAAe,OACrC,MAAOA,EAAS,MAChB,MAAOA,EAAS,MAChB,OAAQA,EAAS,QAAU,MAAM,KAAK,KAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACtF,SAAUA,EAAS,SACnB,eAAgBA,EAAS,eACzB,WAAYA,EAAS,WACrB,aAAczB,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAG1B2B,EAAS,MAAMzB,EAAOW,EAAUa,CAAO,EAG7C,aAAM3C,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAY,MAAMe,EAAY,aAAaf,CAAS,EAAI,EACxD,aAAcK,CAAA,CAChB,CACmB,EAEd2B,EAAO,EAChB,EAGA,MAAM,WAAWhC,EAAmBwB,EAAgBhB,EAAuC,OACzF,MAAMiB,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EAGxDS,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCzB,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWyB,EAAgB,cAAgBzB,EAAQ,eAC7EA,EAAQ,eAAiB,SAC3ByB,EAAgB,aAAezB,EAAQ,cAErCA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,SAAW,SAAWyB,EAAgB,OAASzB,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWyB,EAAgB,IAAMzB,EAAQ,KACzDA,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,WAAa,SAAWyB,EAAgB,SAAWzB,EAAQ,UACnEA,EAAQ,SAAW,SACrB,QAAQ,IAAI,yBAAyBmB,EAAAnB,EAAQ,SAAR,YAAAmB,EAAgB,OAAQ,QAAQ,EACrEM,EAAgB,OAASzB,EAAQ,QAGnC,QAAQ,IAAI,6BAA8BgB,EAAQ,gBAAiB,OAAO,KAAKS,CAAe,CAAC,EAC/F,MAAMxB,EAAUgB,EAASQ,CAAe,EACxC,QAAQ,IAAI,uCAAuC,CACrD,EAGA,MAAM,aAAajC,EAAmBwB,EAAgBU,EAAiC,CACrF,MAAMT,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EACxDE,EAAW,MAAMvB,EAAOsB,CAAO,EAErC,GAAI,CAACC,EAAS,SACZ,MAAM,IAAI,MAAM,gBAAgB,EAKlC,MAAMS,EAAgB,CAAC,GAFNT,EAAS,KAAA,EACK,QAAU,CAAA,EACAQ,CAAK,EAE9C,MAAMzB,EAAUgB,EAAS,CACvB,OAAQU,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,EAGA,MAAM,iBAAiBnC,EAAmBwB,EAAgBY,EAAoC,CAC5F,MAAMX,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EAC9D,MAAMf,EAAUgB,EAAS,CACvB,OAAAW,EACA,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,EAGA,MAAM,gBAAgBpC,EAAmBwB,EAAgBa,EAAiC,CACxF,MAAMZ,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EACxDE,EAAW,MAAMvB,EAAOsB,CAAO,EAErC,GAAI,CAACC,EAAS,SACZ,MAAM,IAAI,MAAM,gBAAgB,EAKlC,MAAMS,GAFWT,EAAS,KAAA,EACK,QAAU,CAAA,GACL,OAAQY,GAAmBA,EAAI,MAAQD,CAAQ,EAEnF,MAAM5B,EAAUgB,EAAS,CACvB,OAAQU,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,EAGA,MAAM,gBAAgBnC,EAAmBwB,EAAgBa,EAAiC,CACxF,MAAMZ,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EACxDE,EAAW,MAAMvB,EAAOsB,CAAO,EAErC,GAAI,CAACC,EAAS,SACZ,MAAM,IAAI,MAAM,gBAAgB,EAMlC,MAAMS,GAHWT,EAAS,KAAA,EACK,QAAU,CAAA,GAEL,IAAKY,IAAoB,CAC3D,GAAGA,EACH,UAAWA,EAAI,MAAQD,CAAA,EACvB,EAEF,MAAM5B,EAAUgB,EAAS,CACvB,OAAQU,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,EAGA,MAAM,WAAWnC,EAAmBwB,EAA+B,CACjE,MAAMC,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EAC9D,MAAMd,EAAUe,CAAO,EAGvB,MAAMpB,MAAU,KAChB,MAAMjB,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAY,KAAK,IAAI,EAAG,MAAMe,EAAY,aAAaf,CAAS,EAAI,CAAC,EACrE,aAAcK,CAAA,CAChB,CACmB,CACvB,EAGA,MAAM,aAAaL,EAAoC,CACrD,MAAMkB,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EAE9D,OADiB,MAAMuC,EAAmBrB,CAAQ,GAClC,OAAO,KACzB,EAGA,iBACElB,EACAW,EACAK,EACA,CACA,MAAME,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EAC9D,IAAIP,EAAIC,EAAMwB,EAAUvB,EAAQ,eAAgB,MAAM,CAAC,EAGvD,OAAIqB,GAAA,MAAAA,EAAS,SACXvB,EAAIC,EAAMD,EAAG0B,EAAM,cAAe,KAAMH,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXvB,EAAIC,EAAMD,EAAG0B,EAAM,SAAU,KAAMH,EAAQ,QAAQ,CAAC,GAG/CJ,EAAWnB,EAAIoB,GAAa,CACjC,QAAQ,IAAI,qCAAsCA,EAAS,KAAK,OAAQ,WAAW,EACnF,IAAIS,EAAQT,EAAS,KAAK,IAAIhB,GAAO,CACnC,MAAMC,EAAOD,EAAI,KAAA,EAqBjB,MApBa,CACX,QAASA,EAAI,GACb,YAAaC,EAAK,YAClB,OAAQA,EAAK,OACb,IAAKA,EAAK,IACV,eAAgBA,EAAK,eACrB,cAAeA,EAAK,cACpB,aAAcA,EAAK,aACnB,eAAgBA,EAAK,eACrB,YAAaA,EAAK,YAClB,MAAOA,EAAK,MACZ,MAAOA,EAAK,MACZ,OAAQA,EAAK,OACb,SAAUA,EAAK,SACf,eAAgBA,EAAK,eACrB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,aAAcA,EAAK,aACnB,OAAQA,EAAK,QAAU,CAAA,CAAC,CAG5B,CAAC,EAGD,GAAIkB,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMI,EAAaJ,EAAQ,YAAY,YAAA,EACvCM,EAAQA,EAAM,OAAOC,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASH,CAAU,GAClDG,EAAK,OAAO,YAAA,EAAc,SAASH,CAAU,GAC7CG,EAAK,IAAI,YAAA,EAAc,SAASH,CAAU,GAC1CG,EAAK,eAAe,YAAA,EAAc,SAASH,CAAU,CAAA,CAEzD,CAEA,QAAQ,IAAI,gCAAiCE,EAAM,OAAQ,OAAO,EAClEX,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,YAAYtB,EAAmBwC,EAAsC,CACzE,GAAIA,EAAY,OAAS,EAAG,MAAO,CAAA,EAEnC,MAAMtB,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EACxDP,EAAIC,EACRwB,EACAC,EAAM,cAAe,KAAMqB,EAAY,aAAa,EACpDrB,EAAM,cAAe,KAAMqB,EAAY,YAAA,EAAgB,GAAQ,EAC/D7C,EAAQ,aAAa,EACrB0B,EAAM,EAAE,CAAA,EAKV,OAFsB,MAAMzB,EAAQH,CAAC,GAEhB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOD,EAAI,KAAA,EACjB,MAAO,CACL,QAASA,EAAI,GACb,YAAaC,EAAK,YAClB,OAAQA,EAAK,OACb,IAAKA,EAAK,IACV,eAAgBA,EAAK,eACrB,cAAeA,EAAK,cACpB,aAAcA,EAAK,aACnB,eAAgBA,EAAK,eACrB,YAAaA,EAAK,YAClB,MAAOA,EAAK,MACZ,MAAOA,EAAK,MACZ,OAAQA,EAAK,OACb,SAAUA,EAAK,SACf,eAAgBA,EAAK,eACrB,WAAYA,EAAK,WACjB,aAAcA,EAAK,aACnB,aAAcA,EAAK,YAAA,CAEvB,CAAC,CACH,EAGA,MAAM,iBAAiBE,EAAmByC,EAA2E,CACnH,MAAMC,EAAQC,EAAWnD,CAAE,EAE3BiD,EAAY,QAAQ,CAAC,CAAE,GAAAG,EAAI,QAAApC,KAAc,CACvC,MAAMiB,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAAS4C,CAAE,EAGpDX,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCzB,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWyB,EAAgB,cAAgBzB,EAAQ,eAC7EA,EAAQ,eAAiB,SAC3ByB,EAAgB,aAAezB,EAAQ,cAErCA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,SAAW,SAAWyB,EAAgB,OAASzB,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWyB,EAAgB,IAAMzB,EAAQ,KACzDA,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,WAAa,SAAWyB,EAAgB,SAAWzB,EAAQ,UAEvEkC,EAAM,OAAOjB,EAASQ,CAAe,CACvC,CAAC,EAED,MAAMS,EAAM,OAAA,CACd,EAGA,MAAM,cAAc1C,EAAmB6C,EAAyC,CAE9E,MAAMC,EAAe,MAAM,KAAK,QAAQ9C,EAAW6C,CAAc,EACjE,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,MAAMzC,MAAU,KACV0C,EAAY,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACtEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,OAAS,GAC7B,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,eAAgBF,EAAa,eAC7B,WAAY9C,EACZ,aAAcK,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQyC,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQC,GAAO,CACrCD,EAAeC,CAAG,IAAM,QAC1B,OAAOD,EAAeC,CAAG,CAE7B,CAAC,EAGD,MAAMzB,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAAS+C,CAAS,EACjE,MAAMI,EAAO1B,EAASwB,CAAc,EAGpC,MAAMG,EAAY,MAAM,KAAK,aAAapD,CAAS,EACnD,aAAMZ,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAYoD,EACZ,aAAc/C,CAAA,CAChB,CACmB,EAEd0C,CACT,EAGA,MAAM,uBACJ/C,EACAqD,EACAC,EACAC,EACAjC,EACmB,CACnB,MAAMoB,EAAQC,EAAWnD,CAAE,EACrBgE,EAA2B,CAAA,EAC3BnD,MAAU,KAEhBiB,EAAM,QAASQ,GAAa,CAC1B,MAAMN,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACzEgC,EAAe,KAAKhC,CAAM,EAE1B,MAAMC,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EACxDiC,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEnElC,EAAO,CACX,QAASC,EACT,YAAaM,EAAS,YACtB,OAAQyB,EACR,IAAKzB,EAAS,KAAO,GACrB,eAAgBA,EAAS,eACzB,cAAeA,EAAS,cACxB,aAAcA,EAAS,cAAgB,GACvC,eAAgB,cAChB,YAAa,OACb,MAAOA,EAAS,OAAS,GACzB,OAAQ2B,EACR,SAAU,GACV,eAAgBJ,EAChB,WAAYrD,EACZ,aAAcsD,EACd,aAAcjD,EAAI,YAAA,EAClB,OAAQ,CAAA,CAAC,EAGXqC,EAAM,IAAIjB,EAASF,CAAI,CACzB,CAAC,EAED,MAAMmB,EAAM,OAAA,EAGZ,MAAMU,EAAY,MAAM,KAAK,aAAapD,CAAS,EACnD,aAAMZ,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAYoD,EACZ,aAAc/C,CAAA,CAChB,CACmB,EAEdmD,CACT,EAGA,MAAM,oBAAoBxD,EAAmBqD,EAA0C,CACrF,MAAMnC,EAAW3B,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EACxDP,EAAIC,EACRwB,EACAC,EAAM,iBAAkB,KAAMkC,CAAa,EAC3C1D,EAAQ,eAAgB,KAAK,CAAA,EAI/B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAOA,EAAI,EAAE,CAC7C,EAGA,MAAM,qBACJG,EACAqD,EACAC,EACAC,EACAzB,EACiB,CACjB,MAAMzB,MAAU,KAEVmB,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACnEiC,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEnElC,EAAO,CACX,QAASC,EACT,YAAaM,EAAS,YACtB,OAAQyB,EACR,IAAKzB,EAAS,KAAO,GACrB,eAAgBA,EAAS,eACzB,cAAeA,EAAS,cACxB,aAAcA,EAAS,cAAgB,GACvC,eAAgB,cAChB,YAAa,OACb,MAAOA,EAAS,OAAS,GACzB,MAAO,GACP,OAAQ2B,EACR,SAAU,GACV,eAAgBJ,EAChB,WAAYrD,EACZ,aAAcsD,EACd,aAAcjD,EAAI,YAAA,EAClB,OAAQ,CAAA,CAAC,EAILoB,EAAU5B,EAAIL,EAAI,WAAYQ,EAAW,QAASwB,CAAM,EAC9D,aAAM2B,EAAO1B,EAASF,CAAI,EAG1B,MAAMnC,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAY,MAAMe,EAAY,aAAaf,CAAS,EAAI,EACxD,aAAcK,CAAA,CAChB,CACmB,EAEdmB,CACT,CACF,EAGakC,EAAqB,CAEhC,MAAM,gBAAgB1D,EAA2C,CAC/D,MAAM2D,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtEP,EAAIC,EAAMiE,EAAiBhE,EAAQ,aAAc,MAAM,CAAC,EAG9D,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnC+D,EAAkB,CACtB,GAAG9D,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAG+D,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,eAAe5D,EAAmBqD,EAAoD,CAC1F,MAAMQ,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EAC7ES,EAAkB,MAAM3D,EAAO0D,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAC5B,MAAMhE,EAAOC,EAAkB+D,EAAgB,KAAA,CAAM,EAErD,QAAQ,IAAI,+BAAgChE,CAAI,EAChD,QAAQ,IAAI,yCAA0CA,EAAK,kBAAkB,EAC7E,QAAQ,IAAI,8CAA+C,OAAOA,EAAK,kBAAkB,EAEzF,MAAM8D,EAAkB,CACtB,GAAG9D,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,eAAQ,IAAI,gDAAiD8D,CAAe,EAErE,CACL,eAAgBE,EAAgB,GAChC,GAAGF,CAAA,CAEP,CACA,OAAO,IACT,EAGA,MAAM,mBAAmBP,EAA+F,CAEtH,MAAMvC,EAAW,MAAM1B,EAAe,YAAA,EAGtC,UAAW2E,KAAWjD,EACpB,GAAI,CACF,MAAMkD,EAAc,MAAM,KAAK,eAAeD,EAAQ,GAAIV,CAAa,EACvE,GAAIW,EACF,MAAO,CAAE,YAAAA,EAAa,UAAWD,EAAQ,EAAA,CAE7C,OAASE,EAAO,CACd,QAAQ,MAAM,mCAAmCZ,CAAa,eAAeU,EAAQ,EAAE,IAAKE,CAAK,CACnG,CAGF,MAAO,CAAE,YAAa,KAAM,UAAW,IAAA,CACzC,EAGA,MAAM,kBACJjE,EACA4D,EACAtC,EACiB,CACjB,GAAI,CACF,MAAMqC,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EAGtEkE,EAAiB,CACrB,GAAGN,EACH,eAJc,KAAA,EAIE,YAAA,EAEhB,OAAQA,EAAgB,QAAU,YAClC,mBAAoBA,EAAgB,oBAAsB,KAC1D,cAAeA,EAAgB,eAAiB,IAAA,EAGlD,QAAQ,IAAI,wBAAyBM,CAAc,EACnD,QAAQ,IAAI,qBAAsB5C,CAAK,EAGvC,MAAM+B,GADS,MAAM9C,EAAOoD,EAAiBO,CAAc,GAC9B,GAI7B,GAHA,QAAQ,IAAI,oCAAqCb,CAAa,EAG1D/B,GAASA,EAAM,OAAS,EAAG,CAC7B,QAAQ,IAAI,kCAAmC+B,CAAa,EAC5D,MAAMG,EAAiB,MAAMzC,EAAY,uBACvCf,EACAqD,EACAO,EAAgB,iBAChBA,EAAgB,OAChBtC,CAAA,EAEF,QAAQ,IAAI,iBAAkBkC,CAAc,CAC9C,CAEA,OAAOH,CACT,OAASY,EAAO,CACd,cAAQ,MAAM,8BAA+BA,CAAK,EAC5CA,CACR,CACF,EAGA,MAAM,kBAAkBjE,EAAmBqD,EAAuB7C,EAA8C,CAC9G,MAAMqD,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EAG7Ec,EAAoB,CAAE,GAAG3D,CAAA,EAG3B2D,EAAa,SAAW,aAAeA,EAAa,qBAAuB,SAC7EA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,qBAAuB,KACtCA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,oBAAsBA,EAAa,SAAW,cAE7DA,EAAa,OAAS,WAGxB,MAAM1D,EAAUoD,EAAgBM,CAAY,CAC9C,EAGA,MAAM,kBAAkBnE,EAAmBqD,EAAsC,CAC/E,MAAMQ,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EACnF,MAAM3C,EAAUmD,CAAc,CAChC,EAGA,wBAAwB7D,EAAmBW,EAAiD,CAC1F,MAAMgD,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtEP,EAAIC,EAAMiE,EAAiBhE,EAAQ,aAAc,MAAM,CAAC,EAE9D,OAAOiB,EAAWnB,EAAIoB,GAAa,CACjC,MAAMwD,EAAexD,EAAS,KAAK,IAAIhB,GAAO,CAC5C,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnC+D,EAAkB,CACtB,GAAG9D,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAG+D,CAAA,CAEP,CAAC,EACDjD,EAAS0D,CAAY,CACvB,CAAC,CACH,EAGA,uBACErE,EACAqD,EACA1C,EACA,CACA,MAAMkD,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EAEnF,OAAOzC,EAAWiD,EAAiBhE,GAAQ,CACzC,GAAIA,EAAI,SAAU,CAChB,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEzC,QAAQ,IAAI,yCAA0CC,CAAI,EAC1D,QAAQ,IAAI,mDAAoDA,EAAK,kBAAkB,EAEvF,MAAM8D,EAAkB,CACtB,GAAG9D,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,QAAQ,IAAI,0DAA2D8D,CAAe,EAEtF,MAAMI,EAAc,CAClB,eAAgBnE,EAAI,GACpB,GAAG+D,CAAA,EAELjD,EAASqD,CAAW,CACtB,MACErD,EAAS,IAAI,CAEjB,CAAC,CACH,EAGA,MAAM,uBAAuBX,EAA2C,CACtE,MAAM2D,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtEP,EAAIC,EACRiE,EACAxC,EAAM,SAAU,KAAM,SAAS,EAC/BxB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnC+D,EAAkB,CACtB,GAAG9D,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAG+D,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,wBACJ5D,EACAqD,EACAiB,EACA9D,EACe,CACf,MAAMqD,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EAE7EkB,EAAkB,CACtB,OAAAD,EACA,GAAG9D,CAAA,EAID8D,IAAW,aAAe,EAAC9D,GAAA,MAAAA,EAAS,oBACtC+D,EAAW,iBAAmB,IAAI,KAAA,EAAO,YAAA,GAG3C,MAAM9D,EAAUoD,EAAgBU,CAAU,CAC5C,CACF,EAGaC,EAA2B,CAEtC,MAAM,0BACJxD,EACAC,EACkC,CAClC,MAAMC,EAAW3B,EAAWC,EAAI,oBAAoB,EACpD,IAAIC,EAAIC,EAAMwB,CAAQ,EAGlBF,GAAA,MAAAA,EAAS,SACXvB,EAAIC,EAAMD,EAAG0B,EAAM,mBAAoB,KAAMH,EAAQ,MAAM,CAAC,GAI9DvB,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCsB,IACFxB,EAAIC,EAAMD,EAAG4B,EAAMJ,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBxB,EAAIC,EAAMD,EAAG4B,EAAMJ,EAAW,KAAOA,EAAW,KAAK,CAAC,IAM1D,IAAIK,GAFkB,MAAM1B,EAAQH,CAAC,GAEX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACa,EAG3B,GAAImB,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMI,EAAaJ,EAAQ,YAAY,YAAA,EACvCM,EAAQA,EAAM,OAAOC,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASH,CAAU,GAClDG,EAAK,OAAO,YAAA,EAAc,SAASH,CAAU,GAC7CG,EAAK,IAAI,YAAA,EAAc,SAASH,CAAU,KAC1CO,EAAAJ,EAAK,8BAAL,YAAAI,EAAkC,cAAc,SAASP,IAAU,CAEvE,CAEA,OAAOE,CACT,EAGA,MAAM,yBAAyBE,EAAuD,CACpF,MAAMC,EAAU5B,EAAIL,EAAI,qBAAsBgC,CAAM,EAC9CE,EAAW,MAAMvB,EAAOsB,CAAO,EAErC,OAAIC,EAAS,SACJ,CACL,QAASA,EAAS,GAClB,GAAGA,EAAS,KAAA,CAAK,EAGd,IACT,EAGA,MAAM,+BAA+BmB,EAAyC,CAE5E,MAAMC,EAAe,MAAM,KAAK,yBAAyBD,CAAc,EACvE,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,4CAA4C,EAG9D,MAAMzC,MAAU,KACV0C,EAAY,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACvEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,OAAS,GAC7B,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,iBAAkB,YAClB,mBAAoB,OACpB,4BAA6BF,EAAa,6BAA+B,GACzE,uBAAwB,OACxB,eAAgBA,EAAa,eAC7B,aAAczC,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQyC,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQC,GAAO,CACrCD,EAAeC,CAAG,IAAM,QAC1B,OAAOD,EAAeC,CAAG,CAE7B,CAAC,EAGD,MAAMzB,EAAU5B,EAAIL,EAAI,qBAAsBuD,CAAS,EACvD,aAAMI,EAAO1B,EAASwB,CAAc,EAE7BF,CACT,EAGA,MAAM,4BAA4BjB,EAAqG,CACrI,MAAMZ,EAAW3B,EAAWC,EAAI,oBAAoB,EAC9Ca,MAAU,KAEV0B,EAAU,CACd,GAAGD,EACH,iBAAkBA,EAAS,kBAAoB,YAC/C,aAAczB,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAIhC,OADe,MAAME,EAAOW,EAAUa,CAAO,GAC/B,EAChB,EAGA,MAAM,4BAA4BP,EAAgBhB,EAAwD,CACxG,MAAMiB,EAAU5B,EAAIL,EAAI,qBAAsBgC,CAAM,EAE9CS,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCzB,EAAQ,mBAAqB,SAAWyB,EAAgB,iBAAmBzB,EAAQ,kBACnFA,EAAQ,qBAAuB,SAAWyB,EAAgB,mBAAqBzB,EAAQ,oBACvFA,EAAQ,8BAAgC,SAAWyB,EAAgB,4BAA8BzB,EAAQ,6BACzGA,EAAQ,yBAA2B,SAAWyB,EAAgB,uBAAyBzB,EAAQ,wBAC/FA,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWyB,EAAgB,cAAgBzB,EAAQ,eAC7EA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,SAAW,SAAWyB,EAAgB,OAASzB,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWyB,EAAgB,IAAMzB,EAAQ,KACzDA,EAAQ,eAAiB,SAAWyB,EAAgB,aAAezB,EAAQ,cAC3EA,EAAQ,iBAAmB,SAAWyB,EAAgB,eAAiBzB,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWyB,EAAgB,YAAczB,EAAQ,aACzEA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,QAAU,SAAWyB,EAAgB,MAAQzB,EAAQ,OAC7DA,EAAQ,WAAa,SAAWyB,EAAgB,SAAWzB,EAAQ,UACnEA,EAAQ,SAAW,SAAWyB,EAAgB,OAASzB,EAAQ,QAEnE,MAAMC,EAAUgB,EAASQ,CAAe,CAC1C,EAGA,MAAM,4BAA4BT,EAA+B,CAC/D,MAAMC,EAAU5B,EAAIL,EAAI,qBAAsBgC,CAAM,EACpD,MAAMd,EAAUe,CAAO,CACzB,EAGA,MAAM,2BAA6D,CACjE,MAAMP,EAAW3B,EAAWC,EAAI,oBAAoB,EAC9CqB,EAAW,MAAM0B,EAAmBrB,CAAQ,EAE5CuD,EAAgB/E,EAAMwB,CAAQ,EAC9BwD,EAAe,MAAM9E,EAAQ6E,CAAa,EAEhD,IAAIE,EAAiB,EACjBC,EAAe,EACfC,EAAY,EAEhB,OAAAH,EAAa,KAAK,QAAQ7E,GAAO,CAE/B,OADaA,EAAI,KAAA,EACJ,iBAAA,CACX,IAAK,YACH8E,IACA,MACF,IAAK,UACHC,IACA,MACF,IAAK,OACHC,IACA,KAAA,CAEN,CAAC,EAEM,CACL,WAAYhE,EAAS,KAAA,EAAO,MAC5B,eAAA8D,EACA,aAAAC,EACA,UAAAC,CAAA,CAEJ,EAGA,6BACElE,EACAK,EACA,CACA,MAAME,EAAW3B,EAAWC,EAAI,oBAAoB,EACpD,IAAIC,EAAIC,EAAMwB,EAAUvB,EAAQ,eAAgB,MAAM,CAAC,EAEvD,OAAIqB,GAAA,MAAAA,EAAS,SACXvB,EAAIC,EAAMD,EAAG0B,EAAM,mBAAoB,KAAMH,EAAQ,MAAM,CAAC,GAGvDJ,EAAWnB,EAAIoB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAIhB,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACa,EAG3B,GAAImB,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMI,EAAaJ,EAAQ,YAAY,YAAA,EACvCM,EAAQA,EAAM,OAAOC,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASH,CAAU,GAClDG,EAAK,OAAO,YAAA,EAAc,SAASH,CAAU,GAC7CG,EAAK,IAAI,YAAA,EAAc,SAASH,CAAU,KAC1CO,EAAAJ,EAAK,8BAAL,YAAAI,EAAkC,cAAc,SAASP,IAAU,CAEvE,CAEAT,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,sBACJE,EACAxB,EACA8E,EACAC,EACiB,CAEjB,MAAMnB,EAAkB,CACtB,WAAY5D,EACZ,iBAAkB,IAAI,KAAA,EAAO,YAAA,EAC7B,OAAQ,uBACR,iBAAkB,gBAClB,eAAgB,UAChB,OAAA8E,EACA,gBAAiB,cACjB,MAAOC,GAAS,yCAChB,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXpB,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtE6D,EAAiB,MAAMtD,EAAOoD,EAAiBC,CAAe,EAGpE,aAAM,KAAK,4BAA4BpC,EAAQ,CAC7C,iBAAkB,UAClB,mBAAoBxB,EACpB,uBAAwB6D,EAAe,EAAA,CACxC,EAEMA,EAAe,EACxB,EAGA,MAAM,4BACJmB,EACAhF,EACAiF,EAII,CAAA,EACe,CACnB,MAAMvC,EAAQC,EAAWnD,CAAE,EACrB0F,EAA2B,CAAA,EAC3B7E,MAAU,KAGV8E,EAAmB5F,EAAWC,EAAI,oBAAoB,EACtD4F,EAAqB1F,EAAMyF,EAAkBhE,EAAM,WAAY,KAAM6D,CAAO,CAAC,EAC7EK,EAAwB,MAAMzF,EAAQwF,CAAkB,EAE9D,GAAIC,EAAsB,MACxB,MAAM,IAAI,MAAM,mCAAmC,EAIrD,MAAMzB,EAAkB,CACtB,WAAY5D,EACZ,iBAAkBK,EAAI,YAAA,EACtB,OAAQ,6BACR,iBAAkB,gBAClB,eAAgB,UAChB,OAAQ4E,EAAe,QAAU,OACjC,gBAAiB,cACjB,MAAOA,EAAe,OAAS,uBAAuBD,EAAQ,MAAM,iCACpE,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXrB,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtE6D,EAAiBhE,EAAI8D,CAAe,EAC1CjB,EAAM,IAAImB,EAAgBD,CAAe,EACzCsB,EAAe,KAAKrB,EAAe,EAAE,EAGrCwB,EAAsB,KAAK,QAASC,GAAoB,CACtD,MAAMC,EAAmBD,EAAgB,KAAA,EAGnCE,EAAgB,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAC1EC,EAAiB5F,EAAIL,EAAI,WAAYQ,EAAW,QAASwF,CAAa,EAEtEE,EAAkB,CACtB,QAASF,EACT,YAAaD,EAAiB,YAC9B,OAAQA,EAAiB,OACzB,IAAKA,EAAiB,IACtB,cAAeA,EAAiB,cAChC,aAAcA,EAAiB,cAAgB,GAC/C,eAAgB,OAChB,YAAa,OACb,MAAOA,EAAiB,OAAS,GACjC,MAAON,EAAe,OAAS,GAC/B,OAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACnE,SAAU,GACV,eAAgBpB,EAAe,GAC/B,WAAY7D,EACZ,aAAcuF,EAAiB,aAC/B,aAAclF,EAAI,YAAA,EAClB,OAAQkF,EAAiB,QAAU,CAAA,CAAC,EAGtC7C,EAAM,IAAI+C,EAAgBC,CAAe,CAC3C,CAAC,EAGDV,EAAQ,QAAQxD,GAAU,CACxB,MAAMC,EAAU5B,EAAIL,EAAI,qBAAsBgC,CAAM,EACpDkB,EAAM,OAAOjB,EAAS,CACpB,iBAAkB,OAClB,mBAAoBzB,EACpB,uBAAwB6D,EAAe,GACvC,aAAcxD,EAAI,YAAA,CAAY,CAC/B,CACH,CAAC,EAED,MAAMqC,EAAM,OAAA,EAGZ,MAAMiD,EAAmB,MAAM5E,EAAY,aAAaf,CAAS,EACjE,aAAMZ,EAAe,cAAcY,EAAW,CAC5C,SAAU,CACR,WAAY2F,EACZ,aAActF,CAAA,CAChB,CACmB,EAEd6E,CACT,EAGA,MAAM,sBAAsB1D,EAAgB6B,EAAuBrD,EAAkC,CAEnG,MAAM6D,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EACnF,MAAM5C,EAAUoD,EAAgB,CAC9B,OAAQ,WAAA,CACT,EAGD,MAAM,KAAK,4BAA4BrC,EAAQ,CAC7C,iBAAkB,YAClB,mBAAoB,OACpB,uBAAwB,MAAA,CACzB,CACH,EAGA,MAAM,eACJA,EACA6B,EACArD,EACA4F,EACe,CAEf,MAAM/B,EAAiBhE,EAAIL,EAAI,WAAYQ,EAAW,eAAgBqD,CAAa,EACnF,MAAM5C,EAAUoD,EAAgB,CAC9B,OAAQ,YACR,iBAAkB,IAAI,KAAA,EAAO,YAAA,EAC7B,eAAgB+B,CAAA,CACjB,EAGD,MAAM,KAAK,4BAA4BpE,EAAQ,CAC7C,iBAAkB,OAClB,mBAAoB,OACpB,uBAAwB,MAAA,CACzB,CACH,EAGA,MAAM,4BACJA,EACAxB,EACA8E,EACAC,EACiB,CAEjB,MAAMc,EAAkBtG,EAAWC,EAAI,WAAYQ,EAAW,OAAO,EAC/D8F,EAAYpG,EAAMmG,EAAiB1E,EAAM,UAAW,KAAMK,CAAM,CAAC,EACjEE,EAAW,MAAM9B,EAAQkG,CAAS,EAExC,GAAIpE,EAAS,MACX,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAMI,EAAWJ,EAAS,KAAK,CAAC,EAAE,KAAA,EAG5BkC,EAAkB,CACtB,WAAY5D,EACZ,iBAAkB,IAAI,KAAA,EAAO,YAAA,EAC7B,OAAQ,kBACR,iBAAkB,gBAClB,eAAgB,UAChB,OAAA8E,EACA,gBAAiB,cACjB,MAAOC,GAAS,oDAChB,WAAY,SACZ,OAAQ,UACR,mBAAoB,SACpB,cAAe,sBAAA,EAGXpB,EAAkBpE,EAAWC,EAAI,WAAYQ,EAAW,cAAc,EACtE6D,EAAiB,MAAMtD,EAAOoD,EAAiBC,CAAe,EAG9DmC,EAAkB,CACtB,YAAajE,EAAS,YACtB,OAAQA,EAAS,OACjB,IAAKA,EAAS,IACd,MAAOA,EAAS,MAChB,aAAcA,EAAS,aACvB,eAAgBA,EAAS,eACzB,YAAaA,EAAS,aAAe,OACrC,MAAOA,EAAS,MAChB,MAAOA,EAAS,MAChB,OAAQA,EAAS,OACjB,SAAUA,EAAS,UAAY,GAC/B,iBAAkB,YAClB,4BAA6B,8BAC7B,eAAgB+B,EAAe,GAC/B,OAAQ/B,EAAS,QAAU,CAAA,CAAC,EAG9B,aAAM,KAAK,4BAA4BiE,CAAe,EAGtD,MAAMrF,EAAUgB,EAAS,KAAK,CAAC,EAAE,GAAG,EAE7BmC,EAAe,EACxB,CACF"}