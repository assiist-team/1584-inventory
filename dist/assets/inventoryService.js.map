{"version":3,"file":"inventoryService.js","sources":["../../src/utils/dateUtils.ts","../../src/services/lineageService.ts","../../src/services/inventoryService.ts"],"sourcesContent":["import type { DateValue } from '@/types'\n\n/**\n * Safely converts various date representations to JavaScript Date objects\n */\nexport const toDate = (value: DateValue): Date | null => {\n  if (!value) return null\n\n  if (value instanceof Date) {\n    return value\n  }\n\n  // Handle various date formats including legacy timestamp objects\n  if (typeof value === 'object' && value) {\n    // Check if it's a legacy timestamp object with toDate method\n    if ('toDate' in value && typeof (value as any).toDate === 'function') {\n      try {\n        return (value as any).toDate()\n      } catch (error) {\n        console.warn('Failed to convert timestamp to Date:', error)\n        return null\n      }\n    }\n\n    // Check if it's a legacy timestamp object with seconds/nanoseconds\n    if ('seconds' in value && 'nanoseconds' in value) {\n      try {\n        return new Date((value as any).seconds * 1000 + (value as any).nanoseconds / 1000000)\n      } catch (error) {\n        console.warn('Failed to convert timestamp to Date:', error)\n        return null\n      }\n    }\n  }\n\n  // Handle string dates\n  if (typeof value === 'string') {\n    try {\n      // Check if it's a date-only string (YYYY-MM-DD format)\n      // This avoids timezone conversion issues by parsing as local time\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        // Parse as local date to avoid timezone conversion\n        const [year, month, day] = value.split('-').map(Number)\n        const date = new Date(year, month - 1, day) // month is 0-indexed\n        return isNaN(date.getTime()) ? null : date\n      }\n\n      // For other date formats, use the original parsing\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to parse date string:', value, error)\n      return null\n    }\n  }\n\n  // Handle number (milliseconds since epoch)\n  if (typeof value === 'number') {\n    try {\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to convert number to Date:', value, error)\n      return null\n    }\n  }\n\n  return null\n}\n\n/**\n * Safely formats a date value to a localized string\n */\nexport const formatDate = (\n  value: DateValue,\n  fallback: string = 'Unknown',\n  options?: Intl.DateTimeFormatOptions\n): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value with specific options\n */\nexport const formatDateTime = (value: DateValue, options?: Intl.DateTimeFormatOptions, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value as a time string\n */\nexport const formatTime = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  } catch (error) {\n    console.warn('Failed to format time:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Checks if a date value is valid\n */\nexport const isValidDate = (value: DateValue): boolean => {\n  return toDate(value) !== null\n}\n\n/**\n * Formats a currency amount with proper thousands separators and decimal places\n */\nexport const formatCurrency = (amount: string | number, fallback: string = '$0.00'): string => {\n  const num = typeof amount === 'string' ? parseFloat(amount) : amount\n\n  if (isNaN(num)) return fallback\n\n  return num.toLocaleString('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Formats a number with thousands separators (no currency symbol)\n */\nexport const formatNumber = (num: string | number, fallback: string = '0.00'): string => {\n  const value = typeof num === 'string' ? parseFloat(num) : num\n\n  if (isNaN(value)) return fallback\n\n  return value.toLocaleString('en-US', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Returns today's date as a date-only string in YYYY-MM-DD format (local time)\n */\nexport const getTodayDateString = (): string => {\n  const now = new Date()\n  const yyyy = now.getFullYear()\n  const mm = String(now.getMonth() + 1).padStart(2, '0')\n  const dd = String(now.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n/**\n * Converts an input date value to a date-only string (YYYY-MM-DD) if possible.\n * Returns an empty string when conversion fails or value is falsy.\n */\nexport const toDateOnlyString = (value: DateValue): string => {\n  if (!value) return ''\n  // Already a date-only string\n  if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n    return value\n  }\n  const d = toDate(value)\n  if (!d) return ''\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n","import { supabase, getCurrentUser } from './supabase'\nimport { ensureAuthenticatedForDatabase } from './databaseService'\nimport type { ItemLineageEdge } from '@/types'\n\n/**\n * Centralized service for managing item lineage edges.\n * Provides idempotent edge creation and enforces single-path invariants.\n */\nexport const lineageService = {\n  /**\n   * Append a lineage edge for an item move.\n   * Includes idempotency checks to prevent duplicate edges.\n   * \n   * @param accountId - Account ID\n   * @param itemId - Item ID\n   * @param fromTransactionId - Source transaction (null = from inventory)\n   * @param toTransactionId - Destination transaction (null = to inventory)\n   * @param note - Optional note about the move\n   * @returns The created edge, or null if skipped due to idempotency\n   */\n  async appendItemLineageEdge(\n    accountId: string,\n    itemId: string,\n    fromTransactionId: string | null,\n    toTransactionId: string | null,\n    note?: string | null\n  ): Promise<ItemLineageEdge | null> {\n    await ensureAuthenticatedForDatabase()\n\n    // Skip if from === to (no-op move)\n    if (fromTransactionId === toTransactionId) {\n      console.log('‚è≠Ô∏è Skipping lineage edge: from === to', { itemId, fromTransactionId, toTransactionId })\n      return null\n    }\n\n    // Get current user for created_by\n    const user = await getCurrentUser()\n    const createdBy = user?.id || null\n\n    // Idempotency check: check if a similar edge was created recently (within last 5 seconds)\n    // This prevents duplicate edges from rapid repeated calls\n    const fiveSecondsAgo = new Date(Date.now() - 5000).toISOString()\n    const { data: recentEdges } = await supabase\n      .from('item_lineage_edges')\n      .select('id, created_at')\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n      .eq('from_transaction_id', fromTransactionId ?? null)\n      .eq('to_transaction_id', toTransactionId ?? null)\n      .gte('created_at', fiveSecondsAgo)\n      .order('created_at', { ascending: false })\n      .limit(1)\n\n    if (recentEdges && recentEdges.length > 0) {\n      console.log('‚è≠Ô∏è Skipping duplicate lineage edge (recent match found)', {\n        itemId,\n        fromTransactionId,\n        toTransactionId,\n        existingEdgeId: recentEdges[0].id\n      })\n      // Return the existing edge converted to our type\n      const existing = await this.getLineageEdgeById(recentEdges[0].id)\n      return existing\n    }\n\n    // Insert the new edge\n    const { data, error } = await supabase\n      .from('item_lineage_edges')\n      .insert({\n        account_id: accountId,\n        item_id: itemId,\n        from_transaction_id: fromTransactionId ?? null,\n        to_transaction_id: toTransactionId ?? null,\n        created_by: createdBy,\n        note: note ?? null\n      })\n      .select()\n      .single()\n\n    if (error) {\n      // Treat missing-table / PostgREST schema-cache errors as non-fatal.\n      // These commonly appear as PGRST205 or 404 when the REST layer hasn't\n      // reloaded schema after a migration. Surface a clear console message\n      // linking to the troubleshooting doc so operators can remediate quickly.\n      const isMissingTableError =\n        error?.code === 'PGRST205' ||\n        error?.status === 404 ||\n        (typeof error?.message === 'string' &&\n          error.message.includes(\"Could not find the table\"))\n\n      if (isMissingTableError) {\n        console.warn(\n          '‚ö†Ô∏è Lineage table not found / PostgREST schema cache issue. Lineage writes are non-fatal while the migration is pending.'\n        )\n        console.warn(\n          'Read dev_docs/troubleshooting/transaction-lineage-troubleshooting.md for diagnostic steps and remediation.'\n        )\n        console.debug('Lineage append error details:', error)\n        // Return null to indicate no edge was created, but allow the higher-level\n        // flow to proceed (deallocation etc. should still complete).\n        return null\n      }\n\n      console.error('‚ùå Failed to append lineage edge:', error)\n      throw error\n    }\n\n    console.log('‚úÖ Lineage edge appended:', {\n      itemId,\n      fromTransactionId,\n      toTransactionId,\n      edgeId: data.id\n    })\n\n    return this._convertEdgeFromDb(data)\n  },\n\n  /**\n   * Update the latest_transaction_id pointer on an item.\n   * Also updates origin_transaction_id if it's not already set.\n   * \n   * @param accountId - Account ID\n   * @param itemId - Item ID\n   * @param latestTransactionId - New latest transaction ID (null = in inventory)\n   * @param originTransactionId - Optional origin transaction ID (only set if not already set)\n   */\n  async updateItemLineagePointers(\n    accountId: string,\n    itemId: string,\n    latestTransactionId: string | null,\n    originTransactionId?: string | null\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const updates: any = {\n      latest_transaction_id: latestTransactionId ?? null\n    }\n\n    // Only set origin_transaction_id if it's not already set and we have a value\n    if (originTransactionId !== undefined) {\n      // Check current value first\n      const { data: currentItem } = await supabase\n        .from('items')\n        .select('origin_transaction_id')\n        .eq('account_id', accountId)\n        .eq('item_id', itemId)\n        .single()\n\n      if (!currentItem?.origin_transaction_id && originTransactionId) {\n        updates.origin_transaction_id = originTransactionId\n      }\n    }\n\n    const { error } = await supabase\n      .from('items')\n      .update(updates)\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n\n    if (error) {\n      console.error('‚ùå Failed to update item lineage pointers:', error)\n      throw error\n    }\n\n    console.log('‚úÖ Updated item lineage pointers:', {\n      itemId,\n      latestTransactionId,\n      originTransactionId: updates.origin_transaction_id\n    })\n  },\n\n  /**\n   * Get all lineage edges for an item (ordered by creation time).\n   * Used for reconstructing the full history path.\n   */\n  async getItemLineageHistory(itemId: string, accountId: string): Promise<ItemLineageEdge[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('item_lineage_edges')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n      .order('created_at', { ascending: true })\n\n    if (error) {\n      console.error('‚ùå Failed to fetch item lineage history:', error)\n      throw error\n    }\n\n    return (data || []).map(edge => this._convertEdgeFromDb(edge))\n  },\n\n  /**\n   * Get edges that moved FROM a specific transaction.\n   * Used to find items that \"moved out\" of a transaction.\n   */\n  async getEdgesFromTransaction(transactionId: string, accountId: string): Promise<ItemLineageEdge[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('item_lineage_edges')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('from_transaction_id', transactionId)\n      .order('created_at', { ascending: true })\n\n    if (error) {\n      console.error('‚ùå Failed to fetch edges from transaction:', error)\n      throw error\n    }\n\n    return (data || []).map(edge => this._convertEdgeFromDb(edge))\n  },\n\n  /**\n   * Get a single lineage edge by ID.\n   */\n  async getLineageEdgeById(edgeId: string): Promise<ItemLineageEdge | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('item_lineage_edges')\n      .select('*')\n      .eq('id', edgeId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      console.error('‚ùå Failed to fetch lineage edge:', error)\n      throw error\n    }\n\n    return data ? this._convertEdgeFromDb(data) : null\n  },\n\n  /**\n   * Subscribe to lineage edge INSERTs for a specific item (or broader filters).\n   * Returns an unsubscribe function.\n   *\n   * @param accountId - Account ID to scope subscription\n   * @param itemId - Optional itemId to narrow subscription to a single item\n   * @param callback - Receives newly inserted edge (converted to app type)\n   */\n  subscribeToItemLineageForItem(\n    accountId: string,\n    itemId: string | undefined,\n    callback: (edge: ItemLineageEdge) => void\n  ): () => void {\n    const filterParts = [`account_id=eq.${accountId}`]\n    if (itemId) {\n      filterParts.push(`item_id=eq.${itemId}`)\n    }\n    const filter = filterParts.join(',')\n\n    const channelName = `item_lineage:${accountId}${itemId ? `:${itemId}` : ''}`\n    const channel = supabase\n      .channel(channelName)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'item_lineage_edges',\n          filter\n        },\n        (payload: any) => {\n          try {\n            const edge = this._convertEdgeFromDb(payload.new)\n            callback(edge)\n          } catch (err) {\n            console.debug('lineageService.subscribeToItemLineageForItem - callback error', err)\n          }\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to item_lineage_edges channel', channelName)\n        }\n        if (err) {\n          console.error('Error subscribing to item_lineage_edges channel', err)\n        }\n      })\n\n    return () => {\n      try {\n        channel.unsubscribe()\n      } catch (err) {\n        console.debug('Failed to unsubscribe from lineage channel', err)\n      }\n    }\n  },\n  /**\n   * Subscribe to lineage edge INSERTs where from_transaction_id == given transactionId.\n   * Useful for transaction-level views that need to know when items moved out.\n   * Returns an unsubscribe function.\n   */\n  subscribeToEdgesFromTransaction(\n    accountId: string,\n    fromTransactionId: string,\n    callback: (edge: ItemLineageEdge) => void\n  ): () => void {\n    const filter = `account_id=eq.${accountId},from_transaction_id=eq.${fromTransactionId}`\n\n    const channelName = `item_lineage:from_tx:${accountId}:${fromTransactionId}`\n    const channel = supabase\n      .channel(channelName)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'item_lineage_edges',\n          filter\n        },\n        (payload: any) => {\n          try {\n            const edge = this._convertEdgeFromDb(payload.new)\n            callback(edge)\n          } catch (err) {\n            console.debug('lineageService.subscribeToEdgesFromTransaction - callback error', err)\n          }\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to item_lineage_edges from_transaction channel', channelName)\n        }\n        if (err) {\n          console.error('Error subscribing to item_lineage_edges from_transaction channel', err)\n        }\n      })\n\n    return () => {\n      try {\n        channel.unsubscribe()\n      } catch (err) {\n        console.debug('Failed to unsubscribe from lineage from_tx channel', err)\n      }\n    }\n  },\n\n  /**\n   * Helper to convert database edge (snake_case) to app format (camelCase).\n   */\n  _convertEdgeFromDb(dbEdge: any): ItemLineageEdge {\n    return {\n      id: dbEdge.id,\n      accountId: dbEdge.account_id,\n      itemId: dbEdge.item_id,\n      fromTransactionId: dbEdge.from_transaction_id ?? null,\n      toTransactionId: dbEdge.to_transaction_id ?? null,\n      createdAt: dbEdge.created_at,\n      createdBy: dbEdge.created_by ?? null,\n      note: dbEdge.note ?? null\n    }\n  }\n}\n\n","import { supabase, getCurrentUser } from './supabase'\nimport { convertTimestamps, ensureAuthenticatedForDatabase } from './databaseService'\nimport { toDateOnlyString } from '@/utils/dateUtils'\nimport { getTaxPresetById } from './taxPresetsService'\nimport { CLIENT_OWES_COMPANY, COMPANY_OWES_CLIENT } from '@/constants/company'\nimport { lineageService } from './lineageService'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, TransactionCompleteness, CompletenessStatus } from '@/types'\n\n// Audit Logging Service for allocation/de-allocation events\nexport const auditService = {\n  // Log allocation/de-allocation events\n  async logAllocationEvent(\n    accountId: string,\n    eventType: 'allocation' | 'deallocation' | 'return',\n    itemId: string,\n    projectId: string | null,\n    transactionIdOrDetails: any,\n    detailsOrUndefined?: Record<string, any>\n  ): Promise<void> {\n    try {\n      // Handle different calling patterns\n      let transactionId: string | null | undefined = null\n      let details: Record<string, any> = {}\n\n      if (typeof transactionIdOrDetails === 'string') {\n        transactionId = transactionIdOrDetails\n        details = detailsOrUndefined || {}\n      } else {\n        transactionId = null\n        details = transactionIdOrDetails || {}\n      }\n\n      const { error } = await supabase\n        .from('audit_logs')\n        .insert({\n          account_id: accountId,\n          event_type: eventType,\n          item_id: itemId,\n          project_id: projectId,\n          transaction_id: transactionId,\n          details: details,\n          timestamp: new Date().toISOString(),\n          created_at: new Date().toISOString()\n        })\n\n      if (error) {\n        console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      } else {\n        console.log(`üìã Audit logged: ${eventType} for item ${itemId}`)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  },\n\n  // Log transaction state changes\n  async logTransactionStateChange(\n    accountId: string,\n    transactionId: string,\n    changeType: 'created' | 'updated' | 'deleted',\n    oldState?: any,\n    newState?: any\n  ): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('transaction_audit_logs')\n        .insert({\n          account_id: accountId,\n          transaction_id: transactionId,\n          change_type: changeType,\n          old_state: oldState || null,\n          new_state: newState || null,\n          timestamp: new Date().toISOString(),\n          created_at: new Date().toISOString()\n        })\n\n      if (error) {\n        console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      } else {\n        console.log(`üìã Transaction audit logged: ${changeType} for ${transactionId}`)\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  }\n}\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current account\n  async getProjects(accountId: string): Promise<Project[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .select('*')\n      .eq('account_id', accountId)\n      .order('updated_at', { ascending: false })\n\n    if (error) throw error\n\n    return (data || []).map(project => {\n      const converted = convertTimestamps(project)\n      return {\n        id: converted.id,\n        accountId: converted.account_id,\n        name: converted.name,\n        description: converted.description || '',\n        clientName: converted.client_name || '',\n        budget: converted.budget ? parseFloat(converted.budget) : undefined,\n        designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n        budgetCategories: converted.budget_categories || undefined,\n        createdAt: converted.created_at,\n        updatedAt: converted.updated_at,\n        createdBy: converted.created_by,\n        settings: converted.settings || undefined,\n        metadata: converted.metadata || undefined,\n        itemCount: converted.item_count || 0,\n        transactionCount: converted.transaction_count || 0,\n        totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(accountId: string, projectId: string): Promise<Project | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .select('*')\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      description: converted.description || '',\n      clientName: converted.client_name || '',\n      budget: converted.budget ? parseFloat(converted.budget) : undefined,\n      designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n      budgetCategories: converted.budget_categories || undefined,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at,\n      createdBy: converted.created_by,\n      settings: converted.settings || undefined,\n      metadata: converted.metadata || undefined,\n      itemCount: converted.item_count || 0,\n      transactionCount: converted.transaction_count || 0,\n      totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n    } as Project\n  },\n\n  // Create new project\n  async createProject(accountId: string, projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('projects')\n      .insert({\n        account_id: accountId,\n        name: projectData.name,\n        description: projectData.description || null,\n        client_name: projectData.clientName || null,\n        budget: projectData.budget || null,\n        design_fee: projectData.designFee || null,\n        budget_categories: projectData.budgetCategories || {},\n        settings: projectData.settings || {},\n        metadata: projectData.metadata || {},\n        created_by: projectData.createdBy,\n        item_count: 0,\n        transaction_count: 0,\n        total_value: 0,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      })\n      .select('id')\n      .single()\n\n    if (error) throw error\n    return data.id\n  },\n\n  // Update project\n  async updateProject(accountId: string, projectId: string, updates: Partial<Project>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const updateData: any = {\n      updated_at: new Date().toISOString()\n    }\n\n    if (updates.name !== undefined) updateData.name = updates.name\n    if (updates.description !== undefined) updateData.description = updates.description\n    if (updates.clientName !== undefined) updateData.client_name = updates.clientName\n    if (updates.budget !== undefined) updateData.budget = updates.budget\n    if (updates.designFee !== undefined) updateData.design_fee = updates.designFee\n    if (updates.budgetCategories !== undefined) updateData.budget_categories = updates.budgetCategories\n    if (updates.settings !== undefined) updateData.settings = updates.settings\n    if (updates.metadata !== undefined) updateData.metadata = updates.metadata\n\n    const { error } = await supabase\n      .from('projects')\n      .update(updateData)\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n\n    if (error) throw error\n  },\n\n  // Delete project\n  async deleteProject(accountId: string, projectId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const { error } = await supabase\n      .from('projects')\n      .delete()\n      .eq('id', projectId)\n      .eq('account_id', accountId)\n\n    if (error) throw error\n  },\n\n  // Subscribe to projects with real-time updates\n  subscribeToProjects(\n    accountId: string,\n    callback: (projects: Project[]) => void,\n    initialProjects?: Project[]\n  ) {\n    let projects = [...(initialProjects || [])]\n\n    const channel = supabase\n      .channel(`projects:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'projects',\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Projects change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            const newProject = projectService._convertProjectFromDb(newRecord)\n            projects = [newProject, ...projects]\n          } else if (eventType === 'UPDATE') {\n            const updatedProject = projectService._convertProjectFromDb(newRecord)\n            projects = projects.map(p => p.id === updatedProject.id ? updatedProject : p)\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.id\n            projects = projects.filter(p => p.id !== oldId)\n          }\n          \n          callback([...projects])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to projects channel')\n        }\n        if (err) {\n          console.error('Error subscribing to projects channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Helper function to convert database project to Project type\n  _convertProjectFromDb(dbProject: any): Project {\n    const converted = convertTimestamps(dbProject)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      description: converted.description || '',\n      clientName: converted.client_name || '',\n      budget: converted.budget ? parseFloat(converted.budget) : undefined,\n      designFee: converted.design_fee ? parseFloat(converted.design_fee) : undefined,\n      budgetCategories: converted.budget_categories || undefined,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at,\n      createdBy: converted.created_by,\n      settings: converted.settings || undefined,\n      metadata: converted.metadata || undefined,\n      itemCount: converted.item_count || 0,\n      transactionCount: converted.transaction_count || 0,\n      totalValue: converted.total_value ? parseFloat(converted.total_value) : 0\n    } as Project\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction conversion functions\nfunction _convertTransactionFromDb(dbTransaction: any): Transaction {\n  const converted = convertTimestamps(dbTransaction)\n  return {\n    transactionId: converted.transaction_id,\n    projectId: converted.project_id || undefined,\n    projectName: converted.project_name || undefined, // May be populated by enrichment function\n    transactionDate: converted.transaction_date,\n    source: converted.source || '',\n    transactionType: converted.transaction_type || '',\n    paymentMethod: converted.payment_method || '',\n    amount: converted.amount || '0.00',\n    budgetCategory: converted.budget_category || undefined,\n    notes: converted.notes || undefined,\n    transactionImages: Array.isArray(converted.transaction_images) ? converted.transaction_images : [],\n    receiptImages: Array.isArray(converted.receipt_images) ? converted.receipt_images : [],\n    otherImages: Array.isArray(converted.other_images) ? converted.other_images : [],\n    receiptEmailed: converted.receipt_emailed || false,\n    createdAt: converted.created_at,\n    createdBy: converted.created_by || '',\n    status: converted.status || 'completed',\n    reimbursementType: converted.reimbursement_type || undefined,\n    triggerEvent: converted.trigger_event || undefined,\n    itemIds: Array.isArray(converted.item_ids) ? converted.item_ids : [],\n    taxRatePreset: converted.tax_rate_preset || undefined,\n    taxRatePct: converted.tax_rate_pct ? parseFloat(converted.tax_rate_pct) : undefined,\n    subtotal: converted.subtotal || undefined,\n    // Map DB snake_case needs_review -> camelCase needsReview for the client\n    needsReview: converted.needs_review === true,\n    // Map persisted derived sum of item purchase prices (numeric stored as string/number in DB)\n    sumItemPurchasePrices: converted.sum_item_purchase_prices !== undefined ? String(converted.sum_item_purchase_prices) : '0.00'\n  } as Transaction\n}\n\n/**\n * Enriches transactions with project names by looking them up from project_id\n * This ensures projectName is always available for display without storing it in the database\n */\nasync function _enrichTransactionsWithProjectNames(\n  accountId: string,\n  transactions: Transaction[],\n  projects?: Project[]\n): Promise<Transaction[]> {\n  // Extract unique project IDs (excluding null/undefined)\n  const projectIds = [...new Set(transactions\n    .map(tx => tx.projectId)\n    .filter((id): id is string => !!id)\n  )]\n\n  if (projectIds.length === 0) {\n    // No projects to look up, return as-is\n    return transactions\n  }\n\n  // Batch fetch all projects\n  const projectMap = new Map<string, string>()\n  try {\n    const projects = await projectService.getProjects(accountId)\n    projects.forEach(project => {\n      projectMap.set(project.id, project.name)\n    })\n  } catch (error) {\n    console.warn('Failed to fetch projects for transaction enrichment:', error)\n    // Continue without enrichment rather than failing\n  }\n\n  // Enrich transactions with project names\n  return transactions.map(tx => {\n    if (tx.projectId && !tx.projectName) {\n      const projectName = projectMap.get(tx.projectId)\n      if (projectName) {\n        return { ...tx, projectName }\n      }\n    }\n    return tx\n  })\n}\n\nfunction _convertTransactionToDb(transaction: Partial<Transaction>): any {\n  const dbTransaction: any = {}\n  \n  if (transaction.transactionId !== undefined) dbTransaction.transaction_id = transaction.transactionId\n  if (transaction.projectId !== undefined) dbTransaction.project_id = transaction.projectId ?? null\n  if (transaction.transactionDate !== undefined) dbTransaction.transaction_date = transaction.transactionDate\n  if (transaction.source !== undefined) dbTransaction.source = transaction.source\n  if (transaction.transactionType !== undefined) dbTransaction.transaction_type = transaction.transactionType\n  if (transaction.paymentMethod !== undefined) dbTransaction.payment_method = transaction.paymentMethod\n  if (transaction.amount !== undefined) dbTransaction.amount = transaction.amount\n  if (transaction.budgetCategory !== undefined) dbTransaction.budget_category = transaction.budgetCategory\n  if (transaction.notes !== undefined) dbTransaction.notes = transaction.notes\n  if (transaction.transactionImages !== undefined) dbTransaction.transaction_images = transaction.transactionImages\n  if (transaction.receiptImages !== undefined) dbTransaction.receipt_images = transaction.receiptImages\n  if (transaction.otherImages !== undefined) dbTransaction.other_images = transaction.otherImages\n  if (transaction.receiptEmailed !== undefined) dbTransaction.receipt_emailed = transaction.receiptEmailed\n  if (transaction.createdAt !== undefined) dbTransaction.created_at = transaction.createdAt\n  if (transaction.createdBy !== undefined) dbTransaction.created_by = transaction.createdBy\n  if (transaction.status !== undefined) dbTransaction.status = transaction.status\n  if (transaction.reimbursementType !== undefined) dbTransaction.reimbursement_type = transaction.reimbursementType\n  if (transaction.triggerEvent !== undefined) dbTransaction.trigger_event = transaction.triggerEvent\n  if (transaction.itemIds !== undefined) dbTransaction.item_ids = transaction.itemIds\n  if (transaction.taxRatePreset !== undefined) dbTransaction.tax_rate_preset = transaction.taxRatePreset\n  if (transaction.taxRatePct !== undefined) dbTransaction.tax_rate_pct = transaction.taxRatePct\n  if (transaction.subtotal !== undefined) dbTransaction.subtotal = transaction.subtotal\n  if (transaction.needsReview !== undefined) dbTransaction.needs_review = transaction.needsReview\n  if (transaction.sumItemPurchasePrices !== undefined) dbTransaction.sum_item_purchase_prices = transaction.sumItemPurchasePrices\n  \n  return dbTransaction\n}\n\n/**\n * Adjust the persisted sum_item_purchase_prices for a transaction.\n * Note: This implementation reads the current value then writes the adjusted value.\n * For strict atomicity prefer a DB-side RPC or function (left as an improvement).\n */\nasync function _adjustSumItemPurchasePrices(accountId: string, transactionId: string, delta: number | string): Promise<string> {\n  await ensureAuthenticatedForDatabase()\n\n  // Read current value\n  const { data, error } = await supabase\n    .from('transactions')\n    .select('sum_item_purchase_prices')\n    .eq('account_id', accountId)\n    .eq('transaction_id', transactionId)\n    .single()\n\n  if (error) throw error\n\n  const currentRaw: any = (data && (data as any).sum_item_purchase_prices) || '0'\n  const current = parseFloat(String(currentRaw) || '0')\n  const deltaNum = parseFloat(String(delta) || '0')\n  const newSum = current + deltaNum\n  const newSumStr = newSum.toFixed(2)\n\n  const { error: updateError } = await supabase\n    .from('transactions')\n    .update({ sum_item_purchase_prices: newSumStr })\n    .eq('account_id', accountId)\n    .eq('transaction_id', transactionId)\n\n  if (updateError) throw updateError\n  return newSumStr\n}\n\n// Transaction Services\nexport const transactionService = {\n  async adjustSumItemPurchasePrices(accountId: string, transactionId: string, delta: number | string): Promise<string> {\n    return await _adjustSumItemPurchasePrices(accountId, transactionId, delta)\n  },\n  async notifyTransactionChanged(accountId: string, transactionId: string, opts?: { deltaSum?: number | string; flushImmediately?: boolean }): Promise<void> {\n    // If a delta for the derived sum was provided, adjust the persisted sum first\n    if (opts && opts.deltaSum !== undefined) {\n      try {\n        await _adjustSumItemPurchasePrices(accountId, transactionId, opts.deltaSum)\n      } catch (e) {\n        console.warn('notifyTransactionChanged - failed to adjust sum_item_purchase_prices:', e)\n      }\n    }\n\n    // Enqueue recompute; if flushImmediately requested, set debounceMs = 0\n    const debounceMs = opts && opts.flushImmediately ? 0 : undefined\n    try {\n      // projectId unknown here; pass null so recompute reads transaction directly\n      if (debounceMs === 0) {\n        this._enqueueRecomputeNeedsReview(accountId, null, transactionId, 0).catch((e: any) => {\n          console.warn('Failed to recompute needs_review in notifyTransactionChanged (immediate):', e)\n        })\n      } else {\n        this._enqueueRecomputeNeedsReview(accountId, null, transactionId).catch((e: any) => {\n          console.warn('Failed to recompute needs_review in notifyTransactionChanged:', e)\n        })\n      }\n    } catch (e) {\n      console.warn('notifyTransactionChanged - enqueue failed:', e)\n    }\n  },\n  // Get transactions for a project (account-scoped)\n  async getTransactions(accountId: string, projectId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Get transactions for multiple projects (account-scoped)\n  async getTransactionsForProjects(accountId: string, projectIds: string[], projects?: Project[]): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    if (projectIds.length === 0) {\n      return []\n    }\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('project_id', projectIds)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions, projects)\n  },\n\n  // Get single transaction (account-scoped)\n  async getTransaction(accountId: string, _projectId: string, transactionId: string): Promise<Transaction | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    const transaction = _convertTransactionFromDb(data)\n    const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n    return enriched[0] || null\n  },\n\n  // Get transaction by ID across all projects (for business inventory) - account-scoped\n  async getTransactionById(accountId: string, transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (error || !data) {\n      return { transaction: null, projectId: null }\n    }\n\n    const converted = convertTimestamps(data)\n    const transaction = _convertTransactionFromDb(data)\n    const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n\n    return {\n      transaction: enriched[0] || transaction,\n      projectId: converted.project_id || null\n    }\n  },\n\n  // Calculate transaction completeness metrics\n  async getTransactionCompleteness(\n    accountId: string,\n    projectId: string,\n    transactionId: string\n  ): Promise<TransactionCompleteness> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get transaction and associated items\n    const [transaction, items] = await Promise.all([\n      this.getTransaction(accountId, projectId, transactionId),\n      unifiedItemsService.getItemsForTransaction(accountId, projectId, transactionId)\n    ])\n\n    if (!transaction) {\n      throw new Error('Transaction not found')\n    }\n\n    // Include items that were moved out of this transaction by consulting lineage edges.\n    // The UI displays both \"in transaction\" and \"moved out\" items; completeness should\n    // count both sets when the item has this transaction in its lineage.\n    let combinedItems = items.slice()\n    try {\n      const edgesFromTransaction = await lineageService.getEdgesFromTransaction(transactionId, accountId)\n      const movedOutItemIds = Array.from(new Set(edgesFromTransaction.map(edge => edge.itemId)))\n\n      // Fetch any moved item records that aren't already in the items list\n      const missingMovedItemIds = movedOutItemIds.filter(id => !combinedItems.some(it => it.itemId === id))\n      if (missingMovedItemIds.length > 0) {\n        const movedItemsPromises = missingMovedItemIds.map(id => unifiedItemsService.getItemById(accountId, id))\n        const movedItems = await Promise.all(movedItemsPromises)\n        const validMovedItems = movedItems.filter(mi => mi !== null) as Item[]\n        combinedItems = combinedItems.concat(validMovedItems)\n      }\n    } catch (edgeErr) {\n      // Non-fatal: if lineage lookup fails, fall back to items returned by getItemsForTransaction\n      console.debug('getTransactionCompleteness - failed to fetch lineage edges:', edgeErr)\n    }\n\n    // Calculate items net total (sum of purchase prices)\n    const itemsNetTotal = combinedItems.reduce((sum, item) => {\n      const purchasePrice = parseFloat(item.purchasePrice || '0')\n      return sum + (isNaN(purchasePrice) ? 0 : purchasePrice)\n    }, 0)\n\n    const itemsCount = combinedItems.length\n    const itemsMissingPriceCount = combinedItems.filter(item => {\n      const purchasePrice = item.purchasePrice\n      return !purchasePrice || purchasePrice.trim() === '' || parseFloat(purchasePrice) === 0\n    }).length\n\n    // Calculate transaction subtotal (pre-tax amount)\n    const transactionAmount = parseFloat(transaction.amount || '0')\n    let transactionSubtotal = 0\n    let inferredTax: number | undefined\n    let taxAmount: number | undefined\n    let missingTaxData = false\n\n    // If subtotal is stored, use it\n    if (transaction.subtotal) {\n      transactionSubtotal = parseFloat(transaction.subtotal)\n    } else if (transaction.taxRatePct !== undefined && transaction.taxRatePct !== null) {\n      // Infer subtotal from tax rate: subtotal = total / (1 + taxRate/100)\n      const taxRate = transaction.taxRatePct / 100\n      transactionSubtotal = transactionAmount / (1 + taxRate)\n      inferredTax = transactionAmount - transactionSubtotal\n      // Round to cents\n      transactionSubtotal = Math.round(transactionSubtotal * 100) / 100\n      inferredTax = Math.round(inferredTax * 100) / 100\n    } else {\n      // Fall back to gross total when tax data is missing\n      transactionSubtotal = transactionAmount\n      missingTaxData = true\n    }\n\n    // Calculate completeness ratio\n    // If no items, ratio is 0; if no subtotal but items exist, treat as incomplete (100% variance)\n    const completenessRatio = transactionSubtotal > 0 \n      ? itemsNetTotal / transactionSubtotal \n      : (itemsCount > 0 ? 0 : 0) // 0 when no items, 0 when no subtotal (will show as incomplete)\n\n    // Calculate variance\n    const varianceDollars = itemsNetTotal - transactionSubtotal\n    const variancePercent = transactionSubtotal > 0 \n      ? (varianceDollars / transactionSubtotal) * 100 \n      : (itemsCount > 0 ? -100 : 0) // -100% when items exist but no subtotal, 0 when no items\n\n    // Determine completeness status based on tolerance bands\n    const completenessStatus = this._calculateCompletenessStatus(completenessRatio, variancePercent)\n\n    return {\n      itemsNetTotal: Math.round(itemsNetTotal * 100) / 100,\n      itemsCount,\n      itemsMissingPriceCount,\n      transactionSubtotal: Math.round(transactionSubtotal * 100) / 100,\n      completenessRatio,\n      completenessStatus,\n      missingTaxData,\n      inferredTax,\n      taxAmount,\n      varianceDollars: Math.round(varianceDollars * 100) / 100,\n      variancePercent: Math.round(variancePercent * 100) / 100\n    }\n  },\n\n  // Helper: Calculate completeness status from ratio and variance\n  _calculateCompletenessStatus(ratio: number, variancePercent: number): CompletenessStatus {\n    // Red (over) when totals exceed 120%\n    if (ratio > 1.2) {\n      return 'over'\n    }\n    // Red (incomplete) beyond 20% variance\n    if (Math.abs(variancePercent) > 20) {\n      return 'incomplete'\n    }\n    // Yellow (near) between 1% and 20% variance (complete is now ¬±1%)\n    if (Math.abs(variancePercent) > 1) {\n      return 'near'\n    }\n    // Green (complete) when variance is within ¬±1%\n    return 'complete'\n  },\n  /**\n   * Recompute canonical completeness for a transaction and persist the boolean needs_review flag.\n   * This writes directly to the database to avoid recursive service calls.\n   */\n  async _recomputeNeedsReview(accountId: string, projectId: string | null | undefined, transactionId: string): Promise<void> {\n    try {\n      // Use canonical completeness computation\n      const completeness = await this.getTransactionCompleteness(accountId, projectId || '', transactionId)\n      const needs = completeness.completenessStatus !== 'complete'\n\n      // Persist the boolean directly to the transactions table to avoid calling updateTransaction\n      await ensureAuthenticatedForDatabase()\n      const dbUpdates: any = {\n        needs_review: needs,\n        updated_at: new Date().toISOString()\n      }\n      const { error } = await supabase\n        .from('transactions')\n        .update(dbUpdates)\n        .eq('account_id', accountId)\n        .eq('transaction_id', transactionId)\n\n      if (error) {\n        console.warn('Failed to persist needs_review for transaction', transactionId, error)\n      } else {\n        console.log(`Recomputed needs_review=${needs} for transaction ${transactionId}`)\n      }\n    } catch (err) {\n      console.warn('Failed to recompute needs_review for transaction', transactionId, err)\n    }\n  },\n  /**\n   * Debounced/coalesced enqueue for recomputing needs_review per-transaction.\n   * Coalesces rapid calls and deduplicates concurrent work to avoid N runs when many item updates occur.\n   */\n  _needsReviewTimers: {} as Record<string, any>,\n  _ongoingNeedsReviewPromises: {} as Record<string, Promise<void> | null>,\n  _enqueueCounts: {} as Record<string, number>,\n  // Dirty flag for trailing-edge single-flight behavior. If an enqueue arrives while a run\n  // is in-flight, we set dirty[key]=true and schedule a single trailing run after the\n  // in-flight run finishes.\n  _needsReviewDirty: {} as Record<string, boolean>,\n  // Per-transaction reentrant batch counters to allow top-level flows to group multiple\n  // low-level mutations into a single recompute.\n  _batchCounters: {} as Record<string, number>,\n\n  beginNeedsReviewBatch(accountId: string, transactionId: string): void {\n    const key = `${accountId}:${transactionId}`\n    this._batchCounters[key] = (this._batchCounters[key] || 0) + 1\n  },\n\n  _isBatchActive(accountId: string, transactionId: string): boolean {\n    const key = `${accountId}:${transactionId}`\n    return (this._batchCounters[key] || 0) > 0\n  },\n\n  async flushNeedsReviewBatch(accountId: string, transactionId: string, opts?: { flushImmediately?: boolean }): Promise<void> {\n    const key = `${accountId}:${transactionId}`\n    const remaining = (this._batchCounters[key] || 0) - 1\n    if (remaining <= 0) {\n      delete this._batchCounters[key]\n      try {\n        // Try to resolve projectId for the transaction so enqueue has correct context.\n        let projectId: string | null = null\n        try {\n          await ensureAuthenticatedForDatabase()\n          const { data } = await supabase\n            .from('transactions')\n            .select('project_id')\n            .eq('account_id', accountId)\n            .eq('transaction_id', transactionId)\n            .single()\n          projectId = data?.project_id ?? null\n        } catch (e) {\n          // best-effort - allow null projectId\n        }\n\n        if (opts?.flushImmediately) {\n          // Bypass debounce by using debounceMs = 0\n          this._enqueueRecomputeNeedsReview(accountId, projectId, transactionId, 0).catch((e: any) => {\n            console.warn('Failed to recompute needs_review in flushNeedsReviewBatch:', e)\n          })\n        } else {\n          this._enqueueRecomputeNeedsReview(accountId, projectId, transactionId).catch((e: any) => {\n            console.warn('Failed to recompute needs_review in flushNeedsReviewBatch:', e)\n          })\n        }\n      } catch (e) {\n        console.warn('Failed during flushNeedsReviewBatch:', e)\n      }\n    } else {\n      this._batchCounters[key] = remaining\n    }\n  },\n\n  _enqueueRecomputeNeedsReview(accountId: string, projectId: string | null | undefined, transactionId: string, debounceMs: number = 1000): Promise<void> {\n    const key = `${accountId}:${transactionId}`\n\n    // If a computation is already in-flight for this tx, mark dirty so we schedule\n    // a single trailing run when the in-flight run finishes, then return the in-flight promise.\n    if (this._ongoingNeedsReviewPromises[key]) {\n      try { this._needsReviewDirty[key] = true } catch (e) {}\n      return this._ongoingNeedsReviewPromises[key] as Promise<void>\n    }\n\n    // If a timer is already set, return a promise that will resolve when that timer's work completes.\n    if (this._needsReviewTimers[key]) {\n      // Create proxy promise that resolves when the existing ongoing promise finishes (if any).\n      const proxy = new Promise<void>((resolve, reject) => {\n        const checkInterval = setInterval(() => {\n          if (!this._needsReviewTimers[key] && !this._ongoingNeedsReviewPromises[key]) {\n            clearInterval(checkInterval)\n            resolve()\n          }\n        }, 50)\n      })\n      this._ongoingNeedsReviewPromises[key] = proxy\n      return proxy\n    }\n\n    // Instrumentation: count and log enqueue requests with timestamp and short stacktrace\n    try {\n      this._enqueueCounts[key] = (this._enqueueCounts[key] || 0) + 1\n      const count = this._enqueueCounts[key]\n      // Capture a small stack trace to find the caller (skip first two frames)\n      const stack = new Error().stack || ''\n      const shortStack = stack.split('\\n').slice(2, 6).join(' | ')\n      console.debug(`[needs_review] enqueue requested for ${transactionId} count=${count} ts=${new Date().toISOString()} caller=${shortStack}`)\n    } catch (e) {\n      // non-fatal instrumentation failure\n    }\n\n    // No existing work scheduled: create a promise and timer, store both immediately\n    let resolveFn: (() => void) | null = null\n    let rejectFn: ((e: any) => void) | null = null\n    const p = new Promise<void>((resolve, reject) => {\n      resolveFn = resolve\n      rejectFn = reject\n    })\n    this._ongoingNeedsReviewPromises[key] = p\n\n    this._needsReviewTimers[key] = setTimeout(async () => {\n      try {\n        await this._recomputeNeedsReview(accountId, projectId, transactionId)\n        resolveFn && resolveFn()\n      } catch (e) {\n        rejectFn && rejectFn(e)\n      } finally {\n        // cleanup\n        if (this._needsReviewTimers[key]) {\n          clearTimeout(this._needsReviewTimers[key])\n        }\n        delete this._needsReviewTimers[key]\n        delete this._ongoingNeedsReviewPromises[key]\n        // reset counter after work finishes\n        try { delete this._enqueueCounts[key] } catch (e) {}\n        // If a caller requested a recompute while this run was in-flight, schedule\n        // a single trailing run (short delay) and clear the dirty flag.\n        try {\n          if (this._needsReviewDirty[key]) {\n            // clear flag now to avoid duplicate trailing schedules\n            delete this._needsReviewDirty[key]\n            setTimeout(() => {\n              try {\n                this._enqueueRecomputeNeedsReview(accountId, projectId, transactionId, 25).catch((e: any) => {\n                  console.warn('Failed trailing recompute needs_review:', e)\n                })\n              } catch (e) {\n                console.warn('Failed scheduling trailing recompute:', e)\n              }\n            }, 25)\n          }\n        } catch (e) {\n          // non-fatal\n        }\n      }\n    }, debounceMs)\n\n    return p\n  },\n\n  // Find suggested items to add to transaction (unassociated items with same vendor)\n  async getSuggestedItemsForTransaction(\n    accountId: string,\n    transactionSource: string,\n    limit: number = 5\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('source', transactionSource)\n      .is('transaction_id', null)\n      .order('date_created', { ascending: false })\n      .limit(limit)\n\n    if (error) throw error\n\n    return (data || []).map(item => unifiedItemsService._convertItemFromDb(item))\n  },\n\n  // Create new transaction (account-scoped)\n  async createTransaction(\n    accountId: string,\n    projectId: string | null | undefined,\n    transactionData: Omit<Transaction, 'transactionId' | 'createdAt'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      await ensureAuthenticatedForDatabase()\n\n      // Get current user ID for created_by field\n      const currentUser = await getCurrentUser()\n      const userId = transactionData.createdBy || currentUser?.id || null\n      \n      if (!userId) {\n        throw new Error('User must be authenticated to create transactions')\n      }\n\n      const now = new Date()\n      // Generate a unique transaction_id (UUID format)\n      const transactionId = crypto.randomUUID()\n\n      // Convert camelCase transactionData to database format\n      const dbTransaction = _convertTransactionToDb({\n        ...transactionData,\n        transactionId,\n        createdAt: now.toISOString()\n      })\n\n      // Set account_id and timestamps\n      dbTransaction.account_id = accountId\n      dbTransaction.created_at = now.toISOString()\n      dbTransaction.updated_at = now.toISOString()\n      if (!dbTransaction.status) dbTransaction.status = 'completed'\n\n      console.log('Creating transaction:', dbTransaction)\n      console.log('Transaction items:', items)\n\n      // Apply tax calculation from presets or compute from subtotal when Other\n      if (dbTransaction.tax_rate_preset) {\n        if (dbTransaction.tax_rate_preset === 'Other') {\n          // Validate subtotal presence and calculate rate\n          const amountNum = parseFloat(dbTransaction.amount || '0')\n          const subtotalNum = parseFloat(dbTransaction.subtotal || '0')\n          if (isNaN(subtotalNum) || subtotalNum <= 0) {\n            throw new Error('Subtotal must be greater than 0 when Tax Rate Preset is Other.')\n          }\n          if (isNaN(amountNum) || amountNum < subtotalNum) {\n            throw new Error('Subtotal cannot exceed the total amount.')\n          }\n          const rate = ((amountNum - subtotalNum) / subtotalNum) * 100\n          dbTransaction.tax_rate_pct = Math.round(rate * 10000) / 10000 // 4 decimal places\n        } else {\n          // Look up preset by ID\n          const preset = await getTaxPresetById(accountId, dbTransaction.tax_rate_preset)\n          if (!preset) {\n            throw new Error(`Tax preset with ID '${dbTransaction.tax_rate_preset}' not found.`)\n          }\n          dbTransaction.tax_rate_pct = preset.rate\n          // Remove subtotal for preset selections\n          dbTransaction.subtotal = null\n        }\n      }\n\n      const { error } = await supabase\n        .from('transactions')\n        .insert(dbTransaction)\n\n      if (error) throw error\n\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        // Propagate tax_rate_pct to created items if present on transaction\n        const itemsToCreate = items.map(i => ({ ...i }))\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          accountId,\n          projectId || '',\n          transactionId,\n          transactionData.transactionDate,\n          transactionData.source, // Pass transaction source to items\n          itemsToCreate,\n          dbTransaction.tax_rate_pct\n        )\n        console.log('Created items:', createdItemIds)\n      }\n      // Ensure the denormalized needs_review flag is computed and persisted\n      try {\n        // Fire-and-forget: schedule recompute but don't block the mutation flow\n        this._enqueueRecomputeNeedsReview(accountId, projectId, transactionId).catch((e: any) => {\n          console.warn('Failed to set needs_review after transaction creation:', e)\n        })\n      } catch (e) {\n        console.warn('Failed to set needs_review after transaction creation:', e)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction (account-scoped)\n  async updateTransaction(accountId: string, _projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Apply business rules for reimbursement type and status (using camelCase)\n    const finalUpdates: Partial<Transaction> = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursementType\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursementType !== undefined) {\n      finalUpdates.reimbursementType = null\n    }\n\n    // If reimbursementType is being set to empty string, also clear it\n    if (finalUpdates.reimbursementType === '') {\n      finalUpdates.reimbursementType = null\n    }\n\n    // If reimbursementType is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursementType && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursementType is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    // Apply tax mapping / computation before save (using camelCase)\n    if (finalUpdates.taxRatePreset !== undefined) {\n      if (finalUpdates.taxRatePreset === 'Other') {\n        // Compute from provided subtotal and amount if present in updates or existing doc\n        const { data: existing } = await supabase\n          .from('transactions')\n          .select('amount, subtotal')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n\n        const existingData = existing as { amount?: string; subtotal?: string } | null\n        const amountVal = finalUpdates.amount !== undefined ? parseFloat(finalUpdates.amount) : parseFloat(existingData?.amount || '0')\n        const subtotalVal = finalUpdates.subtotal !== undefined ? parseFloat(finalUpdates.subtotal) : parseFloat(existingData?.subtotal || '0')\n        if (!isNaN(amountVal) && !isNaN(subtotalVal) && subtotalVal > 0 && amountVal >= subtotalVal) {\n          const rate = ((amountVal - subtotalVal) / subtotalVal) * 100\n          finalUpdates.taxRatePct = Math.round(rate * 10000) / 10000\n        }\n      } else {\n        // Look up preset by ID\n        try {\n          const preset = await getTaxPresetById(accountId, finalUpdates.taxRatePreset)\n          if (preset) {\n            finalUpdates.taxRatePct = preset.rate\n            // Remove subtotal when using presets\n            finalUpdates.subtotal = undefined\n          } else {\n            console.warn(`Tax preset with ID '${finalUpdates.taxRatePreset}' not found during update`)\n          }\n        } catch (e) {\n          console.warn('Tax preset lookup failed during update:', e)\n        }\n      }\n    }\n\n    // Convert camelCase updates to database format\n    const dbUpdates = _convertTransactionToDb(finalUpdates)\n    // Add updated_at timestamp for database\n    dbUpdates.updated_at = new Date().toISOString()\n\n    const { error } = await supabase\n      .from('transactions')\n      .update(dbUpdates)\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n\n    // If taxRatePct is set in updates, propagate to items\n    if (finalUpdates.taxRatePct !== undefined) {\n      try {\n        const items = await unifiedItemsService.getItemsForTransaction(accountId, _projectId, transactionId)\n        if (items && items.length > 0) {\n          // Update each item individually (Supabase batch operations)\n          for (const item of items) {\n            await unifiedItemsService.updateItem(accountId, item.itemId, {\n              taxRatePct: finalUpdates.taxRatePct\n            })\n          }\n        }\n      } catch (e) {\n        console.warn('Failed to propagate tax_rate_pct to items:', e)\n      }\n    }\n    // Recompute and persist needs_review unless caller explicitly provided it\n    if (finalUpdates.needsReview === undefined) {\n    // Schedule recompute asynchronously; do not await to keep updates fast\n    this._enqueueRecomputeNeedsReview(accountId, _projectId, transactionId).catch((e: any) => {\n      console.warn('Failed to recompute needs_review after transaction update:', e)\n    })\n    }\n  },\n\n  // Delete transaction (account-scoped)\n  async deleteTransaction(accountId: string, _projectId: string, transactionId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const { error } = await supabase\n      .from('transactions')\n      .delete()\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n  },\n\n  // Subscribe to transactions with real-time updates\n  subscribeToTransactions(\n    accountId: string,\n    projectId: string,\n    callback: (transactions: Transaction[]) => void,\n    initialTransactions?: Transaction[]\n  ) {\n    let transactions = [...(initialTransactions || [])]\n\n    const channel = supabase\n      .channel(`transactions:${accountId}:${projectId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          // Listen at account scope so we receive updates when project_id changes\n          filter: `account_id=eq.${accountId}`\n        },\n        async (payload) => {\n          console.log('Transactions change received (account scope)!', payload)\n\n          const { eventType, new: newRecord, old: oldRecord } = payload\n          const newProjectId = newRecord?.project_id ?? null\n          const oldProjectId = oldRecord?.project_id ?? null\n\n          const matchesProject = (candidate: string | null | undefined) => candidate === projectId\n\n          if (eventType === 'INSERT') {\n            if (matchesProject(newProjectId)) {\n              const newTransaction = _convertTransactionFromDb(newRecord)\n              const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [newTransaction])\n              // Ensure no duplicates before adding\n              transactions = [enrichedTransaction, ...transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [updatedTransaction])\n\n            const wasInProject = transactions.some(t => t.transactionId === enrichedTransaction.transactionId)\n            const isInProject = matchesProject(newProjectId)\n\n            if (isInProject && !wasInProject) {\n              // Transaction moved into this project\n              transactions = [enrichedTransaction, ...transactions]\n            } else if (!isInProject && wasInProject) {\n              // Transaction moved out of this project (or deleted project_id)\n              transactions = transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)\n            } else if (isInProject && wasInProject) {\n              // Transaction updated within this project\n              transactions = transactions.map(t => t.transactionId === enrichedTransaction.transactionId ? enrichedTransaction : t)\n            }\n            // If !isInProject && !wasInProject ‚Üí change unrelated to this project, ignore\n          } else if (eventType === 'DELETE') {\n            if (matchesProject(oldProjectId)) {\n              const oldId = oldRecord.transaction_id\n              transactions = transactions.filter(t => t.transactionId !== oldId)\n            }\n          }\n\n          const sortedTransactions = [...transactions].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n          callback(sortedTransactions)\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to transactions channel')\n        }\n        if (err) {\n          console.error('Error subscribing to transactions channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  subscribeToAllTransactions(\n    accountId: string,\n    callback: (transactions: Transaction[]) => void,\n    initialTransactions?: Transaction[]\n  ) {\n    let transactions = [...(initialTransactions || [])]\n\n    const channel = supabase\n      .channel(`transactions:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          filter: `account_id=eq.${accountId}`\n        },\n        async (payload) => {\n          console.log('All transactions change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            const newTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [newTransaction])\n            transactions = [enrichedTransaction, ...transactions.filter(t => t.transactionId !== enrichedTransaction.transactionId)]\n          } else if (eventType === 'UPDATE') {\n            const updatedTransaction = _convertTransactionFromDb(newRecord)\n            const [enrichedTransaction] = await _enrichTransactionsWithProjectNames(accountId, [updatedTransaction])\n            transactions = transactions.map(t => t.transactionId === enrichedTransaction.transactionId ? enrichedTransaction : t)\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.transaction_id\n            transactions = transactions.filter(t => t.transactionId !== oldId)\n          }\n          \n          const sortedTransactions = [...transactions].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n          callback(sortedTransactions)\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to all transactions channel')\n        }\n        if (err) {\n          console.error('Error subscribing to all transactions channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Subscribe to single transaction for real-time updates\n  subscribeToTransaction(\n    accountId: string,\n    _projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const channel = supabase\n      .channel(`transaction:${accountId}:${transactionId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'transactions',\n          filter: `account_id=eq.${accountId} AND transaction_id=eq.${transactionId}`\n        },\n        async () => {\n          // Refetch transaction on any change\n          try {\n            const { data, error } = await supabase\n              .from('transactions')\n              .select('*')\n              .eq('account_id', accountId)\n              .eq('transaction_id', transactionId)\n              .single()\n            \n            if (error) {\n              if (error.code === 'PGRST116') {\n                // Not found - transaction was deleted\n                callback(null)\n                return\n              }\n              console.error('Error fetching transaction in subscription:', error)\n              return\n            }\n            \n            if (data) {\n              const transaction = _convertTransactionFromDb(data)\n              const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n              callback(enriched[0] || null)\n            } else {\n              callback(null)\n            }\n          } catch (error) {\n            console.error('Error in transaction subscription callback:', error)\n          }\n        }\n      )\n      .subscribe()\n\n    // Initial fetch\n    const fetchTransaction = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('transactions')\n          .select('*')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n        \n        if (error) {\n          if (error.code === 'PGRST116') {\n            callback(null)\n            return\n          }\n          console.error('Error fetching initial transaction:', error)\n          return\n        }\n        \n        if (data) {\n          const transaction = _convertTransactionFromDb(data)\n          const enriched = await _enrichTransactionsWithProjectNames(accountId, [transaction])\n          callback(enriched[0] || null)\n        } else {\n          callback(null)\n        }\n      } catch (error) {\n        console.error('Error in initial transaction fetch:', error)\n      }\n    }\n    \n    fetchTransaction()\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Get pending transactions for a project (account-scoped)\n  async getPendingTransactions(accountId: string, projectId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n      .eq('status', 'pending')\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions) (account-scoped)\n  async updateTransactionStatus(\n    accountId: string,\n    _projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'canceled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    const updateData: any = {\n      status: status,\n      updated_at: new Date().toISOString()\n    }\n\n    if (updates) {\n      if (updates.transactionDate !== undefined) updateData.transaction_date = updates.transactionDate\n      if (updates.paymentMethod !== undefined) updateData.payment_method = updates.paymentMethod\n      if (updates.amount !== undefined) updateData.amount = updates.amount\n      if (updates.notes !== undefined) updateData.notes = updates.notes\n      // Add other fields as needed\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transactionDate) {\n      updateData.transaction_date = toDateOnlyString(new Date())\n    }\n\n    const { error } = await supabase\n      .from('transactions')\n      .update(updateData)\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n\n    if (error) throw error\n  },\n\n  // Utility queries for Business Inventory and reporting (account-scoped)\n  async getInventoryRelatedTransactions(accountId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('reimbursement_type', [CLIENT_OWES_COMPANY, COMPANY_OWES_CLIENT])\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  },\n\n  // Get business inventory transactions (project_id == null) (account-scoped)\n  async getBusinessInventoryTransactions(accountId: string): Promise<Transaction[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .is('project_id', null)\n      .order('created_at', { ascending: false })\n\n    if (error) throw error\n\n    const transactions = (data || []).map(tx => _convertTransactionFromDb(tx))\n    return await _enrichTransactionsWithProjectNames(accountId, transactions)\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Helper function to convert database item (snake_case) to app format (camelCase)\n  _convertItemFromDb(dbItem: any): Item {\n    const converted = convertTimestamps(dbItem)\n    return {\n      itemId: converted.item_id,\n      accountId: converted.account_id,\n      projectId: converted.project_id || undefined,\n      transactionId: converted.transaction_id || undefined,\n      previousProjectTransactionId: converted.previous_project_transaction_id ?? null,\n      previousProjectId: converted.previous_project_id ?? null,\n      name: converted.name || undefined,\n      description: converted.description || '',\n      sku: converted.sku || '',\n      source: converted.source || '',\n      purchasePrice: converted.purchase_price || undefined,\n      projectPrice: converted.project_price || undefined,\n      marketValue: converted.market_value || undefined,\n      paymentMethod: converted.payment_method || '',\n      disposition: converted.disposition || undefined,\n      notes: converted.notes || undefined,\n      space: converted.space || undefined,\n      qrKey: converted.qr_key || '',\n      bookmark: converted.bookmark || false,\n      dateCreated: converted.date_created || '',\n      lastUpdated: converted.last_updated ? (typeof converted.last_updated === 'string' ? converted.last_updated : converted.last_updated.toISOString()) : '',\n      images: Array.isArray(converted.images) ? converted.images : [],\n      inventoryStatus: converted.inventory_status || undefined,\n      businessInventoryLocation: converted.business_inventory_location || undefined,\n      taxRatePct: converted.tax_rate_pct ? parseFloat(converted.tax_rate_pct) : undefined,\n      taxAmount: converted.tax_amount || undefined,\n      taxAmountPurchasePrice: converted.tax_amount_purchase_price || undefined,\n      taxAmountProjectPrice: converted.tax_amount_project_price || undefined,\n      createdBy: converted.created_by || undefined,\n      createdAt: converted.created_at,\n      originTransactionId: converted.origin_transaction_id ?? null,\n      latestTransactionId: converted.latest_transaction_id ?? null\n    } as Item\n  },\n\n  // Helper function to convert app format (camelCase) to database format (snake_case)\n  _convertItemToDb(item: Partial<Item>): any {\n    const dbItem: any = {}\n    \n    if (item.itemId !== undefined) dbItem.item_id = item.itemId\n    if (item.accountId !== undefined) dbItem.account_id = item.accountId\n    if (item.projectId !== undefined) dbItem.project_id = item.projectId ?? null\n    if (item.transactionId !== undefined) dbItem.transaction_id = item.transactionId ?? null\n    if (item.previousProjectTransactionId !== undefined) dbItem.previous_project_transaction_id = item.previousProjectTransactionId ?? null\n    if (item.previousProjectId !== undefined) dbItem.previous_project_id = item.previousProjectId ?? null\n    if (item.name !== undefined) dbItem.name = item.name\n    if (item.description !== undefined) dbItem.description = item.description\n    if (item.sku !== undefined) dbItem.sku = item.sku\n    if (item.source !== undefined) dbItem.source = item.source\n    if (item.purchasePrice !== undefined) dbItem.purchase_price = item.purchasePrice\n    if (item.projectPrice !== undefined) dbItem.project_price = item.projectPrice\n    if (item.marketValue !== undefined) dbItem.market_value = item.marketValue\n    if (item.paymentMethod !== undefined) dbItem.payment_method = item.paymentMethod\n    if (item.disposition !== undefined) dbItem.disposition = item.disposition\n    if (item.notes !== undefined) dbItem.notes = item.notes\n    if (item.space !== undefined) dbItem.space = item.space\n    if (item.qrKey !== undefined) dbItem.qr_key = item.qrKey\n    if (item.bookmark !== undefined) dbItem.bookmark = item.bookmark\n    if (item.dateCreated !== undefined) dbItem.date_created = item.dateCreated\n    if (item.lastUpdated !== undefined) dbItem.last_updated = item.lastUpdated\n    if (item.images !== undefined) dbItem.images = item.images\n    if (item.inventoryStatus !== undefined) dbItem.inventory_status = item.inventoryStatus\n    if (item.businessInventoryLocation !== undefined) dbItem.business_inventory_location = item.businessInventoryLocation\n    if (item.taxRatePct !== undefined) dbItem.tax_rate_pct = item.taxRatePct\n    if (item.taxAmount !== undefined) dbItem.tax_amount = item.taxAmount\n    if (item.taxAmountPurchasePrice !== undefined) dbItem.tax_amount_purchase_price = item.taxAmountPurchasePrice\n    if (item.taxAmountProjectPrice !== undefined) dbItem.tax_amount_project_price = item.taxAmountProjectPrice\n    if (item.createdBy !== undefined) dbItem.created_by = item.createdBy\n    if (item.createdAt !== undefined) dbItem.created_at = item.createdAt\n    if (item.originTransactionId !== undefined) dbItem.origin_transaction_id = item.originTransactionId ?? null\n    if (item.latestTransactionId !== undefined) dbItem.latest_transaction_id = item.latestTransactionId ?? null\n    \n    return dbItem\n  },\n\n  // Get items for a project (project_id == projectId) (account-scoped)\n  async getItemsByProject(\n    accountId: string,\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    let query = supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('project_id', projectId)\n\n    // Apply filters\n    if (filters?.status) {\n      query = query.eq('disposition', filters.status)\n    }\n\n    if (filters?.category) {\n      query = query.eq('source', filters.category)\n    }\n\n    if (filters?.priceRange) {\n      query = query.gte('project_price', filters.priceRange.min.toString())\n      query = query.lte('project_price', filters.priceRange.max.toString())\n    }\n\n    // Apply search (using ilike for case-insensitive search)\n    if (filters?.searchQuery) {\n      query = query.or(`description.ilike.%${filters.searchQuery}%,source.ilike.%${filters.searchQuery}%,sku.ilike.%${filters.searchQuery}%,payment_method.ilike.%${filters.searchQuery}%`)\n    }\n\n    // Apply sorting\n    query = query.order('last_updated', { ascending: false })\n\n    // Apply pagination\n    if (pagination) {\n      const offset = pagination.page > 0 ? (pagination.page - 1) * pagination.limit : 0\n      query = query.range(offset, offset + pagination.limit - 1)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  // Subscribe to items for a project with real-time updates\n  subscribeToProjectItems(\n    accountId: string,\n    projectId: string,\n    callback: (items: Item[]) => void,\n    initialItems?: Item[]\n  ) {\n    let items = [...(initialItems || [])]\n\n    const channel = supabase\n      .channel(`project-items:${accountId}:${projectId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'items',\n          // Broaden filter to account-level to catch updates where project_id changes\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Project items change received (broad filter)!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            // Add item only if it belongs to the current project\n            if (newRecord.project_id === projectId) {\n              const newItem = this._convertItemFromDb(newRecord)\n              items = [newItem, ...items]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedItem = this._convertItemFromDb(newRecord)\n            const wasInProject = items.some(i => i.itemId === updatedItem.itemId)\n            const isInProject = updatedItem.projectId === projectId\n\n            if (isInProject && !wasInProject) {\n              // Item moved INTO this project\n              items = [updatedItem, ...items]\n            } else if (!isInProject && wasInProject) {\n              // Item moved OUT of this project\n              items = items.filter(i => i.itemId !== updatedItem.itemId)\n            } else if (isInProject && wasInProject) {\n              // Item updated WITHIN this project\n              items = items.map(i => i.itemId === updatedItem.itemId ? updatedItem : i)\n            }\n            // If !isInProject and !wasInProject, do nothing (change between other projects)\n            \n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.item_id\n            items = items.filter(i => i.itemId !== oldId)\n          }\n          \n          callback([...items])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to project items channel')\n        }\n        if (err) {\n          console.error('Error subscribing to project items channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n\n  // Get business inventory items (project_id == null) (account-scoped)\n  async getBusinessInventoryItems(\n    accountId: string,\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    let query = supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .is('project_id', null)\n\n    // Apply filters\n    if (filters?.status) {\n      query = query.eq('inventory_status', filters.status)\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      query = query.or(`description.ilike.%${filters.searchQuery}%,source.ilike.%${filters.searchQuery}%,sku.ilike.%${filters.searchQuery}%,business_inventory_location.ilike.%${filters.searchQuery}%`)\n    }\n\n    // Apply sorting\n    query = query.order('last_updated', { ascending: false })\n\n    // Apply pagination\n    if (pagination) {\n      const offset = pagination.page > 0 ? (pagination.page - 1) * pagination.limit : 0\n      query = query.range(offset, offset + pagination.limit - 1)\n    }\n\n    const { data, error } = await query\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  subscribeToBusinessInventory(\n    accountId: string,\n    callback: (items: Item[]) => void,\n    _filters: any,\n    initialItems?: Item[]\n  ) {\n    let items = [...(initialItems || [])]\n\n    const channel = supabase\n      .channel(`business-inventory:${accountId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'items',\n          filter: `account_id=eq.${accountId}`\n        },\n        (payload) => {\n          console.log('Business inventory change received!', payload)\n          const { eventType, new: newRecord, old: oldRecord } = payload\n\n          if (eventType === 'INSERT') {\n            // Check raw DB record (snake_case)\n            if (!newRecord.project_id) {\n              const newItem = this._convertItemFromDb(newRecord)\n              items = [newItem, ...items]\n            }\n          } else if (eventType === 'UPDATE') {\n            const updatedItem = this._convertItemFromDb(newRecord)\n            // Check converted item (camelCase) - if projectId is null/undefined, it's business inventory\n            if (!updatedItem.projectId) {\n              // It's a business inventory item, update it\n              items = items.map(i => i.itemId === updatedItem.itemId ? updatedItem : i)\n            } else {\n              // It's no longer a business inventory item (moved to a project), remove it\n              items = items.filter(i => i.itemId !== updatedItem.itemId)\n            }\n          } else if (eventType === 'DELETE') {\n            const oldId = oldRecord.item_id\n            items = items.filter(i => i.itemId !== oldId)\n          }\n          \n          callback([...items])\n        }\n      )\n      .subscribe((status, err) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('Subscribed to business inventory channel')\n        }\n        if (err) {\n          console.error('Error subscribing to business inventory channel:', err)\n        }\n      })\n\n    return () => {\n      channel.unsubscribe()\n    }\n  },\n\n  // Create new item (account-scoped)\n  async createItem(accountId: string, itemData: Omit<Item, 'itemId' | 'dateCreated' | 'lastUpdated'>): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    const now = new Date()\n    // Generate a unique item_id (using timestamp + random string format like the original)\n    const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Convert camelCase itemData to database format\n    const dbItem = this._convertItemToDb({\n      ...itemData,\n      itemId,\n      qrKey: itemData.qrKey || qrKey\n    } as Item)\n    \n    // Set dateCreated and lastUpdated separately since they're omitted from the type\n    dbItem.date_created = toDateOnlyString(now)\n    dbItem.last_updated = now.toISOString()\n\n    // Set account_id and timestamps\n    dbItem.account_id = accountId\n    dbItem.created_at = now.toISOString()\n    if (!dbItem.date_created) dbItem.date_created = toDateOnlyString(now)\n    if (!dbItem.last_updated) dbItem.last_updated = now.toISOString()\n    if (!dbItem.inventory_status) dbItem.inventory_status = 'available'\n\n    // If item is being created with a transaction_id but missing tax_rate_pct,\n    // attempt to read the transaction and inherit its tax_rate_pct.\n    try {\n      if (dbItem.transaction_id && dbItem.tax_rate_pct === null) {\n        const { data: txData } = await supabase\n          .from('transactions')\n          .select('tax_rate_pct')\n          .eq('account_id', accountId)\n          .eq('transaction_id', dbItem.transaction_id)\n          .single()\n\n        if (txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n          dbItem.tax_rate_pct = txData.tax_rate_pct\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when creating item:', e)\n    }\n\n    // Compute derived tax amounts (store as two-decimal strings). Treat empty/null prices as 0.\n    const computeTaxString = (priceStr: string | null | undefined, ratePct: number | undefined | null) => {\n      const priceNum = parseFloat(priceStr || '0')\n      const rate = (ratePct !== undefined && ratePct !== null) ? (Number(ratePct) / 100) : 0\n      const tax = Math.round((priceNum * rate) * 10000) / 10000\n      return tax.toFixed(4)\n    }\n\n    dbItem.tax_amount_purchase_price = computeTaxString(dbItem.purchase_price, dbItem.tax_rate_pct)\n    dbItem.tax_amount_project_price = computeTaxString(dbItem.project_price, dbItem.tax_rate_pct)\n\n    const { error } = await supabase\n      .from('items')\n      .insert(dbItem)\n\n    if (error) throw error\n    // If this item was created attached to a transaction, adjust that transaction's derived sum and recompute\n    try {\n      if (dbItem.transaction_id) {\n        const txId = dbItem.transaction_id\n        if (!transactionService._isBatchActive(accountId, txId)) {\n          try {\n            const purchasePriceRaw = dbItem.purchase_price ?? dbItem.price ?? '0'\n            const delta = parseFloat(String(purchasePriceRaw) || '0')\n            transactionService.notifyTransactionChanged(accountId, txId, { deltaSum: delta }).catch((e: any) => {\n              console.warn('Failed to notifyTransactionChanged after creating item:', e)\n            })\n          } catch (e) {\n            console.warn('Failed computing delta for created item:', e)\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to notifyTransactionChanged after creating item (sync path):', e)\n    }\n\n    return itemId\n  },\n\n  // Update item (account-scoped)\n  async updateItem(accountId: string, itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n    // Read existing item so we can recompute any affected transactions after the update\n    let existingItem: Item | null = null\n    try {\n      existingItem = await this.getItemById(accountId, itemId)\n    } catch (e) {\n      console.warn('Failed to fetch existing item before update:', e)\n    }\n\n    // Convert camelCase updates to database format\n    const dbUpdates = this._convertItemToDb({\n      ...updates,\n      lastUpdated: new Date().toISOString()\n    })\n\n    // If transaction_id is being set/changed and caller did not provide tax_rate_pct,\n    // attempt to inherit the transaction's tax_rate_pct and include it in the update.\n    try {\n      const willSetTransaction = updates.transactionId !== undefined && updates.transactionId !== null\n      const missingTax = updates.taxRatePct === undefined || updates.taxRatePct === null\n      if (willSetTransaction && missingTax) {\n        const txId = updates.transactionId as string\n        if (txId) {\n          const { data: txData } = await supabase\n            .from('transactions')\n            .select('tax_rate_pct')\n            .eq('account_id', accountId)\n            .eq('transaction_id', txId)\n            .single()\n\n          if (txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n            dbUpdates.tax_rate_pct = txData.tax_rate_pct\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to inherit tax_rate_pct when updating item:', e)\n    }\n\n    // If transaction_id is being set and the item currently has a 'to return'\n    // disposition, and the target transaction is a Return, automatically mark\n    // the item as 'returned' so it reflects the transaction assignment.\n    try {\n      const willSetTransaction = updates.transactionId !== undefined && updates.transactionId !== null\n      if (willSetTransaction && existingItem?.disposition === 'to return') {\n        const txId = updates.transactionId as string\n        if (txId) {\n          const { data: txData } = await supabase\n            .from('transactions')\n            .select('transaction_type')\n            .eq('account_id', accountId)\n            .eq('transaction_id', txId)\n            .single()\n\n          if (txData && txData.transaction_type === 'Return') {\n            // Only set disposition if caller didn't explicitly provide one in updates\n            if (dbUpdates.disposition === undefined) {\n              dbUpdates.disposition = 'returned'\n            }\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to auto-update disposition when assigning return transaction:', e)\n    }\n\n    const { error } = await supabase\n      .from('items')\n      .update(dbUpdates)\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n\n    if (error) throw error\n    // Adjust persisted derived sums and recompute needs_review for affected transactions (old and new)\n    try {\n      const prevTx = existingItem?.transactionId ?? null\n      const newTx = updates.transactionId !== undefined ? (updates.transactionId as string | null) : prevTx\n      const projectForTx = (updates.projectId !== undefined ? updates.projectId : existingItem?.projectId) ?? null\n      const affected = Array.from(new Set([prevTx, newTx]).values()).filter(Boolean) as string[]\n      const prevPrice = parseFloat(existingItem?.purchasePrice || '0')\n      const newPrice = updates.purchasePrice !== undefined ? parseFloat(String(updates.purchasePrice || '0')) : prevPrice\n\n      for (const txId of affected) {\n        try {\n          if (!transactionService._isBatchActive(accountId, txId)) {\n            // Same transaction updated: send delta (new - prev)\n            if (prevTx && newTx && prevTx === newTx && txId === prevTx) {\n              const delta = newPrice - prevPrice\n              if (delta !== 0) {\n                transactionService.notifyTransactionChanged(accountId, txId, { deltaSum: delta }).catch((e: any) => {\n                  console.warn('Failed to notifyTransactionChanged after updating item for tx', txId, e)\n                })\n              }\n            } else {\n              // Moved between transactions: subtract from old and add to new\n              if (txId === prevTx) {\n                const delta = -prevPrice\n                transactionService.notifyTransactionChanged(accountId, txId, { deltaSum: delta }).catch((e: any) => {\n                  console.warn('Failed to notifyTransactionChanged for old tx after moving item', txId, e)\n                })\n              }\n              if (txId === newTx) {\n                const delta = newPrice\n                transactionService.notifyTransactionChanged(accountId, txId, { deltaSum: delta }).catch((e: any) => {\n                  console.warn('Failed to notifyTransactionChanged for new tx after moving item', txId, e)\n                })\n              }\n            }\n          }\n        } catch (e) {\n          console.warn('Failed to schedule notifyTransactionChanged after updating item for tx', txId, e)\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to schedule notifyTransactionChanged after updateItem:', e)\n    }\n  },\n\n  // Delete item (account-scoped)\n  async deleteItem(accountId: string, itemId: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n    // Read existing item to determine associated transaction (if any) so we can recompute after deletion\n    let existingItem: Item | null = null\n    try {\n      existingItem = await this.getItemById(accountId, itemId)\n    } catch (e) {\n      console.warn('Failed to fetch item before deletion:', e)\n    }\n\n    const { error } = await supabase\n      .from('items')\n      .delete()\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n\n    if (error) throw error\n\n    // Adjust persisted sum and recompute for the transaction the item belonged to (if any)\n    try {\n      const txId = existingItem?.transactionId ?? null\n      if (txId) {\n        if (!transactionService._isBatchActive(accountId, txId)) {\n          const prevPrice = parseFloat(existingItem?.purchasePrice || '0')\n          const delta = -prevPrice\n          transactionService.notifyTransactionChanged(accountId, txId, { deltaSum: delta }).catch((e: any) => {\n            console.warn('Failed to notifyTransactionChanged after deleting item:', e)\n          })\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to notifyTransactionChanged after deleting item:', e)\n    }\n  },\n\n  // Get items for a transaction (by transaction_id) (account-scoped)\n  async getItemsForTransaction(accountId: string, _projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .order('date_created', { ascending: true })\n\n    if (error) throw error\n\n    return (data || []).map(item => this._convertItemFromDb(item))\n  },\n\n  // Allocate single item to project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows) (account-scoped)\n  async allocateItemToProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the item to determine current state and calculate amount\n    const item = await this.getItemById(accountId, itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.projectPrice || item.marketValue || '0.00'\n    const currentTransactionId: string | null = item.transactionId || null\n\n    console.log('üîÑ Starting allocation process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.projectId,\n      finalAmount\n    })\n\n    // Log allocation start (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, item.projectId ?? null, currentTransactionId ?? null, {\n        action: 'allocation_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC from ALLOCATION_TRANSACTION_LOGIC.md\n\n    // Scenario A: Item currently in a Sale (Project X)\n    if (currentTransactionId?.startsWith('INV_SALE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n      if (currentProjectId === projectId) {\n        // A.1: Remove item from Sale and move to Inventory (delete Sale if empty)\n        console.log('üìã Scenario A.1: Item in Sale, allocating to same project ‚Üí move to inventory')\n        return await this.handleSaleToInventoryMove(accountId, item, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // A.2: Allocate to different project - remove from Sale, add to Purchase (Project Y)\n        console.log('üìã Scenario A.2: Item in Sale, allocating to different project')\n        return await this.handleSaleToDifferentProjectMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario B: Item currently in a Purchase (Project X)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // B.1: Allocate to same project - remove from Purchase, update amount, delete if empty\n        console.log('üìã Scenario B.1: Item in Purchase, allocating to same project')\n        return await this.handlePurchaseToInventoryMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // B.2: Allocate to different project - remove from Purchase, add to Sale (Project Y)\n        console.log('üìã Scenario B.2: Item in Purchase, allocating to different project')\n        return await this.handlePurchaseToDifferentProjectMove(accountId, itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario C: Item in Inventory (no transaction)\n    // Only treat as inventory when there is no transaction_id. Previously this\n    // branch also treated items with a null project_id as inventory which\n    // incorrectly bypassed removal from existing INV_SALE_/INV_PURCHASE_\n    // transactions. Require absence of currentTransactionId to follow the\n    // inventory -> purchase flow.\n    if (!currentTransactionId) {\n      console.log('üìã Scenario C: Item in inventory, allocating to project')\n      return await this.handleInventoryToPurchaseMove(accountId, itemId, projectId, finalAmount, notes, space)\n    }\n\n    // Fallback: Unknown scenario, treat as new allocation\n    console.log('üìã Fallback: Unknown scenario, treating as new allocation')\n    return await this.handleInventoryToPurchaseMove(accountId, itemId, projectId, finalAmount, notes, space)\n  },\n\n  // Helper: Handle A.1 - Remove item from Sale (same project)\n  async handleSaleToPurchaseMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: projectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space,\n      previousProjectTransactionId: null,\n      previousProjectId: null\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, purchaseTransactionId, notes)\n      await lineageService.updateItemLineagePointers(accountId, itemId, purchaseTransactionId)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Purchase (same project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  async _restoreItemAfterSaleRemoval(\n    accountId: string,\n    item: Item,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<{\n    restoredTransactionId: string | null;\n    restorationStatus: 'restored' | 'missing_previous_link' | 'previous_project_mismatch' | 'transaction_missing';\n  }> {\n    let restoredTransactionId: string | null = null\n    let restorationStatus: 'restored' | 'missing_previous_link' | 'previous_project_mismatch' | 'transaction_missing' = 'missing_previous_link'\n\n    const previousTransactionId = item.previousProjectTransactionId\n    const previousProjectId = item.previousProjectId\n\n    const baseUpdate = {\n      projectId: projectId,\n      inventoryStatus: 'allocated' as const,\n      transactionId: null as string | null,\n      disposition: 'keep' as const,\n      notes: notes,\n      space: space ?? '',\n      previousProjectTransactionId: null as string | null,\n      previousProjectId: null as string | null\n    }\n\n    if (previousTransactionId && previousProjectId) {\n      if (previousProjectId === projectId) {\n        const { data: previousTransaction, error: previousTransactionError } = await supabase\n          .from('transactions')\n          .select('*')\n          .eq('account_id', accountId)\n          .eq('transaction_id', previousTransactionId)\n          .single()\n\n        if (!previousTransactionError && previousTransaction) {\n          await this.addItemToTransaction(\n            accountId,\n            item.itemId,\n            previousTransactionId,\n            finalAmount,\n            'Purchase',\n            'Inventory allocation',\n            notes\n          )\n\n          await this.updateItem(accountId, item.itemId, {\n            ...baseUpdate,\n            transactionId: previousTransactionId\n          })\n\n          restoredTransactionId = previousTransactionId\n          restorationStatus = 'restored'\n        } else {\n          console.warn('‚ö†Ô∏è Stored previous project transaction not found; falling back to allocation without restoration', {\n            itemId: item.itemId,\n            previousTransactionId\n          })\n          restorationStatus = 'transaction_missing'\n\n          await this.updateItem(accountId, item.itemId, baseUpdate)\n        }\n      } else {\n        restorationStatus = 'previous_project_mismatch'\n        await this.updateItem(accountId, item.itemId, baseUpdate)\n      }\n    } else {\n      await this.updateItem(accountId, item.itemId, baseUpdate)\n    }\n\n    return { restoredTransactionId, restorationStatus }\n  },\n\n  // Helper: Handle A.1 (authoritative) - Remove item from Sale and move to Inventory (same project)\n  async handleSaleToInventoryMove(\n    accountId: string,\n    item: Item,\n    currentTransactionId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, item.itemId, currentTransactionId, finalAmount)\n\n    const { restoredTransactionId, restorationStatus } = await this._restoreItemAfterSaleRemoval(\n      accountId,\n      item,\n      projectId,\n      finalAmount,\n      notes,\n      space\n    )\n\n    // Append lineage edge and update pointers\n    try {\n      if (restoredTransactionId) {\n        // Sale ‚Üí Purchase (restored)\n        await lineageService.appendItemLineageEdge(accountId, item.itemId, currentTransactionId, restoredTransactionId, notes)\n        await lineageService.updateItemLineagePointers(accountId, item.itemId, restoredTransactionId)\n      } else {\n        // Sale ‚Üí Inventory (null)\n        await lineageService.appendItemLineageEdge(accountId, item.itemId, currentTransactionId, null, notes)\n        await lineageService.updateItemLineagePointers(accountId, item.itemId, null)\n      }\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Inventory (same project)', {\n      restorationStatus,\n      restoredTransactionId\n    })\n\n    // Log successful move (catch errors to prevent cascading failures)\n    try {\n      const auditDetails: Record<string, any> = {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        amount: finalAmount,\n        restoration_status: restorationStatus,\n        to_status: restoredTransactionId ? 'allocated_with_purchase' : 'allocated'\n      }\n\n      if (restoredTransactionId) {\n        auditDetails.restored_transaction_id = restoredTransactionId\n      }\n\n      await auditService.logAllocationEvent(accountId, 'allocation', item.itemId, projectId, restoredTransactionId ?? null, auditDetails)\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion (A.1):', auditError)\n    }\n\n    // Return restored transaction id when available; fall back to the sale id (for compatibility)\n    return restoredTransactionId ?? currentTransactionId\n  },\n\n  // Helper: Handle A.2 - Remove item from Sale, add to Purchase (different project)\n  async handleSaleToDifferentProjectMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${newProjectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction for new project (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: newProjectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space,\n      previousProjectTransactionId: null,\n      previousProjectId: null\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, purchaseTransactionId, notes)\n      await lineageService.updateItemLineagePointers(accountId, itemId, purchaseTransactionId)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ A.2 completed: Sale ‚Üí Purchase (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, newProjectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.2',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle B.1 - Remove item from Purchase (same project)\n  async handlePurchaseToInventoryMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: null,\n      disposition: 'inventory',\n      notes: _notes,\n      space: space ?? '',\n      previousProjectTransactionId: currentTransactionId,\n      previousProjectId: _projectId\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, null, _notes)\n      await lineageService.updateItemLineagePointers(accountId, itemId, null)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ B.1 completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful deallocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, 'inventory', {\n        action: 'deallocation_completed',\n        scenario: 'B.1',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n    }\n\n    return currentTransactionId // Return the original transaction ID since item is now in inventory\n  },\n\n  // Helper: Handle B.2 - Remove item from Purchase, add to Sale (different project)\n  async handlePurchaseToDifferentProjectMove(\n    accountId: string,\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const saleTransactionId = `INV_SALE_${newProjectId}`\n\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n\n    // Add item to Sale transaction for new project (create if none)\n    await this.addItemToTransaction(accountId, itemId, saleTransactionId, finalAmount, 'To Inventory', 'Inventory sale', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: saleTransactionId,\n      disposition: 'inventory',\n      space: space ?? '',\n      previousProjectTransactionId: null,\n      previousProjectId: null\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, saleTransactionId, notes)\n      await lineageService.updateItemLineagePointers(accountId, itemId, saleTransactionId)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ B.2 completed: Purchase ‚Üí Sale (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, null, saleTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'B.2',\n        from_transaction: currentTransactionId,\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Helper: Handle C - Add item to Purchase (new allocation)\n  async handleInventoryToPurchaseMove(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(accountId, itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(accountId, itemId, {\n      projectId: projectId,\n      inventoryStatus: 'allocated',\n      transactionId: purchaseTransactionId,\n      disposition: 'keep',\n      space: space,\n      previousProjectTransactionId: null,\n      previousProjectId: null\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, itemId, null, purchaseTransactionId, notes)\n      await lineageService.updateItemLineagePointers(accountId, itemId, purchaseTransactionId, purchaseTransactionId)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ C completed: Inventory ‚Üí Purchase (new allocation)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'C',\n        from_status: 'inventory',\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Remove item from transaction and update amounts\n  async removeItemFromTransaction(accountId: string, itemId: string, transactionId: string, _itemAmount: string): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the transaction\n    const { data: transactionData, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (fetchError || !transactionData) {\n      console.warn('‚ö†Ô∏è Transaction not found for removal:', transactionId)\n      return\n    }\n\n    const existingItemIds = transactionData.item_ids || []\n    const updatedItemIds = existingItemIds.filter((id: string) => id !== itemId)\n\n    if (updatedItemIds.length === 0) {\n      // No items left - delete transaction\n      try {\n        const { error: deleteError } = await supabase\n          .from('transactions')\n          .delete()\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (deleteError) throw deleteError\n\n        console.log('üóëÔ∏è Deleted empty transaction:', transactionId)\n\n        // Log transaction deletion (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'deleted', transactionData, null)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction deletion:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to delete empty transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue even if deletion fails\n      }\n    } else {\n      // Recalculate amount from remaining items\n      try {\n        // Get all items to recalculate amount\n        const { data: itemsData, error: itemsError } = await supabase\n          .from('items')\n          .select('project_price, market_value')\n          .eq('account_id', accountId)\n          .in('item_id', updatedItemIds)\n\n        if (itemsError) throw itemsError\n\n        const totalAmount = (itemsData || [])\n          .map(item => item.project_price || item.market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          updated_at: new Date().toISOString()\n        }\n\n        const { error: updateError } = await supabase\n          .from('transactions')\n          .update(updateData)\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (updateError) throw updateError\n\n        console.log('üîÑ Updated transaction after removal:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'updated', transactionData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update transaction after removal:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Helper: Add item to transaction (create if none exists)\n  async addItemToTransaction(\n    accountId: string,\n    itemId: string,\n    transactionId: string,\n    amount: string,\n    transactionType: 'Purchase' | 'Sale' | 'To Inventory',\n    triggerEvent: string,\n    notes?: string\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Check if transaction exists\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', transactionId)\n      .single()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - add item and recalculate amount\n      try {\n        const existingItemIds = existingTransaction.item_ids || []\n        const updatedItemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n        // Get all items to recalculate amount\n        const { data: itemsData, error: itemsError } = await supabase\n          .from('items')\n          .select('project_price, market_value')\n          .eq('account_id', accountId)\n          .in('item_id', updatedItemIds)\n\n        if (itemsError) throw itemsError\n\n        const totalAmount = (itemsData || [])\n          .map(item => item.project_price || item.market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          updated_at: new Date().toISOString()\n        }\n\n        const { error: updateError } = await supabase\n          .from('transactions')\n          .update(updateData)\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n\n        if (updateError) throw updateError\n\n        console.log('üîÑ Added item to existing transaction:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'updated', existingTransaction, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n\n        // If the transaction has a tax rate, propagate it to the added item\n        try {\n          const txTax = existingTransaction.tax_rate_pct\n          if (txTax !== undefined && txTax !== null) {\n            await this.updateItem(accountId, itemId, {\n              tax_rate_pct: txTax\n            })\n          }\n        } catch (e) {\n          console.warn('Failed to set tax_rate_pct on added item:', itemId, e)\n        }\n        // Ensure the item record is linked to the transaction so the UI sees the association\n        try {\n          await this.updateItem(accountId, itemId, {\n            transactionId: transactionId\n          })\n        } catch (linkErr) {\n          console.warn('Failed to link item to transaction after adding to existing transaction:', itemId, linkErr)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update existing transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    } else {\n      // Create new transaction\n      try {\n        // Get current user ID for created_by field\n        const currentUser = await getCurrentUser()\n        if (!currentUser?.id) {\n          throw new Error('User must be authenticated to create transactions')\n        }\n\n        const projectId = transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', '')\n        const project = await projectService.getProject(accountId, projectId)\n        const projectName = project?.name || 'Other'\n\n        const now = new Date()\n        const transactionData = {\n          account_id: accountId,\n          transaction_id: transactionId,\n          project_id: projectId,\n          transaction_date: toDateOnlyString(now),\n          source: transactionType === 'Purchase' ? 'Inventory' : projectName,\n          transaction_type: transactionType,\n          payment_method: 'Pending',\n          amount: amount,\n          budget_category: 'Furnishings',\n          notes: notes || `Transaction for items ${transactionType === 'Purchase' ? 'purchased from' : 'sold to'} ${transactionType === 'Purchase' ? 'inventory' : 'project'}`,\n          status: 'pending' as const,\n          reimbursement_type: transactionType === 'Purchase' ? CLIENT_OWES_COMPANY : COMPANY_OWES_CLIENT,\n          trigger_event: triggerEvent,\n          item_ids: [itemId],\n          created_by: currentUser.id,\n          created_at: now.toISOString(),\n          updated_at: now.toISOString()\n        }\n\n        const { error: insertError } = await supabase\n          .from('transactions')\n          .insert(transactionData)\n\n        if (insertError) throw insertError\n\n        console.log('üÜï Created new transaction:', transactionId, 'amount:', amount)\n\n        // Log transaction creation (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(accountId, transactionId, 'created', null, transactionData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction creation:', auditError)\n        }\n        // Link the newly-created transaction to the item record as well\n        try {\n          await this.updateItem(accountId, itemId, {\n            transactionId: transactionId\n          })\n        } catch (linkErr) {\n          console.warn('Failed to link item to transaction after creating new transaction:', itemId, linkErr)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to create new transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Batch allocate multiple items to project (updates INV_PURCHASE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    accountId: string,\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Fetch the requested items by id (inspect transaction_id per-item to\n    // implement A.1 vs A.2 decisions). Do NOT rely solely on project_id.\n    const { data: itemsData, error: itemsError } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .in('item_id', itemIds)\n\n    if (itemsError || !itemsData || itemsData.length === 0) {\n      throw new Error('No items found for allocation')\n    }\n\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Process each item individually so we can apply A.1/A.2 rules per item.\n    for (const itemData of itemsData) {\n      const item = this._convertItemFromDb(itemData)\n      const itemId = item.itemId\n      const finalAmount = allocationData.amount || itemData.project_price || itemData.market_value || '0.00'\n      const currentTransactionId: string | null = itemData.transaction_id || null\n\n      // Scenario A: Item currently in a Sale (Project X)\n      if (currentTransactionId?.startsWith('INV_SALE_')) {\n        const saleProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n        if (saleProjectId === projectId) {\n          // A.1: Remove item from Sale and DO NOT add to Purchase. Assign back to\n          // the same project (mark allocated) but do not create an INV_PURCHASE.\n          console.log('üìã Batch A.1: Item in sale for target project ‚Äî removing from sale and assigning to project', itemId)\n          await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n          const { restoredTransactionId } = await this._restoreItemAfterSaleRemoval(\n            accountId,\n            item,\n            projectId,\n            finalAmount,\n            allocationData.notes,\n            allocationData.space\n          )\n          // Append lineage edge\n          try {\n            if (restoredTransactionId) {\n              await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, restoredTransactionId, allocationData.notes)\n              await lineageService.updateItemLineagePointers(accountId, itemId, restoredTransactionId)\n            } else {\n              await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, null, allocationData.notes)\n              await lineageService.updateItemLineagePointers(accountId, itemId, null)\n            }\n          } catch (lineageError) {\n            console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n          }\n          continue\n        } else {\n          // A.2: Remove from Sale then add to Purchase for target project\n          console.log('üìã Batch A.2: Item in sale for different project ‚Äî moving to purchase for target project', itemId)\n          await this.removeItemFromTransaction(accountId, itemId, currentTransactionId, finalAmount)\n          await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n          await this.updateItem(accountId, itemId, {\n            projectId: projectId,\n            inventoryStatus: 'allocated',\n            transactionId: canonicalTransactionId,\n            disposition: 'keep',\n            space: allocationData.space || '',\n            previousProjectTransactionId: null,\n            previousProjectId: null\n          })\n          // Append lineage edge\n          try {\n            await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, canonicalTransactionId, allocationData.notes)\n            await lineageService.updateItemLineagePointers(accountId, itemId, canonicalTransactionId)\n          } catch (lineageError) {\n            console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n          }\n          continue\n        }\n      }\n\n      // Scenario C: Item in Inventory (no transaction_id) ‚Äî add to Purchase\n      if (!currentTransactionId) {\n        console.log('üìã Batch C: Item in inventory ‚Äî adding to purchase', itemId)\n        await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n        await this.updateItem(accountId, itemId, {\n          projectId: projectId,\n          inventoryStatus: 'allocated',\n          transactionId: canonicalTransactionId,\n          disposition: 'keep',\n          space: allocationData.space || '',\n          previousProjectTransactionId: null,\n          previousProjectId: null\n        })\n        // Append lineage edge\n        try {\n          await lineageService.appendItemLineageEdge(accountId, itemId, null, canonicalTransactionId, allocationData.notes)\n          await lineageService.updateItemLineagePointers(accountId, itemId, canonicalTransactionId, canonicalTransactionId)\n        } catch (lineageError) {\n          console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n        }\n        continue\n      }\n\n      // Fallback: other transaction types ‚Äî add to purchase and update item\n      console.log('üìã Batch Fallback: Item in other transaction ‚Äî adding to purchase', itemId, currentTransactionId)\n      await this.addItemToTransaction(accountId, itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n      await this.updateItem(accountId, itemId, {\n        projectId: projectId,\n        inventoryStatus: 'allocated',\n        transactionId: canonicalTransactionId,\n        disposition: 'keep',\n        space: allocationData.space || '',\n        previousProjectTransactionId: null,\n        previousProjectId: null\n      })\n      // Append lineage edge\n      try {\n        await lineageService.appendItemLineageEdge(accountId, itemId, currentTransactionId, canonicalTransactionId, allocationData.notes)\n        await lineageService.updateItemLineagePointers(accountId, itemId, canonicalTransactionId)\n      } catch (lineageError) {\n        console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n      }\n    }\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async returnItemFromProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the item to determine current state\n    const item = await this.getItemById(accountId, itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.projectPrice || item.marketValue || '0.00'\n    const currentTransactionId: string | null = item.transactionId || null\n\n    console.log('üîÑ Starting return process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.projectId,\n      finalAmount\n    })\n\n    // Log return start (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', itemId, item.projectId ?? null, currentTransactionId ?? null, {\n        action: 'return_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC for returns (reverse of allocation)\n\n    // If item is in a Purchase transaction, this is a return (Scenario B reverse)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // Returning from same project - remove from Purchase, move to inventory\n        console.log('üìã Return Scenario: Item in Purchase, returning from same project')\n        return await this.handleReturnFromPurchase(accountId, item, currentTransactionId, projectId, finalAmount, notes)\n      }\n    }\n\n    // If item is not in any transaction or is in inventory, this is a new return\n    console.log('üìã Return Scenario: Item not in transaction or new return')\n    return await this.handleNewReturn(accountId, item, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle return from Purchase transaction (same project)\n  async handleReturnFromPurchase(\n    accountId: string,\n    item: Item,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction and return it to inventory.\n    // Per allocation rules, do NOT create an INV_SALE when the item was part of\n    // an INV_PURCHASE for the same project. Simply remove the item from the\n    // purchase (the helper will delete the purchase if empty), then update the\n    // item to reflect that it's back in business inventory.\n    await this.removeItemFromTransaction(accountId, item.itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory and clear transaction linkage for canonical state\n    await this.updateItem(accountId, item.itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: null,\n      disposition: 'inventory',\n      notes: notes,\n      previousProjectTransactionId: currentTransactionId,\n      previousProjectId: item.projectId ?? _projectId\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      await lineageService.appendItemLineageEdge(accountId, item.itemId, currentTransactionId, null, notes)\n      await lineageService.updateItemLineagePointers(accountId, item.itemId, null)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ Return completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', item.itemId, null, currentTransactionId, {\n        action: 'return_completed',\n        scenario: 'return_from_purchase',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    // Return the original purchase transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle new return (item was already in inventory or no transaction)\n  async handleNewReturn(\n    accountId: string,\n    item: Item,\n    projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get current user ID for created_by field\n    const currentUser = await getCurrentUser()\n    if (!currentUser?.id) {\n      throw new Error('User must be authenticated to create transactions')\n    }\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(accountId, projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Create Sale transaction (project selling TO us)\n    const saleTransactionId = `INV_SALE_${projectId}`\n\n    // Check if the canonical transaction already exists (account-scoped)\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', saleTransactionId)\n      .single()\n\n    const now = new Date()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingItemIds = existingTransaction.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.itemId])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const { data: itemsData, error: itemsError } = await supabase\n        .from('items')\n        .select('project_price, market_value')\n        .eq('account_id', accountId)\n        .in('item_id', updatedItemIds)\n\n      if (itemsError) throw itemsError\n\n      const totalAmount = (itemsData || [])\n        .map(current => current.project_price || current.market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n        updated_at: now.toISOString()\n      }\n\n      const { error: updateError } = await supabase\n        .from('transactions')\n        .update(updatedTransactionData)\n        .eq('account_id', accountId)\n        .eq('transaction_id', saleTransactionId)\n\n      if (updateError) throw updateError\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // Transaction doesn't exist - create new one\n      const transactionData = {\n        account_id: accountId,\n        transaction_id: saleTransactionId,\n        project_id: projectId,\n        transaction_date: toDateOnlyString(now),\n        source: projectName,\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: finalAmount,\n        budget_category: 'Furnishings',\n        notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: COMPANY_OWES_CLIENT,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [item.itemId],\n        created_by: currentUser.id,\n        created_at: now.toISOString(),\n        updated_at: now.toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      // Insert the transaction (we've already checked it doesn't exist above)\n      const { error: insertError } = await supabase\n        .from('transactions')\n        .insert(transactionData)\n\n      if (insertError) throw insertError\n    }\n\n    // Update item status to inventory while preserving original purchase metadata when available\n    const previousProjectTransactionId = item.transactionId?.startsWith('INV_PURCHASE_')\n      ? item.transactionId\n      : item.previousProjectTransactionId ?? null\n    const previousProjectId = item.transactionId?.startsWith('INV_PURCHASE_')\n      ? (item.projectId ?? projectId)\n      : item.previousProjectId ?? null\n\n    await this.updateItem(accountId, item.itemId, {\n      projectId: null,\n      inventoryStatus: 'available',\n      transactionId: saleTransactionId,\n      disposition: 'inventory',\n      previousProjectTransactionId,\n      previousProjectId\n    })\n\n    // Append lineage edge and update pointers\n    try {\n      const fromTransactionId = item.transactionId || null\n      await lineageService.appendItemLineageEdge(accountId, item.itemId, fromTransactionId, saleTransactionId, notes)\n      await lineageService.updateItemLineagePointers(accountId, item.itemId, saleTransactionId)\n    } catch (lineageError) {\n      console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n    }\n\n    console.log('‚úÖ New return completed: Inventory ‚Üí Sale')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent(accountId, 'return', item.itemId, null, saleTransactionId, {\n        action: 'return_completed',\n        scenario: 'new_return',\n        from_status: 'inventory',\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    accountId: string,\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForDatabase()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_PURCHASE_${projectId}`\n\n    // Get the transaction\n    const { data: transactionData, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n      .single()\n\n    if (fetchError || !transactionData) {\n      throw new Error('Transaction not found')\n    }\n\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    const now = new Date()\n    const { error: updateError } = await supabase\n      .from('transactions')\n      .update({\n        status: 'completed',\n        payment_method: paymentMethod,\n        transaction_date: toDateOnlyString(now),\n        updated_at: now.toISOString()\n      })\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n\n    if (updateError) throw updateError\n\n    // Clear transaction_id from all linked items (update sequentially since Supabase doesn't have batch updates)\n    for (const itemId of itemIds) {\n      if (transactionType === 'sale') {\n        // For sales (INV_SALE), items move to business inventory (not sold)\n        // Per plan: when completing INV_SALE, items should become available in business inventory\n        // and have a lineage edge INV_SALE ‚Üí null\n        await this.updateItem(accountId, itemId, {\n          transactionId: null,\n          inventoryStatus: 'available'  // Changed from 'sold' to 'available' per plan\n        })\n        \n        // Append lineage edge: sale ‚Üí inventory (null)\n        try {\n          await lineageService.appendItemLineageEdge(accountId, itemId, canonicalTransactionId, null)\n          await lineageService.updateItemLineagePointers(accountId, itemId, null)\n        } catch (lineageError) {\n          console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n        }\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        await this.updateItem(accountId, itemId, {\n          projectId: null,\n          transactionId: null,\n          inventoryStatus: 'available'\n        })\n        \n        // Append lineage edge: purchase ‚Üí inventory (null)\n        try {\n          await lineageService.appendItemLineageEdge(accountId, itemId, canonicalTransactionId, null)\n          await lineageService.updateItemLineagePointers(accountId, itemId, null)\n        } catch (lineageError) {\n          console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n        }\n      }\n    }\n  },\n\n  // Helper function to get item by ID (account-scoped)\n  async getItemById(accountId: string, itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('items')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('item_id', itemId)\n      .single()\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null\n      }\n      throw error\n    }\n\n    if (!data) return null\n\n    return this._convertItemFromDb(data)\n  },\n\n  // Duplicate an existing item (unified collection version) (account-scoped)\n  async duplicateItem(accountId: string, projectId: string, originalItemId: string): Promise<string> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get the original item first\n    const originalItem = await this.getItemById(accountId, originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    const duplicatedItem: any = {\n      account_id: accountId,\n      item_id: newItemId,\n      description: originalItem.description || '',\n      source: originalItem.source || '',\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchasePrice || null,\n      project_price: originalItem.projectPrice || null,\n      market_value: originalItem.marketValue || null,\n      payment_method: originalItem.paymentMethod || '',\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || null,\n      space: originalItem.space || null,\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transactionId || null,\n      project_id: projectId,\n      inventory_status: originalItem.inventoryStatus || 'available',\n      business_inventory_location: originalItem.businessInventoryLocation || null,\n      date_created: originalItem.dateCreated || toDateOnlyString(now),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [], // Copy images from original item\n      tax_rate_pct: originalItem.taxRatePct || null,\n      tax_amount: originalItem.taxAmount || null,\n      created_by: originalItem.createdBy || null,\n      created_at: now.toISOString()\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const { error } = await supabase\n      .from('items')\n      .insert(duplicatedItem)\n\n    if (error) throw error\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version) (account-scoped)\n  async createTransactionItems(\n    accountId: string,\n    projectId: string,\n    transactionId: string,\n    transaction_date: string,\n    transactionSource: string,\n    items: TransactionItemFormData[],\n    taxRatePct?: number\n  ): Promise<string[]> {\n    await ensureAuthenticatedForDatabase()\n\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    // Attempt to read the transaction's tax rate once (avoid per-item reads)\n    let inheritedTax: number | undefined = undefined\n    try {\n      if ((taxRatePct === undefined || taxRatePct === null) && transactionId) {\n        const { data: txData, error: txError } = await supabase\n          .from('transactions')\n          .select('tax_rate_pct')\n          .eq('account_id', accountId)\n          .eq('transaction_id', transactionId)\n          .single()\n\n        if (!txError && txData && txData.tax_rate_pct !== undefined && txData.tax_rate_pct !== null) {\n          inheritedTax = txData.tax_rate_pct\n        }\n      }\n    } catch (e) {\n      // non-fatal - continue without inherited tax\n    }\n\n    // Prepare all items for batch insert\n    const itemsToInsert: any[] = []\n\n    // Helper: compute tax amount string (two-decimal) given price string and rate pct\n    const computeTaxString = (priceStr: string | null | undefined, ratePct: number | undefined | null) => {\n      const priceNum = parseFloat(priceStr || '0')\n      const rate = (ratePct !== undefined && ratePct !== null) ? (Number(ratePct) / 100) : 0\n      const tax = Math.round((priceNum * rate) * 10000) / 10000\n      return tax.toFixed(4)\n    }\n\n    for (const itemData of items) {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item: any = {\n        account_id: accountId,\n        item_id: itemId,\n        description: itemData.description || '',\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchasePrice || null,\n        project_price: itemData.projectPrice || null,\n        market_value: itemData.marketValue || null,\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || null,\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        inventory_status: 'allocated',\n        date_created: transaction_date,\n        last_updated: now.toISOString(),\n        images: [], // Start with empty images array, will be populated after upload\n        created_at: now.toISOString()\n      }\n\n      // Attach tax rate from explicit arg, otherwise inherited transaction value\n      if (taxRatePct !== undefined && taxRatePct !== null) {\n        item.tax_rate_pct = taxRatePct\n      } else if (inheritedTax !== undefined) {\n        item.tax_rate_pct = inheritedTax\n      }\n      // Compute and attach derived tax amounts (purchase and project) as two-decimal strings\n      item.tax_amount_purchase_price = computeTaxString(item.purchase_price, item.tax_rate_pct)\n      item.tax_amount_project_price = computeTaxString(item.project_price, item.tax_rate_pct)\n\n      itemsToInsert.push(item)\n    }\n\n    // Insert all items in a single batch operation\n    if (itemsToInsert.length > 0) {\n      const { error } = await supabase\n        .from('items')\n        .insert(itemsToInsert)\n\n      if (error) throw error\n    }\n    // Recompute and persist needs_review for the transaction we just mutated (fire-and-forget,\n    // but skip if a top-level batch is active for this transaction).\n    try {\n      if (!transactionService._isBatchActive(accountId, transactionId)) {\n        try {\n          const deltaSum = itemsToInsert.reduce((sum, it) => {\n            const p = parseFloat(String(it.purchase_price ?? it.price ?? '0') || '0')\n            return sum + (isNaN(p) ? 0 : p)\n          }, 0)\n          if (deltaSum !== 0) {\n            transactionService.notifyTransactionChanged(accountId, transactionId, { deltaSum }).catch((e: any) => {\n              console.warn('Failed to notifyTransactionChanged after creating transaction items:', e)\n            })\n          } else {\n            // No price delta to apply, still enqueue a recompute (no delta)\n            transactionService.notifyTransactionChanged(accountId, transactionId).catch((e: any) => {\n              console.warn('Failed to notifyTransactionChanged after creating transaction items (no delta):', e)\n            })\n          }\n        } catch (e) {\n          console.warn('Failed computing deltaSum for created transaction items:', e)\n        }\n      }\n    } catch (e) {\n      console.warn('Failed to notifyTransactionChanged after creating transaction items (sync path):', e)\n    }\n\n    return createdItemIds\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  async _resolvePreviousProjectLink(\n    accountId: string,\n    item: Item,\n    projectId: string\n  ): Promise<{\n    previousProjectTransactionId: string | null;\n    previousProjectId: string | null;\n  }> {\n    const currentTransactionId = item.transactionId\n    const currentProjectId = item.projectId ?? projectId\n    const isCanonicalSale = currentTransactionId ? currentTransactionId.startsWith('INV_SALE_') : false\n\n    if (currentTransactionId && !isCanonicalSale) {\n      return {\n        previousProjectTransactionId: currentTransactionId,\n        previousProjectId: currentProjectId\n      }\n    }\n\n    return {\n      previousProjectTransactionId: item.previousProjectTransactionId ?? null,\n      previousProjectId: item.previousProjectId ?? null\n    }\n  },\n\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('üîÑ handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('‚è≠Ô∏è Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('üîç Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(accountId, itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('‚úÖ Item found:', item.itemId, 'disposition:', item.disposition, 'projectId:', item.projectId)\n\n      const {\n        previousProjectTransactionId,\n        previousProjectId\n      } = await this._resolvePreviousProjectLink(accountId, item, projectId)\n\n      // If the item is currently linked to an INV_PURCHASE for the same project,\n      // this is a purchase-reversion: remove it from the purchase and return it\n      // to inventory instead of creating an INV_SALE. This prevents creating\n      // both INV_PURCHASE and INV_SALE canonical transactions for the same\n      // item/project.\n      if (item.transactionId && item.transactionId.startsWith('INV_PURCHASE_')) {\n        const purchaseProjectId = item.transactionId.replace('INV_PURCHASE_', '')\n        if (purchaseProjectId === projectId) {\n          console.log('üîÅ Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory')\n\n          // Remove item from the existing purchase (will delete if empty)\n          await unifiedItemsService.removeItemFromTransaction(accountId, item.itemId, item.transactionId, item.projectPrice || item.marketValue || '0.00')\n\n          // Update the item to reflect it's back in business inventory\n          await unifiedItemsService.updateItem(accountId, item.itemId, {\n            projectId: null,\n            inventoryStatus: 'available',\n            transactionId: null,\n            previousProjectTransactionId,\n            previousProjectId,\n            lastUpdated: new Date().toISOString()\n          })\n\n          try {\n            await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, item.transactionId, {\n              action: 'deallocation_completed',\n              scenario: 'purchase_reversion',\n              from_transaction: item.transactionId,\n              to_status: 'inventory',\n              amount: item.projectPrice || item.marketValue || '0.00'\n            })\n          } catch (auditError) {\n            console.warn('‚ö†Ô∏è Failed to log deallocation completion for purchase-reversion:', auditError)\n          }\n\n          console.log('‚úÖ Purchase-reversion handled: item returned to inventory without creating INV_SALE')\n          return\n        }\n      }\n\n      // Unified approach: Always create/update a \"Sale\" transaction for inventory designation (project selling TO us)\n      console.log('üè¶ Creating/updating Sale transaction for inventory designation')\n\n      // Log deallocation start (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent(accountId, 'deallocation', itemId, item.projectId ?? null, item.transactionId ?? null, {\n          action: 'deallocation_started',\n          target_status: 'inventory',\n          current_transaction_id: item.transactionId\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation start:', auditError)\n      }\n\n      const transactionId = await this.ensureSaleTransaction(\n        accountId,\n        item,\n        projectId,\n        'Transaction for items purchased from project and moved to business inventory',\n        {\n          previousProjectTransactionId,\n          previousProjectId\n        }\n      )\n\n      console.log('üì¶ Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(accountId, item.itemId, {\n        projectId: null,\n        inventoryStatus: 'available',\n        transactionId: transactionId,\n        space: '', // Clear space field when moving to business inventory\n        previousProjectTransactionId,\n        previousProjectId,\n        lastUpdated: new Date().toISOString()\n      })\n\n      // Append lineage edge and update pointers\n      try {\n        const fromTransactionId = item.transactionId || null\n        await lineageService.appendItemLineageEdge(accountId, item.itemId, fromTransactionId, transactionId)\n        await lineageService.updateItemLineagePointers(accountId, item.itemId, transactionId)\n      } catch (lineageError) {\n        console.warn('‚ö†Ô∏è Failed to append lineage edge (non-critical):', lineageError)\n      }\n\n      // Log successful deallocation (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent(accountId, 'deallocation', itemId, null, transactionId, {\n          action: 'deallocation_completed',\n          from_project_id: item.projectId,\n          to_transaction: transactionId,\n          amount: item.projectPrice || item.marketValue || '0.00'\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n      }\n\n      console.log('‚úÖ Item moved to business inventory successfully')\n\n      console.log('‚úÖ Deallocation completed successfully')\n    } catch (error) {\n      console.error('‚ùå Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a sale transaction exists for inventory designation (follows ALLOCATION_TRANSACTION_LOGIC.md)\n  async ensureSaleTransaction(\n    accountId: string,\n    item: Item,\n    projectId: string,\n    additionalNotes?: string,\n    previousLink?: {\n      previousProjectTransactionId: string | null;\n      previousProjectId: string | null;\n    }\n  ): Promise<string | null> {\n    await ensureAuthenticatedForDatabase()\n\n    // Get current user ID for created_by field\n    const currentUser = await getCurrentUser()\n    if (!currentUser?.id) {\n      throw new Error('User must be authenticated to create transactions')\n    }\n\n    console.log('üè¶ Creating/updating sale transaction for item:', item.itemId)\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(accountId, projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Defensive check: if the item is still linked to a purchase for this\n    // project, treat as purchase-reversion and do not create an INV_SALE.\n    if (item.transactionId && item.transactionId.startsWith('INV_PURCHASE_')) {\n      const purchaseProjectId = item.transactionId.replace('INV_PURCHASE_', '')\n      if (purchaseProjectId === projectId) {\n        console.log('‚ÑπÔ∏è ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE')\n\n        // Remove the item from the purchase and return to inventory\n        await unifiedItemsService.removeItemFromTransaction(accountId, item.itemId, item.transactionId, item.projectPrice || item.marketValue || '0.00')\n        await unifiedItemsService.updateItem(accountId, item.itemId, {\n          projectId: null,\n          inventoryStatus: 'available',\n          transactionId: null,\n          previousProjectTransactionId: previousLink?.previousProjectTransactionId ?? item.transactionId,\n          previousProjectId: previousLink?.previousProjectId ?? item.projectId ?? projectId\n        })\n\n        // Return null to indicate no INV_SALE was created\n        return null\n      }\n    }\n\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n    console.log('üîë Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists (account-scoped)\n    const { data: existingTransaction, error: fetchError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('account_id', accountId)\n      .eq('transaction_id', canonicalTransactionId)\n      .single()\n\n    if (existingTransaction && !fetchError) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingItemIds = existingTransaction.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.itemId])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const { data: itemsData, error: itemsError } = await supabase\n        .from('items')\n        .select('project_price, market_value')\n        .eq('account_id', accountId)\n        .in('item_id', updatedItemIds)\n\n      if (itemsError) throw itemsError\n\n      const totalAmount = (itemsData || [])\n        .map(item => item.project_price || item.market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const now = new Date()\n      const updatedTransactionData = {\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        updated_at: now.toISOString()\n      }\n\n      const { error: updateError } = await supabase\n        .from('transactions')\n        .update(updatedTransactionData)\n        .eq('account_id', accountId)\n        .eq('transaction_id', canonicalTransactionId)\n\n      if (updateError) throw updateError\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // Calculate amount from item for new transaction\n      const calculatedAmount = item.projectPrice || item.marketValue || '0.00'\n\n      // New transaction - create Sale transaction (project moving item TO inventory)\n      const now = new Date()\n      const transactionData = {\n        account_id: accountId,\n        transaction_id: canonicalTransactionId,\n        project_id: projectId,\n        transaction_date: toDateOnlyString(now),\n        source: projectName,  // Project name as source (project moving to inventory)\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: parseFloat(calculatedAmount || '0').toFixed(2),\n        budget_category: 'Furnishings',\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: COMPANY_OWES_CLIENT,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [item.itemId],\n        created_by: currentUser.id,\n        created_at: now.toISOString(),\n        updated_at: now.toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      // Insert the transaction (we've already checked it doesn't exist above)\n      const { error: insertError } = await supabase\n        .from('transactions')\n        .insert(transactionData)\n\n      if (insertError) throw insertError\n    }\n\n    console.log('‚úÖ Sale transaction created/updated successfully')\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(accountId, itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    accountId: string,\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(accountId, itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    accountId: string,\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction(accountId, 'sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    accountId: string,\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(accountId, itemId, projectId, disposition)\n  }\n}\n"],"names":["toDate","value","error","year","month","day","date","formatDate","fallback","options","mergedOptions","formatCurrency","amount","num","toDateOnlyString","d","yyyy","mm","dd","lineageService","accountId","itemId","fromTransactionId","toTransactionId","note","ensureAuthenticatedForDatabase","user","getCurrentUser","createdBy","fiveSecondsAgo","recentEdges","supabase","data","latestTransactionId","originTransactionId","updates","currentItem","edge","transactionId","edgeId","callback","filterParts","filter","channelName","channel","payload","err","status","dbEdge","auditService","eventType","projectId","transactionIdOrDetails","detailsOrUndefined","details","changeType","oldState","newState","projectService","project","converted","convertTimestamps","projectData","updateData","initialProjects","projects","newRecord","oldRecord","updatedProject","p","oldId","dbProject","_convertTransactionFromDb","dbTransaction","_enrichTransactionsWithProjectNames","transactions","tx","id","projectMap","projectName","_convertTransactionToDb","transaction","_adjustSumItemPurchasePrices","delta","currentRaw","current","deltaNum","newSumStr","updateError","transactionService","opts","e","debounceMs","projectIds","_projectId","items","unifiedItemsService","combinedItems","edgesFromTransaction","missingMovedItemIds","it","movedItemsPromises","validMovedItems","mi","edgeErr","itemsNetTotal","sum","item","purchasePrice","itemsCount","itemsMissingPriceCount","transactionAmount","transactionSubtotal","inferredTax","taxAmount","missingTaxData","taxRate","completenessRatio","varianceDollars","variancePercent","completenessStatus","ratio","needs","dbUpdates","key","remaining","proxy","resolve","reject","checkInterval","count","shortStack","resolveFn","rejectFn","transactionSource","limit","transactionData","currentUser","now","amountNum","subtotalNum","rate","preset","getTaxPresetById","itemsToCreate","i","createdItemIds","finalUpdates","existing","existingData","amountVal","subtotalVal","initialTransactions","newProjectId","oldProjectId","matchesProject","candidate","newTransaction","enrichedTransaction","t","updatedTransaction","wasInProject","isInProject","sortedTransactions","a","b","enriched","CLIENT_OWES_COMPANY","COMPANY_OWES_CLIENT","dbItem","filters","pagination","query","offset","initialItems","updatedItem","_filters","itemData","qrKey","txData","computeTaxString","priceStr","ratePct","priceNum","txId","purchasePriceRaw","existingItem","willSetTransaction","missingTax","prevTx","newTx","projectForTx","affected","prevPrice","newPrice","notes","space","finalAmount","currentTransactionId","auditError","purchaseTransactionId","lineageError","restoredTransactionId","restorationStatus","previousTransactionId","previousProjectId","baseUpdate","previousTransaction","previousTransactionError","auditDetails","_notes","saleTransactionId","_itemAmount","fetchError","updatedItemIds","deleteError","itemsData","itemsError","totalAmount","price","safeAmount","transactionType","triggerEvent","existingTransaction","existingItemIds","txTax","linkErr","insertError","itemIds","allocationData","canonicalTransactionId","updatedTransactionData","previousProjectTransactionId","_a","_b","paymentMethod","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","transaction_date","taxRatePct","inheritedTax","txError","itemsToInsert","deltaSum","deallocationService","currentProjectId","isCanonicalSale","disposition","additionalNotes","previousLink","calculatedAmount","integrationService","_transactionId","_itemId"],"mappings":"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"}