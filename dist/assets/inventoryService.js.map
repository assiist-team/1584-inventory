{"version":3,"file":"inventoryService.js","sources":["../../src/services/inventoryService.ts"],"sourcesContent":["import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField\n} from 'firebase/firestore'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, BusinessInventoryStats } from '@/types'\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project (top-level collection)\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction (top-level only - post-migration)\n  async getTransaction(_projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory) - top-level only\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction: {\n          transaction_id: transactionSnap.id,\n          ...transactionData\n        } as Transaction,\n        projectId: data.project_id || null\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction (top-level collection)\n  async createTransaction(\n    projectId: string | null | undefined,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        project_id: projectId,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      const docRef = await addDoc(transactionsRef, newTransaction)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          projectId || '',\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          items\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction (top-level collection)\n  async updateTransaction(_projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    // Filter out undefined values to prevent Firebase errors\n    const cleanUpdates: any = {}\n    Object.keys(finalUpdates).forEach(key => {\n      if (finalUpdates[key] !== undefined) {\n        cleanUpdates[key] = finalUpdates[key]\n      }\n    })\n\n    await updateDoc(transactionRef, cleanUpdates)\n  },\n\n  // Delete transaction (top-level collection)\n  async deleteTransaction(_projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions (top-level collection)\n  subscribeToTransactions(_projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', _projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates (top-level collection)\n  subscribeToTransaction(\n    _projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'cancelled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = new Date().toISOString()\n    }\n\n    await updateDoc(transactionRef, updateData)\n  },\n\n  // Utility queries for Business Inventory and reporting (top-level collection)\n  async getInventoryRelatedTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('reimbursement_type', 'in', ['Client Owes', 'We Owe']),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get business inventory transactions (project_id == null)\n  async getBusinessInventoryTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', null),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Get items for a project (project_id == projectId)\n  async getItemsByProject(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('project_price', '>=', filters.priceRange.min),\n        where('project_price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery && items.length > 0) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.payment_method.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to items for a project\n  subscribeToItemsByProject(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Get business inventory items (project_id == null)\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Create new item\n  async createItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.project_id !== undefined) firebaseUpdates.project_id = updates.project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.transaction_id !== undefined) firebaseUpdates.transaction_id = updates.transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete item\n  async deleteItem(itemId: string): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get items for a transaction (by transaction_id)\n  async getItemsForTransaction(_projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n  },\n\n  // Allocate single item to project (creates/updates INV_PURCHASE_<projectId> transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine the amount if not provided\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Use canonical transaction ID for inventory purchases\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Check if the canonical transaction already exists and update it\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    let itemIds: string[]\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('📋 Existing INV_PURCHASE transaction found, updating with new item')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      itemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const itemsRef = collection(db, 'items')\n      const itemsQuery = query(itemsRef, where('__name__', 'in', itemIds))\n      const itemsSnapshot = await getDocs(itemsQuery)\n\n      const totalAmount = itemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        ...existingData,\n        item_ids: itemIds,\n        amount: totalAmount,\n        notes: notes || existingData.notes || 'Transaction for items purchased from business inventory and allocated to project',  // Preserve existing notes or use canonical\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, updatedTransactionData, { merge: true })\n\n      console.log('🔄 Updated INV_PURCHASE transaction with', itemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // New transaction - calculate amount from current item\n      itemIds = [itemId]\n      const transactionData = {\n        project_id: projectId,\n        project_name: null, // Will be filled in later if needed\n        transaction_date: new Date().toISOString(),\n        source: 'Inventory',  // Project purchasing inventory from 1584\n        transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n        payment_method: 'Pending',\n        amount: finalAmount,\n        budget_category: 'Furnishings',\n        notes: notes || 'Transaction for items purchased from business inventory and allocated to project',  // Generic notes for multiple items\n        status: 'pending' as const,\n        reimbursement_type: 'Client Owes' as const,\n        trigger_event: 'Inventory allocation' as const,\n        item_ids: itemIds,\n        created_by: 'system',\n        created_at: new Date().toISOString(),\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, transactionData, { merge: true })\n\n      console.log('🆕 Creating new INV_PURCHASE transaction with amount:', finalAmount)\n    }\n\n    // Update the item in the unified collection\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'pending',\n      transaction_id: canonicalTransactionId,\n      disposition: 'keep'\n    })\n\n    return canonicalTransactionId\n  },\n\n  // Batch allocate multiple items to project (updates INV_PURCHASE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the business inventory items first\n    const itemsRef = collection(db, 'items')\n    const itemsQuery = query(itemsRef, where('__name__', 'in', itemIds), where('project_id', '==', null))\n    const itemsSnapshot = await getDocs(itemsQuery)\n\n    if (itemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Use canonical transaction ID for inventory purchases\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Check if the canonical transaction already exists and get all items that should be in it\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    let allItemIds: string[]\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new items with existing ones\n      console.log('📋 Existing INV_PURCHASE transaction found, updating with new items')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      allItemIds = [...new Set([...existingItemIds, ...itemIds])] // Combine and deduplicate\n\n      // Get all items to recalculate amount\n      const allItemsQuery = query(itemsRef, where('__name__', 'in', allItemIds))\n      const allItemsSnapshot = await getDocs(allItemsQuery)\n\n      const totalAmount = allocationData.amount || allItemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        ...existingData,\n        item_ids: allItemIds,\n        amount: totalAmount,\n        notes: allocationData.notes || existingData.notes || 'Transaction for items purchased from business inventory and allocated to project',\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, updatedTransactionData, { merge: true })\n\n      console.log('🔄 Updated INV_PURCHASE transaction with', allItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // New transaction - use provided items\n      allItemIds = itemIds\n      const totalAmount = allocationData.amount || itemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum, price) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const transactionData = {\n        project_id: projectId,\n        transaction_date: new Date().toISOString(),\n        source: 'Inventory',  // Project purchasing inventory from 1584\n        transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n        payment_method: 'Pending',\n        amount: totalAmount,\n        budget_category: 'Furnishings',\n        notes: allocationData.notes || 'Transaction for items purchased from business inventory and allocated to project',  // Generic notes for multiple items\n        status: 'pending' as const,\n        reimbursement_type: 'Client Owes' as const,\n        trigger_event: 'Inventory allocation' as const,\n        item_ids: allItemIds,\n        created_by: 'system',\n        last_updated: new Date().toISOString()\n      }\n\n      console.log('🆕 Creating new INV_PURCHASE transaction with amount:', totalAmount)\n\n      await setDoc(transactionRef, transactionData, { merge: true })\n    }\n\n    // Update all items in the unified collection\n    const batch = writeBatch(db)\n    itemsSnapshot.docs.forEach((itemDoc) => {\n      const itemId = itemDoc.id\n      batch.update(doc(db, 'items', itemId), {\n        project_id: projectId,\n        inventory_status: 'pending',\n        transaction_id: canonicalTransactionId,\n        disposition: 'keep',\n        last_updated: new Date().toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (creates/updates INV_SALE_<projectId> transaction)\n  async returnItemFromProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Use canonical transaction ID for inventory sales\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n\n    // Calculate amount (use project_price for sale transactions)\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Upsert the canonical transaction\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionData = {\n      project_id: projectId,\n      project_name: null, // Will be filled in later if needed\n      transaction_date: new Date().toISOString(),\n      source: projectName,  // Use project name as source when \"other\" is selected\n      transaction_type: 'To Inventory',  // Correct transaction type for inventory operations\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Transaction for items purchased from project and moved to business inventory',  // Generic notes for multiple items\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Inventory return' as const,\n      item_ids: [itemId],\n      created_by: 'system',\n      created_at: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    }\n\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update the item in the unified collection\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: canonicalTransactionId\n    })\n\n    return canonicalTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_PURCHASE_${projectId}`\n\n    // Get the transaction\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      throw new Error('Transaction not found')\n    }\n\n    const transactionData = transactionSnap.data()\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      payment_method: paymentMethod,\n      transaction_date: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    })\n\n    // Clear transaction_id from all linked items\n    const batch = writeBatch(db)\n    for (const itemId of itemIds) {\n      const itemRef = doc(db, 'items', itemId)\n      if (transactionType === 'sale') {\n        // For sales, keep project_id but clear transaction_id and set status to sold\n        batch.update(itemRef, {\n          transaction_id: null,\n          inventory_status: 'sold',\n          last_updated: new Date().toISOString()\n        })\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        batch.update(itemRef, {\n          project_id: null,\n          transaction_id: null,\n          inventory_status: 'available',\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    await batch.commit()\n  },\n\n  // Helper function to get item by ID\n  async getItemById(itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate an existing item (unified collection version)\n  async duplicateItem(projectId: string, originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getItemById(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transaction_id,\n      project_id: projectId,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'items', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version)\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    items: TransactionItemFormData[]\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    items.forEach((itemData) => {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        project_price: itemData.project_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || '',\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transactionDate,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      } as Item\n\n      batch.set(itemRef, item)\n    })\n\n    await batch.commit()\n    return createdItemIds\n  }\n}\n\n// Business Inventory Services (DEPRECATED - use unifiedItemsService instead)\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<Item | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate a business inventory item\n  async duplicateBusinessInventoryItem(originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getBusinessInventoryItem(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original business inventory item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `BI-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes || '',\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      inventory_status: 'available', // Default status for duplicates\n      business_inventory_location: originalItem.business_inventory_location || '',\n      transaction_id: originalItem.transaction_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'business_inventory', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let pendingItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'pending':\n          pendingItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      pendingItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item to determine the amount if not provided\n    const item = await this.getBusinessInventoryItem(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to pending and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'pending',\n      transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: now.toISOString(),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        project_price: businessItemData.project_price, // 1584 design project price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes || '',\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItems = await unifiedItemsService.getItemsByProject(projectId)\n    const currentItemCount = currentItems.length\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n  async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'cancelled'\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: new Date().toISOString(),\n      payment_method: paymentMethod\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Client Purchase',\n      transaction_type: 'Purchase',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('🔄 handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('⏭️ Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('🔍 Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('✅ Item found:', item.item_id, 'disposition:', item.disposition, 'project_id:', item.project_id)\n\n      // Unified approach: Always create/update a \"We Owe\" transaction for inventory designation\n      console.log('🏦 Creating/updating We Owe transaction for inventory designation')\n      const transactionId = await this.ensurePurchaseTransaction(\n        item,\n        projectId\n        // Remove the problematic additionalNotes parameter that creates inflexible text fields\n      )\n\n      console.log('📦 Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(item.item_id, {\n        project_id: null,\n        inventory_status: 'available',\n        transaction_id: transactionId,\n        last_updated: new Date().toISOString()\n      })\n      console.log('✅ Item moved to business inventory successfully')\n\n      console.log('✅ Deallocation completed successfully')\n    } catch (error) {\n      console.error('❌ Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a sale transaction exists for inventory designation\n  async ensurePurchaseTransaction(\n    item: Item,\n    projectId: string,\n    additionalNotes?: string\n  ): Promise<string> {\n    console.log('🏦 Creating/updating sale transaction for item:', item.item_id)\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n    console.log('🔑 Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists (top-level collection)\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    const transactionData = {\n      project_id: projectId,\n      project_name: null, // Will be filled in later if needed\n      transaction_date: new Date().toISOString(),\n      source: projectName,  // Use project name as source when \"other\" is selected\n      transaction_type: 'To Inventory',  // Correct transaction type for inventory operations\n      payment_method: 'Pending',\n      budget_category: 'Furnishings',\n      notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',  // Generic notes for multiple items\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Inventory return' as const,\n      item_ids: [item.item_id], // Start with current item\n      created_by: 'system',\n      created_at: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    }\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('📋 Existing INV_SALE transaction found, updating with new item')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.item_id])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const itemsRef = collection(db, 'items')\n      const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n      const itemsSnapshot = await getDocs(itemsQuery)\n\n      const totalAmount = itemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        ...existingData,\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: 'Transaction for items purchased from project and moved to business inventory',  // Generic notes for multiple items\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, updatedTransactionData, { merge: true })\n\n      console.log('🔄 Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n      // New transaction - calculate amount from current item\n      const itemAmount = item.project_price || item.market_value || '0.00'\n      const newTransactionData = {\n        ...transactionData,\n        amount: parseFloat(itemAmount || '0').toFixed(2)\n      }\n\n      console.log('🆕 Creating new INV_SALE transaction with amount:', newTransactionData.amount)\n\n      await setDoc(transactionRef, newTransactionData, { merge: true })\n    }\n\n    console.log('✅ Transaction created/updated successfully')\n\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction('sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(itemId, projectId, disposition)\n  }\n}\n"],"names":["projectService","ensureAuthenticatedForStorage","projectsRef","collection","db","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectId","projectRef","projectSnap","getDoc","projectData","now","newProject","addDoc","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","transactionService","transactionsRef","where","transactionData","_projectId","transactionId","transactionRef","transactionSnap","items","newTransaction","createdItemIds","unifiedItemsService","error","finalUpdates","deleteField","cleanUpdates","key","transactions","transaction","status","updateData","filters","pagination","itemsRef","searchTerm","limit","item","_a","itemData","newItem","itemId","itemRef","firebaseUpdates","amount","notes","finalAmount","canonicalTransactionId","itemIds","existingData","existingItemIds","itemsQuery","totalAmount","sum","price","updatedTransactionData","setDoc","allocationData","itemsSnapshot","allItemIds","allItemsQuery","allItemsSnapshot","batch","writeBatch","itemDoc","projectName","project","transactionType","paymentMethod","itemSnap","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","transactionDate","transactionSource","qrKey","businessInventoryService","getCountFromServer","allItemsSnap","availableItems","pendingItems","soldItems","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","projectItemsRef","itemQuery","newBusinessItem","deallocationService","disposition","additionalNotes","updatedItemIds","itemAmount","newTransactionData","integrationService","_transactionId","_itemId"],"mappings":"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"}