{"version":3,"file":"inventoryService.js","sources":["../../src/services/inventoryService.ts"],"sourcesContent":["import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField\n} from 'firebase/firestore'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, ItemImage, BusinessInventoryItem, BusinessInventoryStats } from '@/types'\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services\nexport const itemService = {\n  // Get items for a project with filtering and pagination\n  async getItems(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('price', '>=', filters.priceRange.min),\n        where('price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        // This is a simplified pagination - in production you'd use cursor-based pagination\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery && items.length > 0) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n    return items\n  },\n\n\n  // Get single item\n  async getItem(projectId: string, itemId: string): Promise<Item | null> {\n    console.log('getItem called with:', { projectId, itemId })\n\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    console.log('Document path:', itemRef.path)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      const data = itemSnap.data()\n      console.log('Raw Firebase data:', data)\n      console.log('Images in Firebase:', data.images?.length || 0, 'images')\n\n      const mappedItem = {\n        item_id: itemSnap.id,\n        description: data.description,\n        source: data.source,\n        sku: data.sku,\n        purchase_price: data.purchase_price,\n        resale_price: data.resale_price,\n        market_value: data.market_value, // Direct mapping\n        payment_method: data.payment_method,\n        disposition: data.disposition,\n        notes: data.notes,\n        space: data.space, // Add space field\n        qr_key: data.qr_key,\n        bookmark: data.bookmark,\n        transaction_id: data.transaction_id,\n        project_id: data.project_id,\n        date_created: data.date_created,\n        last_updated: data.last_updated,\n        images: data.images || [] // Include images from Firebase\n      } as Item\n\n      console.log('Mapped item data:', mappedItem)\n      console.log('Mapped images:', mappedItem.images?.length || 0, 'images')\n      return mappedItem\n    }\n    console.log('Document does not exist at path:', itemRef.path)\n    console.log('itemSnap.exists():', itemSnap.exists())\n    console.log('Item not found')\n    return null\n  },\n\n  // Create new item\n  async createItem(projectId: string, itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const now = new Date()\n\n    // Map form fields to Firebase fields\n    const newItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      purchase_price: itemData.purchase_price,\n      resale_price: itemData.resale_price,\n      market_value: itemData.market_value, // Direct mapping\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep', // Default to 'keep' if not provided\n      notes: itemData.notes,\n      space: itemData.space, // Add space field\n      qr_key: itemData.qr_key || `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`,\n      bookmark: itemData.bookmark,\n      transaction_id: itemData.transaction_id,\n      project_id: itemData.project_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n\n    // Update project metadata\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: await itemService.getItemCount(projectId) + 1,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(projectId: string, itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n\n    // Map form fields to Firebase fields for updates\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.resale_price !== undefined) firebaseUpdates.resale_price = updates.resale_price\n    if (updates.market_value !== undefined) {\n      firebaseUpdates.market_value = updates.market_value // Direct mapping\n    }\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space // Add space field\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) {\n      console.log('Updating item images:', updates.images?.length, 'images')\n      firebaseUpdates.images = updates.images\n    }\n\n    console.log('Updating item in database:', itemId, 'with updates:', Object.keys(firebaseUpdates))\n    await updateDoc(itemRef, firebaseUpdates)\n    console.log('Item updated successfully in database')\n  },\n\n  // Add image to item\n  async addItemImage(projectId: string, itemId: string, image: ItemImage): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n    const updatedImages = [...currentImages, image]\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Update item images\n  async updateItemImages(projectId: string, itemId: string, images: ItemImage[]): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await updateDoc(itemRef, {\n      images: images,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Remove image from item\n  async removeItemImage(projectId: string, itemId: string, imageUrl: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n    const updatedImages = currentImages.filter((img: ItemImage) => img.url !== imageUrl)\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Set primary image\n  async setPrimaryImage(projectId: string, itemId: string, imageUrl: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (!itemSnap.exists()) {\n      throw new Error('Item not found')\n    }\n\n    const itemData = itemSnap.data()\n    const currentImages = itemData.images || []\n\n    const updatedImages = currentImages.map((img: ItemImage) => ({\n      ...img,\n      isPrimary: img.url === imageUrl\n    }))\n\n    await updateDoc(itemRef, {\n      images: updatedImages,\n      last_updated: new Date().toISOString()\n    })\n  },\n\n  // Delete item\n  async deleteItem(projectId: string, itemId: string): Promise<void> {\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await deleteDoc(itemRef)\n\n    // Update project metadata\n    const now = new Date()\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: Math.max(0, await itemService.getItemCount(projectId) - 1),\n        lastActivity: now\n      }\n    } as Partial<Project>)\n  },\n\n  // Get item count for a project\n  async getItemCount(projectId: string): Promise<number> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const snapshot = await getCountFromServer(itemsRef)\n    return snapshot.data().count\n  },\n\n  // Subscribe to items\n  subscribeToItems(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    // Apply server-side filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      console.log('Real-time items snapshot received:', snapshot.docs.length, 'documents')\n      let items = snapshot.docs.map(doc => {\n        const data = doc.data()\n        const item = {\n          item_id: doc.id,\n          description: data.description,\n          source: data.source,\n          sku: data.sku,\n          purchase_price: data.purchase_price,\n          resale_price: data.resale_price,\n          market_value: data.market_value, // Direct mapping\n          payment_method: data.payment_method,\n          disposition: data.disposition,\n          notes: data.notes,\n          space: data.space, // Add space field\n          qr_key: data.qr_key,\n          bookmark: data.bookmark,\n          transaction_id: data.transaction_id,\n          project_id: data.project_id,\n          date_created: data.date_created,\n          last_updated: data.last_updated,\n          images: data.images || [] // Include images from Firebase\n        } as Item\n        return item\n      })\n\n      // Apply client-side filters\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      console.log('Real-time items callback with', items.length, 'items')\n      callback(items)\n    })\n  },\n\n  // Search items\n  async searchItems(projectId: string, searchQuery: string): Promise<Item[]> {\n    if (searchQuery.length < 2) return []\n\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const q = query(\n      itemsRef,\n      where('description', '>=', searchQuery.toLowerCase()),\n      where('description', '<=', searchQuery.toLowerCase() + '\\uf8ff'),\n      orderBy('description'),\n      limit(20)\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => {\n      const data = doc.data()\n      return {\n        item_id: doc.id,\n        description: data.description,\n        source: data.source,\n        sku: data.sku,\n        purchase_price: data.purchase_price,\n        resale_price: data.resale_price,\n        market_value: data.market_value, // Direct mapping\n        payment_method: data.payment_method,\n        disposition: data.disposition,\n        notes: data.notes,\n        space: data.space, // Add space field\n        qr_key: data.qr_key,\n        bookmark: data.bookmark,\n        transaction_id: data.transaction_id,\n        project_id: data.project_id,\n        date_created: data.date_created,\n        last_updated: data.last_updated\n      } as Item\n    })\n  },\n\n  // Batch operations\n  async batchUpdateItems(projectId: string, itemUpdates: Array<{ id: string; updates: Partial<Item> }>): Promise<void> {\n    const batch = writeBatch(db)\n\n    itemUpdates.forEach(({ id, updates }) => {\n      const itemRef = doc(db, 'projects', projectId, 'items', id)\n\n      // Map form fields to Firebase fields for batch updates\n      const firebaseUpdates: any = {\n        last_updated: new Date().toISOString()\n      }\n\n      if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n      if (updates.resale_price !== undefined) firebaseUpdates.resale_price = updates.resale_price\n      if (updates.market_value !== undefined) {\n        firebaseUpdates.market_value = updates.market_value // Direct mapping\n      }\n      if (updates.description !== undefined) firebaseUpdates.description = updates.description\n      if (updates.source !== undefined) firebaseUpdates.source = updates.source\n      if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n      if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n      if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n      if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n      if (updates.space !== undefined) firebaseUpdates.space = updates.space // Add space field\n      if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n\n      batch.update(itemRef, firebaseUpdates)\n    })\n\n    await batch.commit()\n  },\n\n  // Create multiple items linked to a transaction\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    items: TransactionItemFormData[]\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    items.forEach((itemData) => {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        resale_price: itemData.resale_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes || '',\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transactionDate,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      } as Item\n\n      batch.set(itemRef, item)\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const itemCount = await itemService.getItemCount(projectId)\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: itemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return createdItemIds\n  },\n\n  // Get items for a transaction\n  async getTransactionItems(projectId: string, transactionId: string): Promise<string[]> {\n    const itemsRef = collection(db, 'projects', projectId, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => doc.id)\n  },\n\n  // Add single item to existing transaction\n  async addItemToTransaction(\n    projectId: string,\n    transactionId: string,\n    transactionDate: string,\n    transactionSource: string,\n    itemData: TransactionItemFormData\n  ): Promise<string> {\n    const now = new Date()\n\n    const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    const item = {\n      item_id: itemId,\n      description: itemData.description,\n      source: transactionSource,\n      sku: itemData.sku || '',\n      purchase_price: itemData.purchase_price,\n      resale_price: itemData.resale_price,\n      market_value: itemData.market_value || '',\n      payment_method: 'Client Card', // Default payment method\n      disposition: 'keep',\n      notes: itemData.notes || '',\n      space: '', // Add space field\n      qr_key: qrKey,\n      bookmark: false,\n      transaction_id: transactionId,\n      project_id: projectId,\n      date_created: transactionDate,\n      last_updated: now.toISOString(),\n      images: [] // Start with empty images array, will be populated after upload\n    } as Item\n\n    // Create the document with the itemId as the document ID\n    const itemRef = doc(db, 'projects', projectId, 'items', itemId)\n    await setDoc(itemRef, item)\n\n    // Update project metadata\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: await itemService.getItemCount(projectId) + 1,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return itemId\n  }\n}\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction\n  async getTransaction(projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory)\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    // Get all projects first\n    const projects = await projectService.getProjects()\n\n    // Search through each project's transactions\n    for (const project of projects) {\n      try {\n        const transaction = await this.getTransaction(project.id, transactionId)\n        if (transaction) {\n          return { transaction, projectId: project.id }\n        }\n      } catch (error) {\n        console.error(`Error searching for transaction ${transactionId} in project ${project.id}:`, error)\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction\n  async createTransaction(\n    projectId: string,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      const docRef = await addDoc(transactionsRef, newTransaction)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        const createdItemIds = await itemService.createTransactionItems(\n          projectId,\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          items\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction\n  async updateTransaction(projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    await updateDoc(transactionRef, finalUpdates)\n  },\n\n  // Delete transaction\n  async deleteTransaction(projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions\n  subscribeToTransactions(projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(transactionsRef, orderBy('created_at', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates\n  subscribeToTransaction(\n    projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'cancelled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = new Date().toISOString()\n    }\n\n    await updateDoc(transactionRef, updateData)\n  }\n}\n\n// Business Inventory Services\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<BusinessInventoryItem[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as BusinessInventoryItem))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<BusinessInventoryItem | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as BusinessInventoryItem\n    }\n    return null\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<BusinessInventoryItem, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<BusinessInventoryItem>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.current_project_id !== undefined) firebaseUpdates.current_project_id = updates.current_project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.pending_transaction_id !== undefined) firebaseUpdates.pending_transaction_id = updates.pending_transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.resale_price !== undefined) firebaseUpdates.resale_price = updates.resale_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let pendingItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'pending':\n          pendingItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      pendingItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: BusinessInventoryItem[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as BusinessInventoryItem))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Item allocated from business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to pending and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'pending',\n      current_project_id: projectId,\n      pending_transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: now.toISOString(),\n      source: 'Batch Inventory Allocation',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `Batch allocation of ${itemIds.length} items from business inventory`,\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        resale_price: businessItemData.resale_price, // 1584 design resale price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes || '',\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        current_project_id: projectId,\n        pending_transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItemCount = await itemService.getItemCount(projectId)\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n  async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'cancelled'\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      current_project_id: undefined,\n      pending_transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: new Date().toISOString(),\n      payment_method: paymentMethod\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      current_project_id: undefined,\n      pending_transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: new Date().toISOString(),\n      source: 'Client Purchase',\n      transaction_type: 'Reimbursement',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    return await businessInventoryService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory\n  async returnItemToBusinessInventory(\n    itemId: string,\n    transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    return await businessInventoryService.returnItemFromProject(itemId, transactionId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold\n  async completePendingTransaction(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    return await businessInventoryService.markItemAsSold(itemId, transactionId, projectId, paymentMethod)\n  }\n}\n"],"names":["projectService","ensureAuthenticatedForStorage","projectsRef","collection","db","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectId","projectRef","projectSnap","getDoc","projectData","now","newProject","addDoc","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","itemService","filters","pagination","itemsRef","where","searchTerm","limit","items","item","itemId","itemRef","itemSnap","_a","mappedItem","_b","itemData","newItem","docRef","firebaseUpdates","image","updatedImages","images","imageUrl","img","getCountFromServer","searchQuery","itemUpdates","batch","writeBatch","id","transactionId","transactionDate","transactionSource","createdItemIds","qrKey","itemCount","setDoc","transactionService","transactionsRef","transactionData","transactionRef","transactionSnap","project","transaction","error","newTransaction","finalUpdates","deleteField","transactions","status","updateData","businessInventoryService","allItemsQuery","allItemsSnap","availableItems","pendingItems","soldItems","amount","notes","itemIds","allocationData","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","paymentMethod","projectItemsRef","itemQuery","newBusinessItem"],"mappings":"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"}