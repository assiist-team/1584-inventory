{"version":3,"file":"inventoryService.js","sources":["../../src/utils/dateUtils.ts","../../src/services/inventoryService.ts"],"sourcesContent":["import type { DateValue } from '@/types'\n\n/**\n * Safely converts various date representations to JavaScript Date objects\n */\nexport const toDate = (value: DateValue): Date | null => {\n  if (!value) return null\n\n  if (value instanceof Date) {\n    return value\n  }\n\n  // Handle Firestore Timestamp objects\n  if (typeof value === 'object' && value) {\n    // Check if it's a Firestore Timestamp with toDate method\n    if ('toDate' in value && typeof (value as any).toDate === 'function') {\n      try {\n        return (value as any).toDate()\n      } catch (error) {\n        console.warn('Failed to convert Firestore Timestamp to Date:', error)\n        return null\n      }\n    }\n\n    // Check if it's a Firestore Timestamp with seconds/nanoseconds\n    if ('seconds' in value && 'nanoseconds' in value) {\n      try {\n        return new Date((value as any).seconds * 1000 + (value as any).nanoseconds / 1000000)\n      } catch (error) {\n        console.warn('Failed to convert Firestore Timestamp to Date:', error)\n        return null\n      }\n    }\n  }\n\n  // Handle string dates\n  if (typeof value === 'string') {\n    try {\n      // Check if it's a date-only string (YYYY-MM-DD format)\n      // This avoids timezone conversion issues by parsing as local time\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        // Parse as local date to avoid timezone conversion\n        const [year, month, day] = value.split('-').map(Number)\n        const date = new Date(year, month - 1, day) // month is 0-indexed\n        return isNaN(date.getTime()) ? null : date\n      }\n\n      // For other date formats, use the original parsing\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to parse date string:', value, error)\n      return null\n    }\n  }\n\n  // Handle number (milliseconds since epoch)\n  if (typeof value === 'number') {\n    try {\n      const date = new Date(value)\n      return isNaN(date.getTime()) ? null : date\n    } catch (error) {\n      console.warn('Failed to convert number to Date:', value, error)\n      return null\n    }\n  }\n\n  return null\n}\n\n/**\n * Safely formats a date value to a localized string\n */\nexport const formatDate = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    })\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value with specific options\n */\nexport const formatDateTime = (value: DateValue, options?: Intl.DateTimeFormatOptions, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    const defaultOptions: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    }\n\n    const mergedOptions = { ...defaultOptions, ...options }\n    return date.toLocaleDateString('en-US', mergedOptions)\n  } catch (error) {\n    console.warn('Failed to format date:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Safely formats a date value as a time string\n */\nexport const formatTime = (value: DateValue, fallback: string = 'Unknown'): string => {\n  const date = toDate(value)\n  if (!date) return fallback\n\n  try {\n    return date.toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  } catch (error) {\n    console.warn('Failed to format time:', value, error)\n    return fallback\n  }\n}\n\n/**\n * Checks if a date value is valid\n */\nexport const isValidDate = (value: DateValue): boolean => {\n  return toDate(value) !== null\n}\n\n/**\n * Formats a currency amount with proper thousands separators and decimal places\n */\nexport const formatCurrency = (amount: string | number, fallback: string = '$0.00'): string => {\n  const num = typeof amount === 'string' ? parseFloat(amount) : amount\n\n  if (isNaN(num)) return fallback\n\n  return num.toLocaleString('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Formats a number with thousands separators (no currency symbol)\n */\nexport const formatNumber = (num: string | number, fallback: string = '0.00'): string => {\n  const value = typeof num === 'string' ? parseFloat(num) : num\n\n  if (isNaN(value)) return fallback\n\n  return value.toLocaleString('en-US', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  })\n}\n\n/**\n * Returns today's date as a date-only string in YYYY-MM-DD format (local time)\n */\nexport const getTodayDateString = (): string => {\n  const now = new Date()\n  const yyyy = now.getFullYear()\n  const mm = String(now.getMonth() + 1).padStart(2, '0')\n  const dd = String(now.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n/**\n * Converts an input date value to a date-only string (YYYY-MM-DD) if possible.\n * Returns an empty string when conversion fails or value is falsy.\n */\nexport const toDateOnlyString = (value: DateValue): string => {\n  if (!value) return ''\n  // Already a date-only string\n  if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n    return value\n  }\n  const d = toDate(value)\n  if (!d) return ''\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}`\n}\n\n","import {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  onSnapshot,\n  writeBatch,\n  getCountFromServer,\n  deleteField,\n  serverTimestamp\n} from 'firebase/firestore'\nimport { db, convertTimestamps, ensureAuthenticatedForStorage } from './firebase'\nimport { toDateOnlyString } from '@/utils/dateUtils'\nimport type { Item, Project, FilterOptions, PaginationOptions, Transaction, TransactionItemFormData, BusinessInventoryStats } from '@/types'\n\n// Audit Logging Service for allocation/de-allocation events\nexport const auditService = {\n  // Log allocation/de-allocation events\n  async logAllocationEvent(\n    eventType: 'allocation' | 'deallocation' | 'return',\n    itemId: string,\n    projectId: string | null,\n    transactionIdOrDetails: any,\n    detailsOrUndefined?: Record<string, any>\n  ): Promise<void> {\n    try {\n      // Handle different calling patterns\n      let transactionId: string | null | undefined = null\n      let details: Record<string, any> = {}\n\n      if (typeof transactionIdOrDetails === 'string') {\n        transactionId = transactionIdOrDetails\n        details = detailsOrUndefined || {}\n      } else {\n        transactionId = null\n        details = transactionIdOrDetails || {}\n      }\n\n      const auditRef = collection(db, 'audit_logs')\n      await addDoc(auditRef, {\n        event_type: eventType,\n        item_id: itemId,\n        project_id: projectId,\n        transaction_id: transactionId,\n        details: details,\n        timestamp: serverTimestamp(),\n        created_at: new Date().toISOString()\n      })\n      console.log(`üìã Audit logged: ${eventType} for item ${itemId}`)\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log audit event (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  },\n\n  // Log transaction state changes\n  async logTransactionStateChange(\n    transactionId: string,\n    changeType: 'created' | 'updated' | 'deleted',\n    oldState?: any,\n    newState?: any\n  ): Promise<void> {\n    try {\n      const auditRef = collection(db, 'transaction_audit_logs')\n      await addDoc(auditRef, {\n        transaction_id: transactionId,\n        change_type: changeType,\n        old_state: oldState,\n        new_state: newState,\n        timestamp: serverTimestamp(),\n        created_at: new Date().toISOString()\n      })\n      console.log(`üìã Transaction audit logged: ${changeType} for ${transactionId}`)\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to log transaction audit (non-critical):', error)\n      // Don't throw - audit logging failures shouldn't break the main flow\n    }\n  }\n}\n\n// Project Services\nexport const projectService = {\n  // Get all projects for current user\n  async getProjects(): Promise<Project[]> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n      return {\n        id: doc.id,\n        ...data\n      } as Project\n    })\n  },\n\n  // Get single project\n  async getProject(projectId: string): Promise<Project | null> {\n    // Ensure authentication before Firestore operations\n    await ensureAuthenticatedForStorage()\n\n    const projectRef = doc(db, 'projects', projectId)\n    const projectSnap = await getDoc(projectRef)\n\n    if (projectSnap.exists()) {\n      const data = convertTimestamps(projectSnap.data())\n      return {\n        id: projectSnap.id,\n        ...data\n      } as Project\n    }\n    return null\n  },\n\n  // Create new project\n  async createProject(projectData: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const projectsRef = collection(db, 'projects')\n    const now = new Date()\n\n    const newProject = {\n      ...projectData,\n      createdAt: now,\n      updatedAt: now\n    }\n\n    const docRef = await addDoc(projectsRef, newProject)\n    return docRef.id\n  },\n\n  // Update project\n  async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await updateDoc(projectRef, {\n      ...updates,\n      updatedAt: new Date()\n    })\n  },\n\n  // Delete project\n  async deleteProject(projectId: string): Promise<void> {\n    const projectRef = doc(db, 'projects', projectId)\n    await deleteDoc(projectRef)\n  },\n\n  // Subscribe to projects\n  subscribeToProjects(callback: (projects: Project[]) => void) {\n    const projectsRef = collection(db, 'projects')\n    const q = query(projectsRef, orderBy('updatedAt', 'desc'))\n\n    return onSnapshot(q, (snapshot) => {\n      const projects = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n        return {\n          id: doc.id,\n          ...data\n        } as Project\n      })\n      callback(projects)\n    })\n  }\n}\n\n// Item Services (REMOVED - migrated to unifiedItemsService)\n// This service was completely removed after successful migration to unified collection\n\n// Transaction Services\nexport const transactionService = {\n  // Get transactions for a project (top-level collection)\n  async getTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get single transaction (top-level only - post-migration)\n  async getTransaction(_projectId: string, transactionId: string): Promise<Transaction | null> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n\n      console.log('inventoryService - raw data:', data)\n      console.log('inventoryService - transaction_images:', data.transaction_images)\n      console.log('inventoryService - transaction_images type:', typeof data.transaction_images)\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      console.log('inventoryService - processed transactionData:', transactionData)\n\n      return {\n        transaction_id: transactionSnap.id,\n        ...transactionData\n      } as Transaction\n    }\n\n    return null\n  },\n\n  // Get transaction by ID across all projects (for business inventory) - top-level only\n  async getTransactionById(transactionId: string): Promise<{ transaction: Transaction | null; projectId: string | null }> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      const data = convertTimestamps(transactionSnap.data())\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction: {\n          transaction_id: transactionSnap.id,\n          ...transactionData\n        } as Transaction,\n        projectId: data.project_id || null\n      }\n    }\n\n    return { transaction: null, projectId: null }\n  },\n\n  // Create new transaction (top-level collection)\n  async createTransaction(\n    projectId: string | null | undefined,\n    transactionData: Omit<Transaction, 'transaction_id' | 'created_at'>,\n    items?: TransactionItemFormData[]\n  ): Promise<string> {\n    try {\n      const transactionsRef = collection(db, 'transactions')\n      const now = new Date()\n\n      const newTransaction = {\n        ...transactionData,\n        project_id: projectId,\n        created_at: now.toISOString(),\n        // Set default values for new fields if not provided\n        status: transactionData.status || 'completed',\n        reimbursement_type: transactionData.reimbursement_type || null,\n        trigger_event: transactionData.trigger_event || null\n      }\n\n      console.log('Creating transaction:', newTransaction)\n      console.log('Transaction items:', items)\n\n      const docRef = await addDoc(transactionsRef, newTransaction)\n      const transactionId = docRef.id\n      console.log('Transaction created successfully:', transactionId)\n\n      // Create items linked to this transaction if provided\n      if (items && items.length > 0) {\n        console.log('Creating items for transaction:', transactionId)\n        const createdItemIds = await unifiedItemsService.createTransactionItems(\n          projectId || '',\n          transactionId,\n          transactionData.transaction_date,\n          transactionData.source, // Pass transaction source to items\n          items\n        )\n        console.log('Created items:', createdItemIds)\n      }\n\n      return transactionId\n    } catch (error) {\n      console.error('Error creating transaction:', error)\n      throw error // Re-throw to preserve original error for debugging\n    }\n  },\n\n  // Update transaction (top-level collection)\n  async updateTransaction(_projectId: string, transactionId: string, updates: Partial<Transaction>): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    // Apply business rules for reimbursement type and status\n    const finalUpdates: any = { ...updates }\n\n    // If status is being set to 'completed', clear reimbursement_type\n    if (finalUpdates.status === 'completed' && finalUpdates.reimbursement_type !== undefined) {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to empty string, also clear it\n    if (finalUpdates.reimbursement_type === '') {\n      finalUpdates.reimbursement_type = deleteField()\n    }\n\n    // If reimbursement_type is being set to a non-empty value, ensure status is not 'completed'\n    if (finalUpdates.reimbursement_type && finalUpdates.status === 'completed') {\n      // Set status to 'pending' if reimbursement_type is being set to a non-empty value and status is 'completed'\n      finalUpdates.status = 'pending'\n    }\n\n    // Filter out undefined values to prevent Firebase errors\n    const cleanUpdates: any = {}\n    Object.keys(finalUpdates).forEach(key => {\n      if (finalUpdates[key] !== undefined) {\n        cleanUpdates[key] = finalUpdates[key]\n      }\n    })\n\n    await updateDoc(transactionRef, cleanUpdates)\n  },\n\n  // Delete transaction (top-level collection)\n  async deleteTransaction(_projectId: string, transactionId: string): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    await deleteDoc(transactionRef)\n  },\n\n  // Subscribe to transactions (top-level collection)\n  subscribeToTransactions(_projectId: string, callback: (transactions: Transaction[]) => void) {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', _projectId),\n      orderBy('created_at', 'desc')\n    )\n\n    return onSnapshot(q, (snapshot) => {\n      const transactions = snapshot.docs.map(doc => {\n        const data = convertTimestamps(doc.data())\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        return {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n      })\n      callback(transactions)\n    })\n  },\n\n  // Subscribe to single transaction for real-time updates (top-level collection)\n  subscribeToTransaction(\n    _projectId: string,\n    transactionId: string,\n    callback: (transaction: Transaction | null) => void\n  ) {\n    const transactionRef = doc(db, 'transactions', transactionId)\n\n    return onSnapshot(transactionRef, (doc) => {\n      if (doc.exists()) {\n        const data = convertTimestamps(doc.data())\n\n        console.log('inventoryService - real-time raw data:', data)\n        console.log('inventoryService - real-time transaction_images:', data.transaction_images)\n\n        const transactionData = {\n          ...data,\n          transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n          receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n          other_images: Array.isArray(data.other_images) ? data.other_images : []\n        }\n\n        console.log('inventoryService - real-time processed transactionData:', transactionData)\n\n        const transaction = {\n          transaction_id: doc.id,\n          ...transactionData\n        } as Transaction\n        callback(transaction)\n      } else {\n        callback(null)\n      }\n    })\n  },\n\n  // Get pending transactions for a project\n  async getPendingTransactions(projectId: string): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('status', '==', 'pending'),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Update transaction status (for completing/cancelling pending transactions)\n  async updateTransactionStatus(\n    projectId: string,\n    transactionId: string,\n    status: 'pending' | 'completed' | 'canceled',\n    updates?: Partial<Transaction>\n  ): Promise<void> {\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n\n    const updateData: any = {\n      status: status,\n      ...updates\n    }\n\n    // Set transaction_date to current time if completing\n    if (status === 'completed' && !updates?.transaction_date) {\n      updateData.transaction_date = toDateOnlyString(new Date())\n    }\n\n    // Add last_updated timestamp\n    updateData.last_updated = new Date().toISOString()\n\n    await updateDoc(transactionRef, updateData)\n  },\n\n  // Utility queries for Business Inventory and reporting (top-level collection)\n  async getInventoryRelatedTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('reimbursement_type', 'in', ['Client Owes', 'We Owe']),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  },\n\n  // Get business inventory transactions (project_id == null)\n  async getBusinessInventoryTransactions(): Promise<Transaction[]> {\n    const transactionsRef = collection(db, 'transactions')\n    const q = query(\n      transactionsRef,\n      where('project_id', '==', null),\n      orderBy('created_at', 'desc')\n    )\n\n    const querySnapshot = await getDocs(q)\n    return querySnapshot.docs.map(doc => {\n      const data = convertTimestamps(doc.data())\n\n      const transactionData = {\n        ...data,\n        transaction_images: Array.isArray(data.transaction_images) ? data.transaction_images : [],\n        receipt_images: Array.isArray(data.receipt_images) ? data.receipt_images : [],\n        other_images: Array.isArray(data.other_images) ? data.other_images : []\n      }\n\n      return {\n        transaction_id: doc.id,\n        ...transactionData\n      } as Transaction\n    })\n  }\n}\n\n// Unified Items Collection Services (NEW)\nexport const unifiedItemsService = {\n  // Get items for a project (project_id == projectId)\n  async getItemsByProject(\n    projectId: string,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.tags && filters.tags.length > 0) {\n      q = query(q, where('tags', 'array-contains-any', filters.tags))\n    }\n\n    if (filters?.priceRange) {\n      q = query(\n        q,\n        where('project_price', '>=', filters.priceRange.min),\n        where('project_price', '<=', filters.priceRange.max)\n      )\n    }\n\n    // Apply search\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    // Apply client-side filtering for complex queries\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery && items.length > 0) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.payment_method.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to items for a project\n  subscribeToItemsByProject(\n    projectId: string,\n    callback: (items: Item[]) => void,\n    filters?: FilterOptions\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', projectId), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('disposition', '==', filters.status))\n    }\n\n    if (filters?.category) {\n      q = query(q, where('source', '==', filters.category))\n    }\n\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      q = query(\n        q,\n        where('description', '>=', searchTerm),\n        where('description', '<=', searchTerm + '\\uf8ff')\n      )\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.payment_method.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Get business inventory items (project_id == null)\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null))\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'items')\n    let q = query(itemsRef, where('project_id', '==', null), orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Create new item\n  async createItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update item\n  async updateItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.project_id !== undefined) firebaseUpdates.project_id = updates.project_id\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.transaction_id !== undefined) firebaseUpdates.transaction_id = updates.transaction_id\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete item\n  async deleteItem(itemId: string): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get items for a transaction (by transaction_id)\n  async getItemsForTransaction(_projectId: string, transactionId: string): Promise<Item[]> {\n    await ensureAuthenticatedForStorage()\n\n    const itemsRef = collection(db, 'items')\n    const q = query(\n      itemsRef,\n      where('transaction_id', '==', transactionId),\n      orderBy('date_created', 'asc')\n    )\n\n    const querySnapshot = await getDocs(q)\n\n    return querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n  },\n\n  // Allocate single item to project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine current state and calculate amount\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n    const currentTransactionId: string | null = item.transaction_id || null\n\n    console.log('üîÑ Starting allocation process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.project_id,\n      finalAmount\n    })\n\n    // Log allocation start (catch errors to prevent cascading failures)\n    try {\n      await (auditService.logAllocationEvent as any)('allocation', itemId, item.project_id, currentTransactionId, {\n        action: 'allocation_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC from ALLOCATION_TRANSACTION_LOGIC.md\n\n    // Scenario A: Item currently in a Sale (Project X)\n    if (currentTransactionId?.startsWith('INV_SALE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n      if (currentProjectId === projectId) {\n        // A.1: Remove item from Sale and move to Inventory (delete Sale if empty)\n        console.log('üìã Scenario A.1: Item in Sale, allocating to same project ‚Üí move to inventory')\n        return await this.handleSaleToInventoryMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // A.2: Allocate to different project - remove from Sale, add to Purchase (Project Y)\n        console.log('üìã Scenario A.2: Item in Sale, allocating to different project')\n        return await this.handleSaleToDifferentProjectMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario B: Item currently in a Purchase (Project X)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // B.1: Allocate to same project - remove from Purchase, update amount, delete if empty\n        console.log('üìã Scenario B.1: Item in Purchase, allocating to same project')\n        return await this.handlePurchaseToInventoryMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      } else {\n        // B.2: Allocate to different project - remove from Purchase, add to Sale (Project Y)\n        console.log('üìã Scenario B.2: Item in Purchase, allocating to different project')\n        return await this.handlePurchaseToDifferentProjectMove(itemId, currentTransactionId, projectId, finalAmount, notes, space)\n      }\n    }\n\n    // Scenario C: Item in Inventory (no transaction)\n    // Only treat as inventory when there is no transaction_id. Previously this\n    // branch also treated items with a null project_id as inventory which\n    // incorrectly bypassed removal from existing INV_SALE_/INV_PURCHASE_\n    // transactions. Require absence of currentTransactionId to follow the\n    // inventory -> purchase flow.\n    if (!currentTransactionId) {\n      console.log('üìã Scenario C: Item in inventory, allocating to project')\n      return await this.handleInventoryToPurchaseMove(itemId, projectId, finalAmount, notes, space)\n    }\n\n    // Fallback: Unknown scenario, treat as new allocation\n    console.log('üìã Fallback: Unknown scenario, treating as new allocation')\n    return await this.handleInventoryToPurchaseMove(itemId, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle A.1 - Remove item from Sale (same project)\n  async handleSaleToPurchaseMove(\n    itemId: string,\n    currentTransactionId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Purchase (same project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle A.1 (authoritative) - Remove item from Sale and move to Inventory (same project)\n  async handleSaleToInventoryMove(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    // Per A.1: allocate back to the same project without creating an INV_PURCHASE\n    // i.e. set the item's project and mark as allocated, but do not attach a\n    // purchase transaction.\n    await this.updateItem(itemId, {\n      project_id: _projectId,\n      inventory_status: 'allocated',\n      transaction_id: null,\n      disposition: 'keep',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ A.1 completed: Sale ‚Üí Inventory (same project)')\n\n    // Log successful move (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, _projectId, null, {\n        action: 'allocation_completed',\n        scenario: 'A.1',\n        from_transaction: currentTransactionId,\n        to_status: 'allocated',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion (A.1):', auditError)\n    }\n\n    // Return original sale transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle A.2 - Remove item from Sale, add to Purchase (different project)\n  async handleSaleToDifferentProjectMove(\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${newProjectId}`\n\n    // Remove item from existing Sale transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Purchase transaction for new project (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: newProjectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ A.2 completed: Sale ‚Üí Purchase (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, newProjectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'A.2',\n        from_transaction: currentTransactionId,\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Handle B.1 - Remove item from Purchase (same project)\n  async handlePurchaseToInventoryMove(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    _notes?: string,\n    space?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      disposition: 'inventory',\n      notes: _notes,\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.1 completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful deallocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('deallocation', itemId, null, 'inventory', {\n        action: 'deallocation_completed',\n        scenario: 'B.1',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n    }\n\n    return currentTransactionId // Return the original transaction ID since item is now in inventory\n  },\n\n  // Helper: Handle B.2 - Remove item from Purchase, add to Sale (different project)\n  async handlePurchaseToDifferentProjectMove(\n    itemId: string,\n    currentTransactionId: string,\n    newProjectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const saleTransactionId = `INV_SALE_${newProjectId}`\n\n    // Remove item from existing Purchase transaction\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Add item to Sale transaction for new project (create if none)\n    await this.addItemToTransaction(itemId, saleTransactionId, finalAmount, 'To Inventory', 'Inventory sale', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: saleTransactionId,\n      disposition: 'inventory',\n      space: space ?? ''\n    })\n\n    console.log('‚úÖ B.2 completed: Purchase ‚Üí Sale (different project)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, null, saleTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'B.2',\n        from_transaction: currentTransactionId,\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Helper: Handle C - Add item to Purchase (new allocation)\n  async handleInventoryToPurchaseMove(\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string,\n    space?: string\n  ): Promise<string> {\n    const purchaseTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Add item to Purchase transaction (create if none)\n    await this.addItemToTransaction(itemId, purchaseTransactionId, finalAmount, 'Purchase', 'Inventory allocation', notes)\n\n    // Update item status\n    await this.updateItem(itemId, {\n      project_id: projectId,\n      inventory_status: 'allocated',\n      transaction_id: purchaseTransactionId,\n      disposition: 'keep',\n      space: space\n    })\n\n    console.log('‚úÖ C completed: Inventory ‚Üí Purchase (new allocation)')\n\n    // Log successful allocation (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('allocation', itemId, projectId, purchaseTransactionId, {\n        action: 'allocation_completed',\n        scenario: 'C',\n        from_status: 'inventory',\n        to_transaction: purchaseTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log allocation completion:', auditError)\n    }\n\n    return purchaseTransactionId\n  },\n\n  // Helper: Remove item from transaction and update amounts\n  async removeItemFromTransaction(itemId: string, transactionId: string, _itemAmount: string): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      console.warn('‚ö†Ô∏è Transaction not found for removal:', transactionId)\n      return\n    }\n\n    const existingData = transactionSnap.data()\n    const existingItemIds = existingData.item_ids || []\n    const updatedItemIds = existingItemIds.filter((id: string) => id !== itemId)\n\n    if (updatedItemIds.length === 0) {\n      // No items left - delete transaction\n      try {\n        await deleteDoc(transactionRef)\n        console.log('üóëÔ∏è Deleted empty transaction:', transactionId)\n\n        // Log transaction deletion (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'deleted', existingData, null)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction deletion:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to delete empty transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue even if deletion fails\n      }\n    } else {\n      // Recalculate amount from remaining items\n      try {\n        const itemsRef = collection(db, 'items')\n        const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n        const itemsSnapshot = await getDocs(itemsQuery)\n\n        const totalAmount = itemsSnapshot.docs\n          .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          last_updated: new Date().toISOString()\n        }\n\n        await updateDoc(transactionRef, updateData)\n        console.log('üîÑ Updated transaction after removal:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'updated', existingData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update transaction after removal:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Helper: Add item to transaction (create if none exists)\n  async addItemToTransaction(\n    itemId: string,\n    transactionId: string,\n    amount: string,\n    transactionType: 'Purchase' | 'Sale' | 'To Inventory',\n    triggerEvent: string,\n    notes?: string\n  ): Promise<void> {\n    const transactionRef = doc(db, 'transactions', transactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - add item and recalculate amount\n      try {\n        const existingData = transactionSnap.data()\n        const existingItemIds = existingData.item_ids || []\n        const updatedItemIds = [...new Set([...existingItemIds, itemId])] // Avoid duplicates\n\n        // Get all items to recalculate amount\n        const itemsRef = collection(db, 'items')\n        const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n        const itemsSnapshot = await getDocs(itemsQuery)\n\n        const totalAmount = itemsSnapshot.docs\n          .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n          .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n          .toFixed(2)\n        // Prevent negative totals\n        const safeAmount = parseFloat(totalAmount) < 0 ? '0.00' : totalAmount\n\n        const updateData = {\n          item_ids: updatedItemIds,\n          amount: safeAmount,\n          last_updated: new Date().toISOString()\n        }\n\n        await updateDoc(transactionRef, updateData)\n        console.log('üîÑ Added item to existing transaction:', transactionId, 'new amount:', safeAmount)\n\n        // Log transaction update (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'updated', existingData, updateData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction update:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to update existing transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    } else {\n      // Create new transaction\n      try {\n        const project = await projectService.getProject(transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', ''))\n        const projectName = project?.name || 'Other'\n\n        const transactionData = {\n          project_id: transactionId.replace(transactionType === 'Purchase' ? 'INV_PURCHASE_' : 'INV_SALE_', ''),\n          project_name: null,\n          transaction_date: toDateOnlyString(new Date()),\n          source: transactionType === 'Purchase' ? 'Inventory' : projectName,\n          transaction_type: transactionType,\n          payment_method: 'Pending',\n          amount: amount,\n          budget_category: 'Furnishings',\n          notes: notes || `Transaction for items ${transactionType === 'Purchase' ? 'purchased from' : 'sold to'} ${transactionType === 'Purchase' ? 'inventory' : 'project'}`,\n          status: 'pending' as const,\n          reimbursement_type: transactionType === 'Purchase' ? 'Client Owes' : 'We Owe',\n          trigger_event: triggerEvent,\n          item_ids: [itemId],\n          created_by: 'system',\n          created_at: new Date().toISOString(),\n          last_updated: new Date().toISOString()\n        }\n\n        await setDoc(transactionRef, transactionData)\n        console.log('üÜï Created new transaction:', transactionId, 'amount:', amount)\n\n        // Log transaction creation (catch errors to prevent cascading failures)\n        try {\n          await auditService.logTransactionStateChange(transactionId, 'created', null, transactionData)\n        } catch (auditError) {\n          console.warn('‚ö†Ô∏è Failed to log transaction creation:', auditError)\n        }\n      } catch (error) {\n        console.error('‚ùå Failed to create new transaction:', transactionId, error)\n        // Don't throw - allow the allocation to continue\n      }\n    }\n  },\n\n  // Batch allocate multiple items to project (updates INV_PURCHASE_<projectId> transaction)\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Fetch the requested items by id (inspect transaction_id per-item to\n    // implement A.1 vs A.2 decisions). Do NOT rely solely on project_id.\n    const itemsRef = collection(db, 'items')\n    const itemsQuery = query(itemsRef, where('__name__', 'in', itemIds))\n    const itemsSnapshot = await getDocs(itemsQuery)\n\n    if (itemsSnapshot.empty) {\n      throw new Error('No items found for allocation')\n    }\n\n    const canonicalTransactionId = `INV_PURCHASE_${projectId}`\n\n    // Process each item individually so we can apply A.1/A.2 rules per item.\n    for (const itemDoc of itemsSnapshot.docs) {\n      const itemId = itemDoc.id\n      const itemData: any = itemDoc.data()\n      const finalAmount = allocationData.amount || itemData.project_price || itemData.market_value || '0.00'\n      const currentTransactionId: string | null = itemData.transaction_id || null\n\n      // Scenario A: Item currently in a Sale (Project X)\n      if (currentTransactionId?.startsWith('INV_SALE_')) {\n        const saleProjectId = currentTransactionId.replace('INV_SALE_', '')\n\n        if (saleProjectId === projectId) {\n          // A.1: Remove item from Sale and DO NOT add to Purchase. Assign back to\n          // the same project (mark allocated) but do not create an INV_PURCHASE.\n          console.log('üìã Batch A.1: Item in sale for target project ‚Äî removing from sale and assigning to project', itemId)\n          await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n          await this.updateItem(itemId, {\n            project_id: projectId,\n            inventory_status: 'allocated',\n            transaction_id: null,\n            disposition: 'keep',\n            notes: allocationData.notes,\n            space: allocationData.space || '',\n            last_updated: new Date().toISOString()\n          })\n          continue\n        } else {\n          // A.2: Remove from Sale then add to Purchase for target project\n          console.log('üìã Batch A.2: Item in sale for different project ‚Äî moving to purchase for target project', itemId)\n          await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n          await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n          await this.updateItem(itemId, {\n            project_id: projectId,\n            inventory_status: 'allocated',\n            transaction_id: canonicalTransactionId,\n            disposition: 'keep',\n            space: allocationData.space || '',\n            last_updated: new Date().toISOString()\n          })\n          continue\n        }\n      }\n\n      // Scenario C: Item in Inventory (no transaction_id) ‚Äî add to Purchase\n      if (!currentTransactionId) {\n        console.log('üìã Batch C: Item in inventory ‚Äî adding to purchase', itemId)\n        await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n        await this.updateItem(itemId, {\n          project_id: projectId,\n          inventory_status: 'allocated',\n          transaction_id: canonicalTransactionId,\n          disposition: 'keep',\n          space: allocationData.space || '',\n          last_updated: new Date().toISOString()\n        })\n        continue\n      }\n\n      // Fallback: other transaction types ‚Äî add to purchase and update item\n      console.log('üìã Batch Fallback: Item in other transaction ‚Äî adding to purchase', itemId, currentTransactionId)\n      await this.addItemToTransaction(itemId, canonicalTransactionId, finalAmount, 'Purchase', 'Inventory allocation', allocationData.notes)\n      await this.updateItem(itemId, {\n        project_id: projectId,\n        inventory_status: 'allocated',\n        transaction_id: canonicalTransactionId,\n        disposition: 'keep',\n        space: allocationData.space || '',\n        last_updated: new Date().toISOString()\n      })\n    }\n\n    return canonicalTransactionId\n  },\n\n  // Return item from project (follows ALLOCATION_TRANSACTION_LOGIC.md deterministic flows)\n  async returnItemFromProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    await ensureAuthenticatedForStorage()\n\n    // Get the item to determine current state\n    const item = await this.getItemById(itemId)\n    if (!item) {\n      throw new Error('Item not found')\n    }\n\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n    const currentTransactionId: string | null = item.transaction_id || null\n\n    console.log('üîÑ Starting return process:', {\n      itemId,\n      projectId,\n      currentTransactionId,\n      itemProjectId: item.project_id,\n      finalAmount\n    })\n\n    // Log return start (catch errors to prevent cascading failures)\n    try {\n      await (auditService.logAllocationEvent as any)('return', itemId, item.project_id, currentTransactionId, {\n        action: 'return_started',\n        target_project_id: projectId,\n        current_transaction_id: currentTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return start:', auditError)\n    }\n\n    // DETERMINISTIC FLOW LOGIC for returns (reverse of allocation)\n\n    // If item is in a Purchase transaction, this is a return (Scenario B reverse)\n    if (currentTransactionId?.startsWith('INV_PURCHASE_')) {\n      const currentProjectId = currentTransactionId.replace('INV_PURCHASE_', '')\n\n      if (currentProjectId === projectId) {\n        // Returning from same project - remove from Purchase, move to inventory\n        console.log('üìã Return Scenario: Item in Purchase, returning from same project')\n        return await this.handleReturnFromPurchase(itemId, currentTransactionId, projectId, finalAmount, notes)\n      }\n    }\n\n    // If item is not in any transaction or is in inventory, this is a new return\n    console.log('üìã Return Scenario: Item not in transaction or new return')\n    return await this.handleNewReturn(itemId, projectId, finalAmount, notes)\n  },\n\n  // Helper: Handle return from Purchase transaction (same project)\n  async handleReturnFromPurchase(\n    itemId: string,\n    currentTransactionId: string,\n    _projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Remove item from existing Purchase transaction and return it to inventory.\n    // Per allocation rules, do NOT create an INV_SALE when the item was part of\n    // an INV_PURCHASE for the same project. Simply remove the item from the\n    // purchase (the helper will delete the purchase if empty), then update the\n    // item to reflect that it's back in business inventory.\n    await this.removeItemFromTransaction(itemId, currentTransactionId, finalAmount)\n\n    // Update item status to inventory and clear transaction linkage for canonical state\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: null,\n      disposition: 'inventory',\n      notes: notes\n    })\n\n    console.log('‚úÖ Return completed: Purchase ‚Üí Inventory (same project)')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('return', itemId, null, currentTransactionId, {\n        action: 'return_completed',\n        scenario: 'return_from_purchase',\n        from_transaction: currentTransactionId,\n        to_status: 'inventory',\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    // Return the original purchase transaction id (may have been deleted)\n    return currentTransactionId\n  },\n\n  // Helper: Handle new return (item was already in inventory or no transaction)\n  async handleNewReturn(\n    itemId: string,\n    projectId: string,\n    finalAmount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Create Sale transaction (project selling TO us)\n    const saleTransactionId = `INV_SALE_${projectId}`\n\n    const transactionData = {\n      project_id: projectId,\n      project_name: null,\n      transaction_date: toDateOnlyString(new Date()),\n      source: projectName,\n      transaction_type: 'To Inventory',  // Project is moving item TO inventory\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Transaction for items purchased from project and moved to business inventory',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,  // We owe the client for this purchase\n      trigger_event: 'Inventory sale' as const,\n      item_ids: [itemId],\n      created_by: 'system',\n      created_at: new Date().toISOString(),\n      last_updated: new Date().toISOString()\n    }\n\n    const transactionRef = doc(db, 'transactions', saleTransactionId)\n    await setDoc(transactionRef, transactionData, { merge: true })\n\n    // Update item status to inventory\n    await this.updateItem(itemId, {\n      project_id: null,\n      inventory_status: 'available',\n      transaction_id: saleTransactionId,\n      disposition: 'inventory'\n    })\n\n    console.log('‚úÖ New return completed: Inventory ‚Üí Sale')\n\n    // Log successful return (catch errors to prevent cascading failures)\n    try {\n      await auditService.logAllocationEvent('return', itemId, null, saleTransactionId, {\n        action: 'return_completed',\n        scenario: 'new_return',\n        from_status: 'inventory',\n        to_transaction: saleTransactionId,\n        amount: finalAmount\n      })\n    } catch (auditError) {\n      console.warn('‚ö†Ô∏è Failed to log return completion:', auditError)\n    }\n\n    return saleTransactionId\n  },\n\n  // Complete pending transaction (marks as completed and clears transaction_id)\n  async completePendingTransaction(\n    transactionType: 'sale' | 'buy',\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    await ensureAuthenticatedForStorage()\n\n    // Determine canonical transaction ID\n    const canonicalTransactionId = transactionType === 'sale'\n      ? `INV_SALE_${projectId}`\n      : `INV_PURCHASE_${projectId}`\n\n    // Get the transaction\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (!transactionSnap.exists()) {\n      throw new Error('Transaction not found')\n    }\n\n    const transactionData = transactionSnap.data()\n    const itemIds = transactionData.item_ids || []\n\n    // Complete the transaction\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      payment_method: paymentMethod,\n      transaction_date: toDateOnlyString(new Date()),\n      last_updated: new Date().toISOString()\n    })\n\n    // Clear transaction_id from all linked items\n    const batch = writeBatch(db)\n    for (const itemId of itemIds) {\n      const itemRef = doc(db, 'items', itemId)\n      if (transactionType === 'sale') {\n        // For sales, keep project_id but clear transaction_id and set status to sold\n        batch.update(itemRef, {\n          transaction_id: null,\n          inventory_status: 'sold',\n          last_updated: new Date().toISOString()\n        })\n      } else {\n        // For buys, clear project_id and transaction_id and set status to available\n        batch.update(itemRef, {\n          project_id: null,\n          transaction_id: null,\n          inventory_status: 'available',\n          last_updated: new Date().toISOString()\n        })\n      }\n    }\n\n    await batch.commit()\n  },\n\n  // Helper function to get item by ID\n  async getItemById(itemId: string): Promise<Item | null> {\n    await ensureAuthenticatedForStorage()\n\n    const itemRef = doc(db, 'items', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate an existing item (unified collection version)\n  async duplicateItem(projectId: string, originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getItemById(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes,\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      transaction_id: originalItem.transaction_id,\n      project_id: projectId,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'items', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create multiple items linked to a transaction (unified collection version)\n  async createTransactionItems(\n    projectId: string,\n    transactionId: string,\n    transaction_date: string,\n    transactionSource: string,\n    items: TransactionItemFormData[]\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const createdItemIds: string[] = []\n    const now = new Date()\n\n    items.forEach((itemData) => {\n      const itemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      createdItemIds.push(itemId)\n\n      const itemRef = doc(db, 'items', itemId)\n      const qrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n      const item = {\n        item_id: itemId,\n        description: itemData.description,\n        source: transactionSource, // Use transaction source for all items\n        sku: itemData.sku || '',\n        purchase_price: itemData.purchase_price,\n        project_price: itemData.project_price,\n        market_value: itemData.market_value || '',\n        payment_method: 'Client Card', // Default payment method\n        disposition: 'keep',\n        notes: itemData.notes,\n        qr_key: qrKey,\n        bookmark: false,\n        transaction_id: transactionId,\n        project_id: projectId,\n        date_created: transaction_date,\n        last_updated: now.toISOString(),\n        images: [] // Start with empty images array, will be populated after upload\n      } as Item\n\n      batch.set(itemRef, item)\n    })\n\n    await batch.commit()\n    return createdItemIds\n  }\n}\n\n// Business Inventory Services (DEPRECATED - use unifiedItemsService instead)\nexport const businessInventoryService = {\n  // Get all business inventory items\n  async getBusinessInventoryItems(\n    filters?: { status?: string; searchQuery?: string },\n    pagination?: PaginationOptions\n  ): Promise<Item[]> {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef)\n\n    // Apply filters\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    // Apply sorting and pagination\n    q = query(q, orderBy('last_updated', 'desc'))\n\n    if (pagination) {\n      q = query(q, limit(pagination.limit))\n      if (pagination.page > 0) {\n        q = query(q, limit(pagination.page * pagination.limit))\n      }\n    }\n\n    const querySnapshot = await getDocs(q)\n\n    let items = querySnapshot.docs.map(doc => ({\n      item_id: doc.id,\n      ...doc.data()\n    } as Item))\n\n    // Apply client-side search if needed\n    if (filters?.searchQuery) {\n      const searchTerm = filters.searchQuery.toLowerCase()\n      items = items.filter(item =>\n        item.description.toLowerCase().includes(searchTerm) ||\n        item.source.toLowerCase().includes(searchTerm) ||\n        item.sku.toLowerCase().includes(searchTerm) ||\n        item.business_inventory_location?.toLowerCase().includes(searchTerm)\n      )\n    }\n\n    return items\n  },\n\n  // Get single business inventory item\n  async getBusinessInventoryItem(itemId: string): Promise<Item | null> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    const itemSnap = await getDoc(itemRef)\n\n    if (itemSnap.exists()) {\n      return {\n        item_id: itemSnap.id,\n        ...itemSnap.data()\n      } as Item\n    }\n    return null\n  },\n\n  // Duplicate a business inventory item\n  async duplicateBusinessInventoryItem(originalItemId: string): Promise<string> {\n    // Get the original item first\n    const originalItem = await this.getBusinessInventoryItem(originalItemId)\n    if (!originalItem) {\n      throw new Error('Original business inventory item not found')\n    }\n\n    const now = new Date()\n    const newItemId = `BI-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n    const newQrKey = `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n\n    // Create duplicate item with new IDs and timestamps\n    // Filter out undefined values to avoid Firebase errors\n    const duplicatedItem: any = {\n      item_id: newItemId,\n      description: originalItem.description,\n      source: originalItem.source,\n      sku: originalItem.sku || '',\n      purchase_price: originalItem.purchase_price || '',\n      project_price: originalItem.project_price || '',\n      market_value: originalItem.market_value || '',\n      payment_method: originalItem.payment_method,\n      disposition: 'keep', // Default disposition for duplicates\n      notes: originalItem.notes,\n      space: originalItem.space || '',\n      qr_key: newQrKey,\n      bookmark: false, // Default bookmark to false for duplicates\n      inventory_status: 'available', // Default status for duplicates\n      business_inventory_location: originalItem.business_inventory_location || '',\n      transaction_id: originalItem.transaction_id,\n      date_created: now.toISOString(),\n      last_updated: now.toISOString(),\n      images: originalItem.images || [] // Copy images from original item\n    }\n\n    // Remove any undefined values that might still exist\n    Object.keys(duplicatedItem).forEach(key => {\n      if (duplicatedItem[key] === undefined) {\n        delete duplicatedItem[key]\n      }\n    })\n\n    // Create the duplicated item\n    const itemRef = doc(db, 'business_inventory', newItemId)\n    await setDoc(itemRef, duplicatedItem)\n\n    return newItemId\n  },\n\n  // Create new business inventory item\n  async createBusinessInventoryItem(itemData: Omit<Item, 'item_id' | 'date_created' | 'last_updated'>): Promise<string> {\n    const itemsRef = collection(db, 'business_inventory')\n    const now = new Date()\n\n    const newItem = {\n      ...itemData,\n      inventory_status: itemData.inventory_status || 'available',\n      date_created: now.toISOString(),\n      last_updated: now.toISOString()\n    }\n\n    const docRef = await addDoc(itemsRef, newItem)\n    return docRef.id\n  },\n\n  // Update business inventory item\n  async updateBusinessInventoryItem(itemId: string, updates: Partial<Item>): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n\n    const firebaseUpdates: any = {\n      last_updated: new Date().toISOString()\n    }\n\n    if (updates.inventory_status !== undefined) firebaseUpdates.inventory_status = updates.inventory_status\n    if (updates.business_inventory_location !== undefined) firebaseUpdates.business_inventory_location = updates.business_inventory_location\n    if (updates.purchase_price !== undefined) firebaseUpdates.purchase_price = updates.purchase_price\n    if (updates.project_price !== undefined) firebaseUpdates.project_price = updates.project_price\n    if (updates.description !== undefined) firebaseUpdates.description = updates.description\n    if (updates.source !== undefined) firebaseUpdates.source = updates.source\n    if (updates.sku !== undefined) firebaseUpdates.sku = updates.sku\n    if (updates.market_value !== undefined) firebaseUpdates.market_value = updates.market_value\n    if (updates.payment_method !== undefined) firebaseUpdates.payment_method = updates.payment_method\n    if (updates.disposition !== undefined) firebaseUpdates.disposition = updates.disposition\n    if (updates.notes !== undefined) firebaseUpdates.notes = updates.notes\n    if (updates.space !== undefined) firebaseUpdates.space = updates.space\n    if (updates.bookmark !== undefined) firebaseUpdates.bookmark = updates.bookmark\n    if (updates.images !== undefined) firebaseUpdates.images = updates.images\n\n    await updateDoc(itemRef, firebaseUpdates)\n  },\n\n  // Delete business inventory item\n  async deleteBusinessInventoryItem(itemId: string): Promise<void> {\n    const itemRef = doc(db, 'business_inventory', itemId)\n    await deleteDoc(itemRef)\n  },\n\n  // Get business inventory statistics\n  async getBusinessInventoryStats(): Promise<BusinessInventoryStats> {\n    const itemsRef = collection(db, 'business_inventory')\n    const snapshot = await getCountFromServer(itemsRef)\n\n    const allItemsQuery = query(itemsRef)\n    const allItemsSnap = await getDocs(allItemsQuery)\n\n    let availableItems = 0\n    let allocatedItems = 0\n    let soldItems = 0\n\n    allItemsSnap.docs.forEach(doc => {\n      const data = doc.data()\n      switch (data.inventory_status) {\n        case 'available':\n          availableItems++\n          break\n        case 'allocated':\n          allocatedItems++\n          break\n        case 'sold':\n          soldItems++\n          break\n      }\n    })\n\n    return {\n      totalItems: snapshot.data().count,\n      availableItems,\n      allocatedItems,\n      soldItems\n    }\n  },\n\n  // Subscribe to business inventory items\n  subscribeToBusinessInventory(\n    callback: (items: Item[]) => void,\n    filters?: { status?: string; searchQuery?: string }\n  ) {\n    const itemsRef = collection(db, 'business_inventory')\n    let q = query(itemsRef, orderBy('last_updated', 'desc'))\n\n    if (filters?.status) {\n      q = query(q, where('inventory_status', '==', filters.status))\n    }\n\n    return onSnapshot(q, (snapshot) => {\n      let items = snapshot.docs.map(doc => ({\n        item_id: doc.id,\n        ...doc.data()\n      } as Item))\n\n      // Apply client-side search if needed\n      if (filters?.searchQuery) {\n        const searchTerm = filters.searchQuery.toLowerCase()\n        items = items.filter(item =>\n          item.description.toLowerCase().includes(searchTerm) ||\n          item.source.toLowerCase().includes(searchTerm) ||\n          item.sku.toLowerCase().includes(searchTerm) ||\n          item.business_inventory_location?.toLowerCase().includes(searchTerm)\n        )\n      }\n\n      callback(items)\n    })\n  },\n\n  // Allocate item to project (creates pending transaction)\n  async allocateItemToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item to determine the amount if not provided\n    const item = await this.getBusinessInventoryItem(itemId)\n    if (!item) {\n      throw new Error('Business inventory item not found')\n    }\n    const finalAmount = amount || item.project_price || item.market_value || '0.00'\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create pending transaction first\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(new Date()),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: finalAmount,\n      budget_category: 'Furnishings',\n      notes: notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Update item status to allocated and link to transaction\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'allocated',\n      transaction_id: transactionRef.id\n    })\n\n    return transactionRef.id\n  },\n\n  // Batch allocate multiple items to a project\n  async batchAllocateItemsToProject(\n    itemIds: string[],\n    projectId: string,\n    allocationData: {\n      amount?: string;\n      notes?: string;\n      space?: string;\n    } = {}\n  ): Promise<string[]> {\n    const batch = writeBatch(db)\n    const transactionIds: string[] = []\n    const now = new Date()\n\n    // Get the business inventory items first\n    const businessItemsRef = collection(db, 'business_inventory')\n    const businessItemsQuery = query(businessItemsRef, where('__name__', 'in', itemIds))\n    const businessItemsSnapshot = await getDocs(businessItemsQuery)\n\n    if (businessItemsSnapshot.empty) {\n      throw new Error('No business inventory items found')\n    }\n\n    // Get project name for the notes\n    let projectName = 'Project'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Project'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction notes:', error)\n    }\n\n    // Create a single transaction for the batch allocation\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(now),\n      source: 'Inventory',  // Project purchasing inventory from 1584\n      transaction_type: 'Purchase',  // Project purchasing inventory from 1584\n      payment_method: 'Pending',\n      amount: allocationData.amount || '0.00',\n      budget_category: 'Furnishings',\n      notes: allocationData.notes || `${projectName} inventory purchase`,  // Include project name in notes\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'Client Owes' as const,\n      trigger_event: 'Inventory allocation' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = doc(transactionsRef)\n    batch.set(transactionRef, transactionData)\n    transactionIds.push(transactionRef.id)\n\n    // Create project items from business inventory items\n    businessItemsSnapshot.docs.forEach((businessItemDoc) => {\n      const businessItemData = businessItemDoc.data()\n\n      // Create the item in project collection with specified defaults\n      const projectItemId = `I-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`\n      const projectItemRef = doc(db, 'projects', projectId, 'items', projectItemId)\n\n      const projectItemData = {\n        item_id: projectItemId,\n        description: businessItemData.description,\n        source: businessItemData.source,\n        sku: businessItemData.sku,\n        project_price: businessItemData.project_price, // 1584 design project price from business inventory\n        market_value: businessItemData.market_value || '',\n        payment_method: '1584', // Default payment method for allocated items\n        disposition: 'keep', // Default disposition for allocated items\n        notes: businessItemData.notes,\n        space: allocationData.space || '', // Optional space field\n        qr_key: `QR-${Date.now()}-${Math.random().toString(36).substr(2, 4)}`, // Generate new QR key\n        bookmark: false, // Default bookmark to false\n        transaction_id: transactionRef.id, // Link to allocation transaction\n        project_id: projectId,\n        date_created: businessItemData.date_created, // Preserve original date\n        last_updated: now.toISOString(),\n        images: businessItemData.images || [] // Preserve images\n      }\n\n      batch.set(projectItemRef, projectItemData)\n    })\n\n    // Mark business inventory items as sold (since they've been moved to project)\n    itemIds.forEach(itemId => {\n      const itemRef = doc(db, 'business_inventory', itemId)\n      batch.update(itemRef, {\n        inventory_status: 'sold',\n        transaction_id: transactionRef.id,\n        last_updated: now.toISOString()\n      })\n    })\n\n    await batch.commit()\n\n    // Update project metadata\n    const currentItems = await unifiedItemsService.getItemsByProject(projectId)\n    const currentItemCount = currentItems.length\n    await projectService.updateProject(projectId, {\n      metadata: {\n        totalItems: currentItemCount,\n        lastActivity: now\n      }\n    } as Partial<Project>)\n\n    return transactionIds\n  },\n\n  // Return item from project (cancels pending transaction)\n    async returnItemFromProject(itemId: string, transactionId: string, projectId: string): Promise<void> {\n    // Cancel the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'canceled',\n      last_updated: new Date().toISOString()\n    })\n\n    // Update item status back to available and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'available',\n      transaction_id: undefined\n    })\n  },\n\n  // Mark item as sold (completes pending transaction)\n  async markItemAsSold(\n    itemId: string,\n    transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // Complete the pending transaction\n    const transactionRef = doc(db, 'projects', projectId, 'transactions', transactionId)\n    await updateDoc(transactionRef, {\n      status: 'completed',\n      transaction_date: toDateOnlyString(new Date()),\n      payment_method: paymentMethod,\n      last_updated: new Date().toISOString()\n    })\n\n    // Update item status to sold and clear project links\n    await this.updateBusinessInventoryItem(itemId, {\n      inventory_status: 'sold',\n      transaction_id: undefined\n    })\n  },\n\n  // Move item from project back to business inventory (creates \"We owe client\" transaction)\n  async moveItemToBusinessInventory(\n    itemId: string,\n    projectId: string,\n    amount: string,\n    notes?: string\n  ): Promise<string> {\n    // Get the item from project first\n    const projectItemsRef = collection(db, 'projects', projectId, 'items')\n    const itemQuery = query(projectItemsRef, where('item_id', '==', itemId))\n    const itemSnap = await getDocs(itemQuery)\n\n    if (itemSnap.empty) {\n      throw new Error('Item not found in project')\n    }\n\n    const itemData = itemSnap.docs[0].data()\n\n    // Create \"We owe client\" transaction\n    const transactionData = {\n      project_id: projectId,\n      transaction_date: toDateOnlyString(new Date()),\n      source: 'Client Purchase',\n      transaction_type: 'Purchase',\n      payment_method: 'Pending',\n      amount: amount,\n      budget_category: 'Furnishings',\n      notes: notes || 'Client-purchased item moved to business inventory',\n      created_by: 'system',\n      status: 'pending' as const,\n      reimbursement_type: 'We Owe' as const,\n      trigger_event: 'Purchase from client' as const\n    }\n\n    const transactionsRef = collection(db, 'projects', projectId, 'transactions')\n    const transactionRef = await addDoc(transactionsRef, transactionData)\n\n    // Create item in business inventory\n    const newBusinessItem = {\n      description: itemData.description,\n      source: itemData.source,\n      sku: itemData.sku,\n      price: itemData.price,\n      market_value: itemData.market_value,\n      payment_method: itemData.payment_method,\n      disposition: itemData.disposition || 'keep',\n      notes: itemData.notes,\n      space: itemData.space,\n      qr_key: itemData.qr_key,\n      bookmark: itemData.bookmark || false,\n      inventory_status: 'available' as const,\n      business_inventory_location: 'Warehouse - Client Purchase',\n      transaction_id: transactionRef.id,\n      images: itemData.images || []\n    }\n\n    await this.createBusinessInventoryItem(newBusinessItem)\n\n    // Remove item from project\n    await deleteDoc(itemSnap.docs[0].ref)\n\n    return transactionRef.id\n  }\n}\n\n// Deallocation Service - Handles inventory designation automation\nexport const deallocationService = {\n  // Main entry point for handling inventory designation - simplified unified approach\n  async handleInventoryDesignation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    console.log('üîÑ handleInventoryDesignation called:', { itemId, projectId, disposition })\n\n    if (disposition !== 'inventory') {\n      console.log('‚è≠Ô∏è Skipping - disposition is not inventory:', disposition)\n      return // Only handle 'inventory' disposition\n    }\n\n    try {\n      console.log('üîç Getting item details for:', itemId)\n      // Get the item details\n      const item = await unifiedItemsService.getItemById(itemId)\n      if (!item) {\n        throw new Error('Item not found')\n      }\n      console.log('‚úÖ Item found:', item.item_id, 'disposition:', item.disposition, 'project_id:', item.project_id)\n\n      // If the item is currently linked to an INV_PURCHASE for the same project,\n      // this is a purchase-reversion: remove it from the purchase and return it\n      // to inventory instead of creating an INV_SALE. This prevents creating\n      // both INV_PURCHASE and INV_SALE canonical transactions for the same\n      // item/project.\n      if (item.transaction_id && item.transaction_id.startsWith('INV_PURCHASE_')) {\n        const purchaseProjectId = item.transaction_id.replace('INV_PURCHASE_', '')\n        if (purchaseProjectId === projectId) {\n          console.log('üîÅ Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory')\n\n          // Remove item from the existing purchase (will delete if empty)\n          await unifiedItemsService.removeItemFromTransaction(item.item_id, item.transaction_id, item.project_price || item.market_value || '0.00')\n\n          // Update the item to reflect it's back in business inventory\n          await unifiedItemsService.updateItem(item.item_id, {\n            project_id: null,\n            inventory_status: 'available',\n            transaction_id: null,\n            last_updated: new Date().toISOString()\n          })\n\n          try {\n            await auditService.logAllocationEvent('deallocation', itemId, null, item.transaction_id, {\n              action: 'deallocation_completed',\n              scenario: 'purchase_reversion',\n              from_transaction: item.transaction_id,\n              to_status: 'inventory',\n              amount: item.project_price || item.market_value || '0.00'\n            })\n          } catch (auditError) {\n            console.warn('‚ö†Ô∏è Failed to log deallocation completion for purchase-reversion:', auditError)\n          }\n\n          console.log('‚úÖ Purchase-reversion handled: item returned to inventory without creating INV_SALE')\n          return\n        }\n      }\n\n      // Unified approach: Always create/update a \"Sale\" transaction for inventory designation (project selling TO us)\n      console.log('üè¶ Creating/updating Sale transaction for inventory designation')\n\n      // Log deallocation start (catch errors to prevent cascading failures)\n      try {\n        await (auditService.logAllocationEvent as any)('deallocation', itemId, item.project_id, item.transaction_id, {\n          action: 'deallocation_started',\n          target_status: 'inventory',\n          current_transaction_id: item.transaction_id\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation start:', auditError)\n      }\n\n      const transactionId = await this.ensureSaleTransaction(\n        item,\n        projectId,\n        'Transaction for items purchased from project and moved to business inventory'\n      )\n\n      console.log('üì¶ Moving item to business inventory...')\n      // Update item to move to business inventory and link to transaction\n      await unifiedItemsService.updateItem(item.item_id, {\n        project_id: null,\n        inventory_status: 'available',\n        transaction_id: transactionId,\n        space: '', // Clear space field when moving to business inventory\n        last_updated: new Date().toISOString()\n      })\n\n      // Log successful deallocation (catch errors to prevent cascading failures)\n      try {\n        await auditService.logAllocationEvent('deallocation', itemId, null, transactionId, {\n          action: 'deallocation_completed',\n          from_project_id: item.project_id,\n          to_transaction: transactionId,\n          amount: item.project_price || item.market_value || '0.00'\n        })\n      } catch (auditError) {\n        console.warn('‚ö†Ô∏è Failed to log deallocation completion:', auditError)\n      }\n\n      console.log('‚úÖ Item moved to business inventory successfully')\n\n      console.log('‚úÖ Deallocation completed successfully')\n    } catch (error) {\n      console.error('‚ùå Error handling inventory designation:', error)\n      throw error\n    }\n  },\n\n  // Unified function to ensure a sale transaction exists for inventory designation (follows ALLOCATION_TRANSACTION_LOGIC.md)\n  async ensureSaleTransaction(\n    item: Item,\n    projectId: string,\n    additionalNotes?: string\n  ): Promise<string | null> {\n    console.log('üè¶ Creating/updating sale transaction for item:', item.item_id)\n\n    // Get project name for source field\n    let projectName = 'Other'\n    try {\n      const project = await projectService.getProject(projectId)\n      projectName = project?.name || 'Other'\n    } catch (error) {\n      console.warn('Could not fetch project name for transaction source:', error)\n    }\n\n    // Defensive check: if the item is still linked to a purchase for this\n    // project, treat as purchase-reversion and do not create an INV_SALE.\n    if (item.transaction_id && item.transaction_id.startsWith('INV_PURCHASE_')) {\n      const purchaseProjectId = item.transaction_id.replace('INV_PURCHASE_', '')\n      if (purchaseProjectId === projectId) {\n        console.log('‚ÑπÔ∏è ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE')\n\n        // Remove the item from the purchase and return to inventory\n        await unifiedItemsService.removeItemFromTransaction(item.item_id, item.transaction_id, item.project_price || item.market_value || '0.00')\n        await unifiedItemsService.updateItem(item.item_id, {\n          project_id: null,\n          inventory_status: 'available',\n          transaction_id: null,\n          last_updated: new Date().toISOString()\n        })\n\n        // Return null to indicate no INV_SALE was created\n        return null\n      }\n    }\n\n    const canonicalTransactionId = `INV_SALE_${projectId}`\n    console.log('üîë Canonical transaction ID:', canonicalTransactionId)\n\n    // Check if the canonical transaction already exists (top-level collection)\n    const transactionRef = doc(db, 'transactions', canonicalTransactionId)\n    const transactionSnap = await getDoc(transactionRef)\n\n    if (transactionSnap.exists()) {\n      // Transaction exists - merge the new item and recalculate amount\n      console.log('üìã Existing INV_SALE transaction found, updating with new item')\n      const existingData = transactionSnap.data()\n      const existingItemIds = existingData.item_ids || []\n      const updatedItemIds = [...new Set([...existingItemIds, item.item_id])] // Avoid duplicates\n\n      // Get all items to recalculate amount\n      const itemsRef = collection(db, 'items')\n      const itemsQuery = query(itemsRef, where('__name__', 'in', updatedItemIds))\n      const itemsSnapshot = await getDocs(itemsQuery)\n\n      const totalAmount = itemsSnapshot.docs\n        .map(doc => doc.data().project_price || doc.data().market_value || '0.00')\n        .reduce((sum: number, price: string) => sum + parseFloat(price || '0'), 0)\n        .toFixed(2)\n\n      const updatedTransactionData = {\n        ...existingData,\n        item_ids: updatedItemIds,\n        amount: totalAmount,\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        last_updated: new Date().toISOString()\n      }\n\n      await setDoc(transactionRef, updatedTransactionData, { merge: true })\n\n      console.log('üîÑ Updated INV_SALE transaction with', updatedItemIds.length, 'items, amount:', totalAmount)\n    } else {\n        // Calculate amount from item for new transaction\n      const calculatedAmount = item.project_price || item.market_value || '0.00'\n\n      // New transaction - create Sale transaction (project moving item TO inventory)\n      const transactionData = {\n        project_id: projectId,\n        project_name: null,\n        transaction_date: toDateOnlyString(new Date()),\n        source: projectName,  // Project name as source (project moving to inventory)\n        transaction_type: 'To Inventory',  // Project is moving item TO inventory\n        payment_method: 'Pending',\n        amount: parseFloat(calculatedAmount || '0').toFixed(2),\n        budget_category: 'Furnishings',\n        notes: additionalNotes || 'Transaction for items purchased from project and moved to business inventory',\n        status: 'pending' as const,\n        reimbursement_type: 'We Owe' as const,  // We owe the client for this purchase\n        trigger_event: 'Inventory sale' as const,\n        item_ids: [item.item_id],\n        created_by: 'system',\n        created_at: new Date().toISOString(),\n        last_updated: new Date().toISOString()\n      }\n\n      console.log('üÜï Creating new INV_SALE transaction with amount:', transactionData.amount)\n\n      await setDoc(transactionRef, transactionData, { merge: true })\n    }\n\n    console.log('‚úÖ Sale transaction created/updated successfully')\n    return canonicalTransactionId\n  }\n}\n\n// Integration Service for Business Inventory and Transactions\nexport const integrationService = {\n  // Allocate business inventory item to project (unified collection)\n  async allocateBusinessInventoryToProject(\n    itemId: string,\n    projectId: string,\n    amount?: string,\n    notes?: string\n  ): Promise<string> {\n    return await unifiedItemsService.allocateItemToProject(itemId, projectId, amount, notes)\n  },\n\n  // Return item from project to business inventory (unified collection)\n  async returnItemToBusinessInventory(\n    itemId: string,\n    _transactionId: string,\n    projectId: string\n  ): Promise<void> {\n    // Use the canonical return method which creates/updates INV_BUY_<projectId> transaction\n    await unifiedItemsService.returnItemFromProject(itemId, projectId)\n  },\n\n  // Complete pending transaction and mark item as sold (unified collection)\n  async completePendingTransaction(\n    _itemId: string,\n    _transactionId: string,\n    projectId: string,\n    paymentMethod: string\n  ): Promise<void> {\n    // For sales, we need to complete the INV_SALE transaction\n    return await unifiedItemsService.completePendingTransaction('sale', projectId, paymentMethod)\n  },\n\n  // Handle item deallocation (new method)\n  async handleItemDeallocation(\n    itemId: string,\n    projectId: string,\n    disposition: string\n  ): Promise<void> {\n    return await deallocationService.handleInventoryDesignation(itemId, projectId, disposition)\n  }\n}\n"],"names":["toDate","value","error","year","month","day","date","formatDate","fallback","formatCurrency","amount","num","toDateOnlyString","d","yyyy","mm","dd","auditService","eventType","itemId","projectId","transactionIdOrDetails","detailsOrUndefined","transactionId","details","auditRef","collection","db","addDoc","serverTimestamp","changeType","oldState","newState","projectService","ensureAuthenticatedForStorage","projectsRef","q","query","orderBy","getDocs","doc","data","convertTimestamps","projectRef","projectSnap","getDoc","projectData","now","newProject","updates","updateDoc","deleteDoc","callback","onSnapshot","snapshot","projects","transactionService","transactionsRef","where","transactionData","_projectId","transactionRef","transactionSnap","items","newTransaction","createdItemIds","unifiedItemsService","finalUpdates","deleteField","cleanUpdates","key","transactions","transaction","status","updateData","filters","pagination","itemsRef","searchTerm","limit","item","_a","itemData","newItem","itemRef","firebaseUpdates","notes","space","finalAmount","currentTransactionId","auditError","purchaseTransactionId","_notes","newProjectId","saleTransactionId","_itemAmount","existingData","updatedItemIds","id","itemsQuery","totalAmount","sum","price","safeAmount","transactionType","triggerEvent","existingItemIds","project","projectName","setDoc","itemIds","allocationData","itemsSnapshot","canonicalTransactionId","itemDoc","paymentMethod","batch","writeBatch","itemSnap","originalItemId","originalItem","newItemId","newQrKey","duplicatedItem","transaction_date","transactionSource","qrKey","businessInventoryService","getCountFromServer","allItemsQuery","allItemsSnap","availableItems","allocatedItems","soldItems","transactionIds","businessItemsRef","businessItemsQuery","businessItemsSnapshot","businessItemDoc","businessItemData","projectItemId","projectItemRef","projectItemData","currentItemCount","projectItemsRef","itemQuery","newBusinessItem","deallocationService","disposition","additionalNotes","updatedTransactionData","calculatedAmount","integrationService","_transactionId","_itemId"],"mappings":"0LAKO,MAAMA,EAAUC,GAAkC,CACvD,GAAI,CAACA,EAAO,OAAO,KAEnB,GAAIA,aAAiB,KACnB,OAAOA,EAIT,GAAI,OAAOA,GAAU,UAAYA,EAAO,CAEtC,GAAI,WAAYA,GAAS,OAAQA,EAAc,QAAW,WACxD,GAAI,CACF,OAAQA,EAAc,OAAA,CACxB,OAASC,EAAO,CACd,eAAQ,KAAK,iDAAkDA,CAAK,EAC7D,IACT,CAIF,GAAI,YAAaD,GAAS,gBAAiBA,EACzC,GAAI,CACF,OAAO,IAAI,KAAMA,EAAc,QAAU,IAAQA,EAAc,YAAc,GAAO,CACtF,OAASC,EAAO,CACd,eAAQ,KAAK,iDAAkDA,CAAK,EAC7D,IACT,CAEJ,CAGA,GAAI,OAAOD,GAAU,SACnB,GAAI,CAGF,GAAI,sBAAsB,KAAKA,CAAK,EAAG,CAErC,KAAM,CAACE,EAAMC,EAAOC,CAAG,EAAIJ,EAAM,MAAM,GAAG,EAAE,IAAI,MAAM,EAChDK,EAAO,IAAI,KAAKH,EAAMC,EAAQ,EAAGC,CAAG,EAC1C,OAAO,MAAMC,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,CAGA,MAAMA,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,+BAAgCD,EAAOC,CAAK,EAClD,IACT,CAIF,GAAI,OAAOD,GAAU,SACnB,GAAI,CACF,MAAMK,EAAO,IAAI,KAAKL,CAAK,EAC3B,OAAO,MAAMK,EAAK,QAAA,CAAS,EAAI,KAAOA,CACxC,OAASJ,EAAO,CACd,eAAQ,KAAK,oCAAqCD,EAAOC,CAAK,EACvD,IACT,CAGF,OAAO,IACT,EAKaK,EAAa,CAACN,EAAkBO,EAAmB,YAAsB,CACpF,MAAMF,EAAON,EAAOC,CAAK,EACzB,GAAI,CAACK,EAAM,OAAOE,EAElB,GAAI,CACF,OAAOF,EAAK,mBAAmB,QAAS,CACtC,KAAM,UACN,MAAO,QACP,IAAK,SAAA,CACN,CACH,OAASJ,EAAO,CACd,eAAQ,KAAK,yBAA0BD,EAAOC,CAAK,EAC5CM,CACT,CACF,EAsDaC,EAAiB,CAACC,EAAyBF,EAAmB,UAAoB,CAC7F,MAAMG,EAAM,OAAOD,GAAW,SAAW,WAAWA,CAAM,EAAIA,EAE9D,OAAI,MAAMC,CAAG,EAAUH,EAEhBG,EAAI,eAAe,QAAS,CACjC,MAAO,WACP,SAAU,MACV,sBAAuB,EACvB,sBAAuB,CAAA,CACxB,CACH,EA+BaC,EAAoBX,GAA6B,CAC5D,GAAI,CAACA,EAAO,MAAO,GAEnB,GAAI,OAAOA,GAAU,UAAY,sBAAsB,KAAKA,CAAK,EAC/D,OAAOA,EAET,MAAMY,EAAIb,EAAOC,CAAK,EACtB,GAAI,CAACY,EAAG,MAAO,GACf,MAAMC,EAAOD,EAAE,YAAA,EACTE,EAAK,OAAOF,EAAE,SAAA,EAAa,CAAC,EAAE,SAAS,EAAG,GAAG,EAC7CG,EAAK,OAAOH,EAAE,QAAA,CAAS,EAAE,SAAS,EAAG,GAAG,EAC9C,MAAO,GAAGC,CAAI,IAAIC,CAAE,IAAIC,CAAE,EAC5B,EC3KaC,EAAe,CAE1B,MAAM,mBACJC,EACAC,EACAC,EACAC,EACAC,EACe,CACf,GAAI,CAEF,IAAIC,EAA2C,KAC3CC,EAA+B,CAAA,EAE/B,OAAOH,GAA2B,UACpCE,EAAgBF,EAChBG,EAAUF,GAAsB,CAAA,IAEhCC,EAAgB,KAChBC,EAAUH,GAA0B,CAAA,GAGtC,MAAMI,EAAWC,EAAWC,EAAI,YAAY,EAC5C,MAAMC,EAAOH,EAAU,CACrB,WAAYP,EACZ,QAASC,EACT,WAAYC,EACZ,eAAgBG,EAChB,QAAAC,EACA,UAAWK,EAAA,EACX,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACD,QAAQ,IAAI,oBAAoBX,CAAS,aAAaC,CAAM,EAAE,CAChE,OAASjB,EAAO,CACd,QAAQ,KAAK,+CAAgDA,CAAK,CAEpE,CACF,EAGA,MAAM,0BACJqB,EACAO,EACAC,EACAC,EACe,CACf,GAAI,CACF,MAAMP,EAAWC,EAAWC,EAAI,wBAAwB,EACxD,MAAMC,EAAOH,EAAU,CACrB,eAAgBF,EAChB,YAAaO,EACb,UAAWC,EACX,UAAWC,EACX,UAAWH,EAAA,EACX,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACD,QAAQ,IAAI,gCAAgCC,CAAU,QAAQP,CAAa,EAAE,CAC/E,OAASrB,EAAO,CACd,QAAQ,KAAK,qDAAsDA,CAAK,CAE1E,CACF,CACF,EAGa+B,EAAiB,CAE5B,MAAM,aAAkC,CAEtC,MAAMC,EAAA,EAEN,MAAMC,EAAcT,EAAWC,EAAI,UAAU,EACvCS,EAAIC,EAAMF,EAAaG,EAAQ,YAAa,MAAM,CAAC,EAGzD,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,WAAWrB,EAA4C,CAE3D,MAAMc,EAAA,EAEN,MAAMS,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAC1CwB,EAAc,MAAMC,EAAOF,CAAU,EAE3C,GAAIC,EAAY,SAAU,CACxB,MAAMH,EAAOC,EAAkBE,EAAY,KAAA,CAAM,EACjD,MAAO,CACL,GAAIA,EAAY,GAChB,GAAGH,CAAA,CAEP,CACA,OAAO,IACT,EAGA,MAAM,cAAcK,EAA+E,CACjG,MAAMX,EAAcT,EAAWC,EAAI,UAAU,EACvCoB,MAAU,KAEVC,EAAa,CACjB,GAAGF,EACH,UAAWC,EACX,UAAWA,CAAA,EAIb,OADe,MAAMnB,EAAOO,EAAaa,CAAU,GACrC,EAChB,EAGA,MAAM,cAAc5B,EAAmB6B,EAA0C,CAC/E,MAAMN,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAChD,MAAM8B,EAAUP,EAAY,CAC1B,GAAGM,EACH,cAAe,IAAK,CACrB,CACH,EAGA,MAAM,cAAc7B,EAAkC,CACpD,MAAMuB,EAAaH,EAAIb,EAAI,WAAYP,CAAS,EAChD,MAAM+B,EAAUR,CAAU,CAC5B,EAGA,oBAAoBS,EAAyC,CAC3D,MAAMjB,EAAcT,EAAWC,EAAI,UAAU,EACvCS,EAAIC,EAAMF,EAAaG,EAAQ,YAAa,MAAM,CAAC,EAEzD,OAAOe,EAAWjB,EAAIkB,GAAa,CACjC,MAAMC,EAAWD,EAAS,KAAK,IAAId,GAAO,CACxC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EACzC,MAAO,CACL,GAAIA,EAAI,GACR,GAAGC,CAAA,CAEP,CAAC,EACDW,EAASG,CAAQ,CACnB,CAAC,CACH,CACF,EAMaC,EAAqB,CAEhC,MAAM,gBAAgBpC,EAA2C,CAC/D,MAAMqC,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAMtC,CAAS,EACnCkB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,eAAeC,EAAoBrC,EAAoD,CAC3F,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAC5B,MAAMrB,EAAOC,EAAkBoB,EAAgB,KAAA,CAAM,EAErD,QAAQ,IAAI,+BAAgCrB,CAAI,EAChD,QAAQ,IAAI,yCAA0CA,EAAK,kBAAkB,EAC7E,QAAQ,IAAI,8CAA+C,OAAOA,EAAK,kBAAkB,EAEzF,MAAMkB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,eAAQ,IAAI,gDAAiDkB,CAAe,EAErE,CACL,eAAgBG,EAAgB,GAChC,GAAGH,CAAA,CAEP,CAEA,OAAO,IACT,EAGA,MAAM,mBAAmBpC,EAA+F,CACtH,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAC5B,MAAMrB,EAAOC,EAAkBoB,EAAgB,KAAA,CAAM,EAC/CH,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,YAAa,CACX,eAAgBqB,EAAgB,GAChC,GAAGH,CAAA,EAEL,UAAWlB,EAAK,YAAc,IAAA,CAElC,CAEA,MAAO,CAAE,YAAa,KAAM,UAAW,IAAA,CACzC,EAGA,MAAM,kBACJrB,EACAuC,EACAI,EACiB,CACjB,GAAI,CACF,MAAMN,EAAkB/B,EAAWC,EAAI,cAAc,EAG/CqC,EAAiB,CACrB,GAAGL,EACH,WAAYvC,EACZ,eALc,KAAA,EAKE,YAAA,EAEhB,OAAQuC,EAAgB,QAAU,YAClC,mBAAoBA,EAAgB,oBAAsB,KAC1D,cAAeA,EAAgB,eAAiB,IAAA,EAGlD,QAAQ,IAAI,wBAAyBK,CAAc,EACnD,QAAQ,IAAI,qBAAsBD,CAAK,EAGvC,MAAMxC,GADS,MAAMK,EAAO6B,EAAiBO,CAAc,GAC9B,GAI7B,GAHA,QAAQ,IAAI,oCAAqCzC,CAAa,EAG1DwC,GAASA,EAAM,OAAS,EAAG,CAC7B,QAAQ,IAAI,kCAAmCxC,CAAa,EAC5D,MAAM0C,EAAiB,MAAMC,EAAoB,uBAC/C9C,GAAa,GACbG,EACAoC,EAAgB,iBAChBA,EAAgB,OAChBI,CAAA,EAEF,QAAQ,IAAI,iBAAkBE,CAAc,CAC9C,CAEA,OAAO1C,CACT,OAASrB,EAAO,CACd,cAAQ,MAAM,8BAA+BA,CAAK,EAC5CA,CACR,CACF,EAGA,MAAM,kBAAkB0D,EAAoBrC,EAAuB0B,EAA8C,CAC/G,MAAMY,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAGtD4C,EAAoB,CAAE,GAAGlB,CAAA,EAG3BkB,EAAa,SAAW,aAAeA,EAAa,qBAAuB,SAC7EA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,qBAAuB,KACtCA,EAAa,mBAAqBC,EAAA,GAIhCD,EAAa,oBAAsBA,EAAa,SAAW,cAE7DA,EAAa,OAAS,WAIxB,MAAME,EAAoB,CAAA,EAC1B,OAAO,KAAKF,CAAY,EAAE,QAAQG,GAAO,CACnCH,EAAaG,CAAG,IAAM,SACxBD,EAAaC,CAAG,EAAIH,EAAaG,CAAG,EAExC,CAAC,EAED,MAAMpB,EAAUW,EAAgBQ,CAAY,CAC9C,EAGA,MAAM,kBAAkBT,EAAoBrC,EAAsC,CAChF,MAAMsC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAC5D,MAAM4B,EAAUU,CAAc,CAChC,EAGA,wBAAwBD,EAAoBR,EAAiD,CAC3F,MAAMK,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAME,CAAU,EACpCtB,EAAQ,aAAc,MAAM,CAAA,EAG9B,OAAOe,EAAWjB,EAAIkB,GAAa,CACjC,MAAMiB,EAAejB,EAAS,KAAK,IAAId,GAAO,CAC5C,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,EACDP,EAASmB,CAAY,CACvB,CAAC,CACH,EAGA,uBACEX,EACArC,EACA6B,EACA,CACA,MAAMS,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EAE5D,OAAO8B,EAAWQ,EAAiBrB,GAAQ,CACzC,GAAIA,EAAI,SAAU,CAChB,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEzC,QAAQ,IAAI,yCAA0CC,CAAI,EAC1D,QAAQ,IAAI,mDAAoDA,EAAK,kBAAkB,EAEvF,MAAMkB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,QAAQ,IAAI,0DAA2DkB,CAAe,EAEtF,MAAMa,EAAc,CAClB,eAAgBhC,EAAI,GACpB,GAAGmB,CAAA,EAELP,EAASoB,CAAW,CACtB,MACEpB,EAAS,IAAI,CAEjB,CAAC,CACH,EAGA,MAAM,uBAAuBhC,EAA2C,CACtE,MAAMqC,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEgB,EAAIC,EACRoB,EACAC,EAAM,SAAU,KAAM,SAAS,EAC/BpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,wBACJvC,EACAG,EACAkD,EACAxB,EACe,CACf,MAAMY,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EAE7EmD,EAAkB,CACtB,OAAAD,EACA,GAAGxB,CAAA,EAIDwB,IAAW,aAAe,EAACxB,GAAA,MAAAA,EAAS,oBACtCyB,EAAW,iBAAmB9D,EAAiB,IAAI,IAAM,GAI3D8D,EAAW,aAAe,IAAI,KAAA,EAAO,YAAA,EAErC,MAAMxB,EAAUW,EAAgBa,CAAU,CAC5C,EAGA,MAAM,iCAA0D,CAC9D,MAAMjB,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,qBAAsB,KAAM,CAAC,cAAe,QAAQ,CAAC,EAC3DpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,EAGA,MAAM,kCAA2D,CAC/D,MAAMF,EAAkB/B,EAAWC,EAAI,cAAc,EAC/CS,EAAIC,EACRoB,EACAC,EAAM,aAAc,KAAM,IAAI,EAC9BpB,EAAQ,aAAc,MAAM,CAAA,EAI9B,OADsB,MAAMC,EAAQH,CAAC,GAChB,KAAK,IAAII,GAAO,CACnC,MAAMC,EAAOC,EAAkBF,EAAI,KAAA,CAAM,EAEnCmB,EAAkB,CACtB,GAAGlB,EACH,mBAAoB,MAAM,QAAQA,EAAK,kBAAkB,EAAIA,EAAK,mBAAqB,CAAA,EACvF,eAAgB,MAAM,QAAQA,EAAK,cAAc,EAAIA,EAAK,eAAiB,CAAA,EAC3E,aAAc,MAAM,QAAQA,EAAK,YAAY,EAAIA,EAAK,aAAe,CAAA,CAAC,EAGxE,MAAO,CACL,eAAgBD,EAAI,GACpB,GAAGmB,CAAA,CAEP,CAAC,CACH,CACF,EAGaO,EAAsB,CAEjC,MAAM,kBACJ9C,EACAuD,EACAC,EACiB,CACjB,MAAM1C,EAAA,EAEN,MAAM2C,EAAWnD,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMwC,EAAUnB,EAAM,aAAc,KAAMtC,CAAS,CAAC,EAwB5D,GArBIuD,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,cAAe,KAAMiB,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXvC,EAAIC,EAAMD,EAAGsB,EAAM,SAAU,KAAMiB,EAAQ,QAAQ,CAAC,GAGlDA,GAAA,MAAAA,EAAS,MAAQA,EAAQ,KAAK,OAAS,IACzCvC,EAAIC,EAAMD,EAAGsB,EAAM,OAAQ,qBAAsBiB,EAAQ,IAAI,CAAC,GAG5DA,GAAA,MAAAA,EAAS,aACXvC,EAAIC,EACFD,EACAsB,EAAM,gBAAiB,KAAMiB,EAAQ,WAAW,GAAG,EACnDjB,EAAM,gBAAiB,KAAMiB,EAAQ,WAAW,GAAG,CAAA,GAKnDA,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCvC,EAAIC,EACFD,EACAsB,EAAM,cAAe,KAAMoB,CAAU,EACrCpB,EAAM,cAAe,KAAMoB,EAAa,GAAQ,CAAA,CAEpD,CAGA1C,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCsC,IACFxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAO1D,IAAIb,GAHkB,MAAMxB,EAAQH,CAAC,GAGX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,aAAeZ,EAAM,OAAS,EAAG,CAC5C,MAAMe,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,GAC1CE,EAAK,eAAe,YAAA,EAAc,SAASF,CAAU,CAAA,CAEzD,CAEA,OAAOf,CACT,EAGA,0BACE3C,EACAgC,EACAuB,EACA,CACA,MAAME,EAAWnD,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMwC,EAAUnB,EAAM,aAAc,KAAMtC,CAAS,EAAGkB,EAAQ,eAAgB,MAAM,CAAC,EAU7F,GARIqC,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,cAAe,KAAMiB,EAAQ,MAAM,CAAC,GAGrDA,GAAA,MAAAA,EAAS,WACXvC,EAAIC,EAAMD,EAAGsB,EAAM,SAAU,KAAMiB,EAAQ,QAAQ,CAAC,GAGlDA,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCvC,EAAIC,EACFD,EACAsB,EAAM,cAAe,KAAMoB,CAAU,EACrCpB,EAAM,cAAe,KAAMoB,EAAa,GAAQ,CAAA,CAEpD,CAEA,OAAOzB,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GACnBA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,GAC1CE,EAAK,eAAe,YAAA,EAAc,SAASF,CAAU,CAAA,CAEzD,CAEA1B,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,0BACJY,EACAC,EACiB,CACjB,MAAM1C,EAAA,EAEN,MAAM2C,EAAWnD,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMwC,EAAUnB,EAAM,aAAc,KAAM,IAAI,CAAC,EAGnDiB,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMiB,EAAQ,MAAM,CAAC,GAI9DvC,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCsC,IACFxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAM1D,IAAIb,GAFkB,MAAMxB,EAAQH,CAAC,GAEX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,KAC1CG,EAAAD,EAAK,8BAAL,YAAAC,EAAkC,cAAc,SAASH,IAAU,CAEvE,CAEA,OAAOf,CACT,EAGA,6BACEX,EACAuB,EACA,CACA,MAAME,EAAWnD,EAAWC,EAAI,OAAO,EACvC,IAAIS,EAAIC,EAAMwC,EAAUnB,EAAM,aAAc,KAAM,IAAI,EAAGpB,EAAQ,eAAgB,MAAM,CAAC,EAExF,OAAIqC,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMiB,EAAQ,MAAM,CAAC,GAGvDtB,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,KAC1CG,EAAAD,EAAK,8BAAL,YAAAC,EAAkC,cAAc,SAASH,IAAU,CAEvE,CAEA1B,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,WAAWmB,EAAoF,CACnG,MAAMhD,EAAA,EAEN,MAAM2C,EAAWnD,EAAWC,EAAI,OAAO,EACjCoB,MAAU,KAEVoC,EAAU,CACd,GAAGD,EACH,iBAAkBA,EAAS,kBAAoB,YAC/C,aAAcnC,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAIhC,OADe,MAAMnB,EAAOiD,EAAUM,CAAO,GAC/B,EAChB,EAGA,MAAM,WAAWhE,EAAgB8B,EAAuC,CACtE,MAAMf,EAAA,EAEN,MAAMkD,EAAU5C,EAAIb,EAAI,QAASR,CAAM,EAEjCkE,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCpC,EAAQ,mBAAqB,SAAWoC,EAAgB,iBAAmBpC,EAAQ,kBACnFA,EAAQ,aAAe,SAAWoC,EAAgB,WAAapC,EAAQ,YACvEA,EAAQ,8BAAgC,SAAWoC,EAAgB,4BAA8BpC,EAAQ,6BACzGA,EAAQ,iBAAmB,SAAWoC,EAAgB,eAAiBpC,EAAQ,gBAC/EA,EAAQ,iBAAmB,SAAWoC,EAAgB,eAAiBpC,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWoC,EAAgB,cAAgBpC,EAAQ,eAC7EA,EAAQ,cAAgB,SAAWoC,EAAgB,YAAcpC,EAAQ,aACzEA,EAAQ,SAAW,SAAWoC,EAAgB,OAASpC,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWoC,EAAgB,IAAMpC,EAAQ,KACzDA,EAAQ,eAAiB,SAAWoC,EAAgB,aAAepC,EAAQ,cAC3EA,EAAQ,iBAAmB,SAAWoC,EAAgB,eAAiBpC,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWoC,EAAgB,YAAcpC,EAAQ,aACzEA,EAAQ,QAAU,SAAWoC,EAAgB,MAAQpC,EAAQ,OAC7DA,EAAQ,QAAU,SAAWoC,EAAgB,MAAQpC,EAAQ,OAC7DA,EAAQ,WAAa,SAAWoC,EAAgB,SAAWpC,EAAQ,UACnEA,EAAQ,SAAW,SAAWoC,EAAgB,OAASpC,EAAQ,QAEnE,MAAMC,EAAUkC,EAASC,CAAe,CAC1C,EAGA,MAAM,WAAWlE,EAA+B,CAC9C,MAAMe,EAAA,EAEN,MAAMkD,EAAU5C,EAAIb,EAAI,QAASR,CAAM,EACvC,MAAMgC,EAAUiC,CAAO,CACzB,EAGA,MAAM,uBAAuBxB,EAAoBrC,EAAwC,CACvF,MAAMW,EAAA,EAEN,MAAM2C,EAAWnD,EAAWC,EAAI,OAAO,EACjCS,EAAIC,EACRwC,EACAnB,EAAM,iBAAkB,KAAMnC,CAAa,EAC3Ce,EAAQ,eAAgB,KAAK,CAAA,EAK/B,OAFsB,MAAMC,EAAQH,CAAC,GAEhB,KAAK,IAAII,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,CACZ,EAGA,MAAM,sBACJrB,EACAC,EACAV,EACA4E,EACAC,EACiB,CACjB,MAAMrD,EAAA,EAGN,MAAM8C,EAAO,MAAM,KAAK,YAAY7D,CAAM,EAC1C,GAAI,CAAC6D,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMQ,EAAc9E,GAAUsE,EAAK,eAAiBA,EAAK,cAAgB,OACnES,EAAsCT,EAAK,gBAAkB,KAEnE,QAAQ,IAAI,kCAAmC,CAC7C,OAAA7D,EACA,UAAAC,EACA,qBAAAqE,EACA,cAAeT,EAAK,WACpB,YAAAQ,CAAA,CACD,EAGD,GAAI,CACF,MAAOvE,EAAa,mBAA2B,aAAcE,EAAQ6D,EAAK,WAAYS,EAAsB,CAC1G,OAAQ,qBACR,kBAAmBrE,EACnB,uBAAwBqE,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,qCAAsCA,CAAU,CAC/D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,aACVA,EAAqB,QAAQ,YAAa,EAAE,IAE5CrE,GAEvB,QAAQ,IAAI,+EAA+E,EACpF,MAAM,KAAK,0BAA0BD,EAAQsE,EAAsBrE,EAAWoE,EAAaF,EAAOC,CAAK,IAG9G,QAAQ,IAAI,gEAAgE,EACrE,MAAM,KAAK,iCAAiCpE,EAAQsE,EAAsBrE,EAAWoE,EAAaF,EAAOC,CAAK,GAKrHE,GAAA,MAAAA,EAAsB,WAAW,iBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDrE,GAEvB,QAAQ,IAAI,+DAA+D,EACpE,MAAM,KAAK,8BAA8BD,EAAQsE,EAAsBrE,EAAWoE,EAAaF,EAAOC,CAAK,IAGlH,QAAQ,IAAI,oEAAoE,EACzE,MAAM,KAAK,qCAAqCpE,EAAQsE,EAAsBrE,EAAWoE,EAAaF,EAAOC,CAAK,GAUxHE,GAML,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,8BAA8BtE,EAAQC,EAAWoE,EAAaF,CAAK,IANnF,QAAQ,IAAI,yDAAyD,EAC9D,MAAM,KAAK,8BAA8BnE,EAAQC,EAAWoE,EAAaF,EAAOC,CAAK,EAMhG,EAGA,MAAM,yBACJpE,EACAsE,EACArE,EACAoE,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBvE,CAAS,GAGvD,MAAM,KAAK,0BAA0BD,EAAQsE,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBrE,EAAQwE,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWnE,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgBuE,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,iDAAiD,EAG7D,GAAI,CACF,MAAMtE,EAAa,mBAAmB,aAAcE,EAAQC,EAAWuE,EAAuB,CAC5F,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BACJxE,EACAsE,EACA7B,EACA4B,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BpE,EAAQsE,EAAsBD,CAAW,EAM9E,MAAM,KAAK,WAAWrE,EAAQ,CAC5B,WAAYyC,EACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,OACb,MAAO2B,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,kDAAkD,EAG9D,GAAI,CACF,MAAMtE,EAAa,mBAAmB,aAAcE,EAAQyC,EAAY,KAAM,CAC5E,OAAQ,uBACR,SAAU,MACV,iBAAkB6B,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,gDAAiDA,CAAU,CAC1E,CAGA,OAAOD,CACT,EAGA,MAAM,iCACJtE,EACAsE,EACAI,EACAL,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBE,CAAY,GAG1D,MAAM,KAAK,0BAA0B1E,EAAQsE,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBrE,EAAQwE,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWnE,EAAQ,CAC5B,WAAY0E,EACZ,iBAAkB,YAClB,eAAgBF,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtE,EAAa,mBAAmB,aAAcE,EAAQ0E,EAAcF,EAAuB,CAC/F,OAAQ,uBACR,SAAU,MACV,iBAAkBF,EAClB,eAAgBE,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,8BACJxE,EACAsE,EACA7B,EACA4B,EACAI,EACAL,EACiB,CAEjB,MAAM,KAAK,0BAA0BpE,EAAQsE,EAAsBD,CAAW,EAG9E,MAAM,KAAK,WAAWrE,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,YAAa,YACb,MAAOyE,EACP,MAAOL,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtE,EAAa,mBAAmB,eAAgBE,EAAQ,KAAM,YAAa,CAC/E,OAAQ,yBACR,SAAU,MACV,iBAAkBsE,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,OAAOD,CACT,EAGA,MAAM,qCACJtE,EACAsE,EACAI,EACAL,EACAF,EACAC,EACiB,CACjB,MAAMO,EAAoB,YAAYD,CAAY,GAGlD,MAAM,KAAK,0BAA0B1E,EAAQsE,EAAsBD,CAAW,EAG9E,MAAM,KAAK,qBAAqBrE,EAAQ2E,EAAmBN,EAAa,eAAgB,iBAAkBF,CAAK,EAG/G,MAAM,KAAK,WAAWnE,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB2E,EAChB,YAAa,YACb,MAAOP,GAAS,EAAA,CACjB,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtE,EAAa,mBAAmB,aAAcE,EAAQ,KAAM2E,EAAmB,CACnF,OAAQ,uBACR,SAAU,MACV,iBAAkBL,EAClB,eAAgBK,EAChB,OAAQN,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOI,CACT,EAGA,MAAM,8BACJ3E,EACAC,EACAoE,EACAF,EACAC,EACiB,CACjB,MAAMI,EAAwB,gBAAgBvE,CAAS,GAGvD,MAAM,KAAK,qBAAqBD,EAAQwE,EAAuBH,EAAa,WAAY,uBAAwBF,CAAK,EAGrH,MAAM,KAAK,WAAWnE,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgBuE,EAChB,YAAa,OACb,MAAAJ,CAAA,CACD,EAED,QAAQ,IAAI,sDAAsD,EAGlE,GAAI,CACF,MAAMtE,EAAa,mBAAmB,aAAcE,EAAQC,EAAWuE,EAAuB,CAC5F,OAAQ,uBACR,SAAU,IACV,YAAa,YACb,eAAgBA,EAChB,OAAQH,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,0CAA2CA,CAAU,CACpE,CAEA,OAAOC,CACT,EAGA,MAAM,0BAA0BxE,EAAgBI,EAAuBwE,EAAoC,CACzG,MAAMlC,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAI,CAACC,EAAgB,SAAU,CAC7B,QAAQ,KAAK,wCAAyCvC,CAAa,EACnE,MACF,CAEA,MAAMyE,EAAelC,EAAgB,KAAA,EAE/BmC,GADkBD,EAAa,UAAY,CAAA,GACV,OAAQE,GAAeA,IAAO/E,CAAM,EAE3E,GAAI8E,EAAe,SAAW,EAE5B,GAAI,CACF,MAAM9C,EAAUU,CAAc,EAC9B,QAAQ,IAAI,iCAAkCtC,CAAa,EAG3D,GAAI,CACF,MAAMN,EAAa,0BAA0BM,EAAe,UAAWyE,EAAc,IAAI,CAC3F,OAASN,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAASxF,EAAO,CACd,QAAQ,MAAM,wCAAyCqB,EAAerB,CAAK,CAE7E,KAGA,IAAI,CACF,MAAM2E,EAAWnD,EAAWC,EAAI,OAAO,EACjCwE,EAAa9D,EAAMwC,EAAUnB,EAAM,WAAY,KAAMuC,CAAc,CAAC,EAGpEG,GAFgB,MAAM7D,EAAQ4D,CAAU,GAEZ,KAC/B,IAAI3D,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAAC6D,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD1B,EAAa,CACjB,SAAUuB,EACV,OAAQM,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMrD,EAAUW,EAAgBa,CAAU,EAC1C,QAAQ,IAAI,wCAAyCnD,EAAe,cAAegF,CAAU,EAG7F,GAAI,CACF,MAAMtF,EAAa,0BAA0BM,EAAe,UAAWyE,EAActB,CAAU,CACjG,OAASgB,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CACF,OAASxF,EAAO,CACd,QAAQ,MAAM,gDAAiDqB,EAAerB,CAAK,CAErF,CAEJ,EAGA,MAAM,qBACJiB,EACAI,EACAb,EACA8F,EACAC,EACAnB,EACe,CACf,MAAMzB,EAAiBrB,EAAIb,EAAI,eAAgBJ,CAAa,EACtDuC,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAElB,GAAI,CACF,MAAMkC,EAAelC,EAAgB,KAAA,EAC/B4C,EAAkBV,EAAa,UAAY,CAAA,EAC3CC,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGS,EAAiBvF,CAAM,CAAC,CAAC,EAG1D0D,EAAWnD,EAAWC,EAAI,OAAO,EACjCwE,EAAa9D,EAAMwC,EAAUnB,EAAM,WAAY,KAAMuC,CAAc,CAAC,EAGpEG,GAFgB,MAAM7D,EAAQ4D,CAAU,GAEZ,KAC/B,IAAI3D,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAAC6D,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENC,EAAa,WAAWH,CAAW,EAAI,EAAI,OAASA,EAEpD1B,EAAa,CACjB,SAAUuB,EACV,OAAQM,EACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMrD,EAAUW,EAAgBa,CAAU,EAC1C,QAAQ,IAAI,yCAA0CnD,EAAe,cAAegF,CAAU,EAG9F,GAAI,CACF,MAAMtF,EAAa,0BAA0BM,EAAe,UAAWyE,EAActB,CAAU,CACjG,OAASgB,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CACF,OAASxF,EAAO,CACd,QAAQ,MAAM,2CAA4CqB,EAAerB,CAAK,CAEhF,KAGA,IAAI,CACF,MAAMyG,EAAU,MAAM1E,EAAe,WAAWV,EAAc,QAAQiF,IAAoB,WAAa,gBAAkB,YAAa,EAAE,CAAC,EACnII,GAAcD,GAAA,YAAAA,EAAS,OAAQ,QAE/BhD,EAAkB,CACtB,WAAYpC,EAAc,QAAQiF,IAAoB,WAAa,gBAAkB,YAAa,EAAE,EACpG,aAAc,KACd,iBAAkB5F,EAAiB,IAAI,IAAM,EAC7C,OAAQ4F,IAAoB,WAAa,YAAcI,EACvD,iBAAkBJ,EAClB,eAAgB,UAChB,OAAA9F,EACA,gBAAiB,cACjB,MAAO4E,GAAS,yBAAyBkB,IAAoB,WAAa,iBAAmB,SAAS,IAAIA,IAAoB,WAAa,YAAc,SAAS,GAClK,OAAQ,UACR,mBAAoBA,IAAoB,WAAa,cAAgB,SACrE,cAAeC,EACf,SAAU,CAACtF,CAAM,EACjB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAM0F,EAAOhD,EAAgBF,CAAe,EAC5C,QAAQ,IAAI,8BAA+BpC,EAAe,UAAWb,CAAM,EAG3E,GAAI,CACF,MAAMO,EAAa,0BAA0BM,EAAe,UAAW,KAAMoC,CAAe,CAC9F,OAAS+B,EAAY,CACnB,QAAQ,KAAK,yCAA0CA,CAAU,CACnE,CACF,OAASxF,EAAO,CACd,QAAQ,MAAM,sCAAuCqB,EAAerB,CAAK,CAE3E,CAEJ,EAGA,MAAM,4BACJ4G,EACA1F,EACA2F,EAII,CAAA,EACa,CACjB,MAAM7E,EAAA,EAIN,MAAM2C,EAAWnD,EAAWC,EAAI,OAAO,EACjCwE,EAAa9D,EAAMwC,EAAUnB,EAAM,WAAY,KAAMoD,CAAO,CAAC,EAC7DE,EAAgB,MAAMzE,EAAQ4D,CAAU,EAE9C,GAAIa,EAAc,MAChB,MAAM,IAAI,MAAM,+BAA+B,EAGjD,MAAMC,EAAyB,gBAAgB7F,CAAS,GAGxD,UAAW8F,KAAWF,EAAc,KAAM,CACxC,MAAM7F,EAAS+F,EAAQ,GACjBhC,EAAgBgC,EAAQ,KAAA,EACxB1B,EAAcuB,EAAe,QAAU7B,EAAS,eAAiBA,EAAS,cAAgB,OAC1FO,EAAsCP,EAAS,gBAAkB,KAGvE,GAAIO,GAAA,MAAAA,EAAsB,WAAW,aAGnC,GAFsBA,EAAqB,QAAQ,YAAa,EAAE,IAE5CrE,EAAW,CAG/B,QAAQ,IAAI,8FAA+FD,CAAM,EACjH,MAAM,KAAK,0BAA0BA,EAAQsE,EAAsBD,CAAW,EAC9E,MAAM,KAAK,WAAWrE,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,OACb,MAAO2F,EAAe,MACtB,MAAOA,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,KAAO,CAEL,QAAQ,IAAI,2FAA4F5F,CAAM,EAC9G,MAAM,KAAK,0BAA0BA,EAAQsE,EAAsBD,CAAW,EAC9E,MAAM,KAAK,qBAAqBrE,EAAQ8F,EAAwBzB,EAAa,WAAY,uBAAwBuB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAW5F,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB6F,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,CAIF,GAAI,CAACtB,EAAsB,CACzB,QAAQ,IAAI,qDAAsDtE,CAAM,EACxE,MAAM,KAAK,qBAAqBA,EAAQ8F,EAAwBzB,EAAa,WAAY,uBAAwBuB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAW5F,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB6F,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EACD,QACF,CAGA,QAAQ,IAAI,oEAAqE5F,EAAQsE,CAAoB,EAC7G,MAAM,KAAK,qBAAqBtE,EAAQ8F,EAAwBzB,EAAa,WAAY,uBAAwBuB,EAAe,KAAK,EACrI,MAAM,KAAK,WAAW5F,EAAQ,CAC5B,WAAYC,EACZ,iBAAkB,YAClB,eAAgB6F,EAChB,YAAa,OACb,MAAOF,EAAe,OAAS,GAC/B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CACH,CAEA,OAAOE,CACT,EAGA,MAAM,sBACJ9F,EACAC,EACAV,EACA4E,EACiB,CACjB,MAAMpD,EAAA,EAGN,MAAM8C,EAAO,MAAM,KAAK,YAAY7D,CAAM,EAC1C,GAAI,CAAC6D,EACH,MAAM,IAAI,MAAM,gBAAgB,EAGlC,MAAMQ,EAAc9E,GAAUsE,EAAK,eAAiBA,EAAK,cAAgB,OACnES,EAAsCT,EAAK,gBAAkB,KAEnE,QAAQ,IAAI,8BAA+B,CACzC,OAAA7D,EACA,UAAAC,EACA,qBAAAqE,EACA,cAAeT,EAAK,WACpB,YAAAQ,CAAA,CACD,EAGD,GAAI,CACF,MAAOvE,EAAa,mBAA2B,SAAUE,EAAQ6D,EAAK,WAAYS,EAAsB,CACtG,OAAQ,iBACR,kBAAmBrE,EACnB,uBAAwBqE,EACxB,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,iCAAkCA,CAAU,CAC3D,CAKA,OAAID,GAAA,MAAAA,EAAsB,WAAW,kBACVA,EAAqB,QAAQ,gBAAiB,EAAE,IAEhDrE,GAEvB,QAAQ,IAAI,mEAAmE,EACxE,MAAM,KAAK,yBAAyBD,EAAQsE,EAAsBrE,EAAWoE,EAAaF,CAAK,IAK1G,QAAQ,IAAI,2DAA2D,EAChE,MAAM,KAAK,gBAAgBnE,EAAQC,EAAWoE,EAAaF,CAAK,EACzE,EAGA,MAAM,yBACJnE,EACAsE,EACA7B,EACA4B,EACAF,EACiB,CAMjB,MAAM,KAAK,0BAA0BnE,EAAQsE,EAAsBD,CAAW,EAG9E,MAAM,KAAK,WAAWrE,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,YAAa,YACb,MAAAmE,CAAA,CACD,EAED,QAAQ,IAAI,yDAAyD,EAGrE,GAAI,CACF,MAAMrE,EAAa,mBAAmB,SAAUE,EAAQ,KAAMsE,EAAsB,CAClF,OAAQ,mBACR,SAAU,uBACV,iBAAkBA,EAClB,UAAW,YACX,OAAQD,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAGA,OAAOD,CACT,EAGA,MAAM,gBACJtE,EACAC,EACAoE,EACAF,EACiB,CAEjB,IAAIsB,EAAc,QAClB,GAAI,CACF,MAAMD,EAAU,MAAM1E,EAAe,WAAWb,CAAS,EACzDwF,GAAcD,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAASzG,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAGA,MAAM4F,EAAoB,YAAY1E,CAAS,GAEzCuC,EAAkB,CACtB,WAAYvC,EACZ,aAAc,KACd,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQgG,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQpB,EACR,gBAAiB,cACjB,MAAOF,GAAS,+EAChB,OAAQ,UACR,mBAAoB,SACpB,cAAe,iBACf,SAAU,CAACnE,CAAM,EACjB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGjC0C,EAAiBrB,EAAIb,EAAI,eAAgBmE,CAAiB,EAChE,MAAMe,EAAOhD,EAAgBF,EAAiB,CAAE,MAAO,GAAM,EAG7D,MAAM,KAAK,WAAWxC,EAAQ,CAC5B,WAAY,KACZ,iBAAkB,YAClB,eAAgB2E,EAChB,YAAa,WAAA,CACd,EAED,QAAQ,IAAI,0CAA0C,EAGtD,GAAI,CACF,MAAM7E,EAAa,mBAAmB,SAAUE,EAAQ,KAAM2E,EAAmB,CAC/E,OAAQ,mBACR,SAAU,aACV,YAAa,YACb,eAAgBA,EAChB,OAAQN,CAAA,CACT,CACH,OAASE,EAAY,CACnB,QAAQ,KAAK,sCAAuCA,CAAU,CAChE,CAEA,OAAOI,CACT,EAGA,MAAM,2BACJU,EACApF,EACA+F,EACe,CACf,MAAMjF,EAAA,EAGN,MAAM+E,EAAyBT,IAAoB,OAC/C,YAAYpF,CAAS,GACrB,gBAAgBA,CAAS,GAGvByC,EAAiBrB,EAAIb,EAAI,eAAgBsF,CAAsB,EAC/DnD,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAI,CAACC,EAAgB,SACnB,MAAM,IAAI,MAAM,uBAAuB,EAIzC,MAAMgD,EADkBhD,EAAgB,KAAA,EACR,UAAY,CAAA,EAG5C,MAAMZ,EAAUW,EAAgB,CAC9B,OAAQ,YACR,eAAgBsD,EAChB,iBAAkBvG,EAAiB,IAAI,IAAM,EAC7C,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAMwG,EAAQC,EAAW1F,CAAE,EAC3B,UAAWR,KAAU2F,EAAS,CAC5B,MAAM1B,EAAU5C,EAAIb,EAAI,QAASR,CAAM,EACnCqF,IAAoB,OAEtBY,EAAM,OAAOhC,EAAS,CACpB,eAAgB,KAChB,iBAAkB,OAClB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGDgC,EAAM,OAAOhC,EAAS,CACpB,WAAY,KACZ,eAAgB,KAChB,iBAAkB,YAClB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,CAEL,CAEA,MAAMgC,EAAM,OAAA,CACd,EAGA,MAAM,YAAYjG,EAAsC,CACtD,MAAMe,EAAA,EAEN,MAAMkD,EAAU5C,EAAIb,EAAI,QAASR,CAAM,EACjCmG,EAAW,MAAMzE,EAAOuC,CAAO,EAErC,OAAIkC,EAAS,SACJ,CACL,QAASA,EAAS,GAClB,GAAGA,EAAS,KAAA,CAAK,EAGd,IACT,EAGA,MAAM,cAAclG,EAAmBmG,EAAyC,CAE9E,MAAMC,EAAe,MAAM,KAAK,YAAYD,CAAc,EAC1D,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,MAAMzE,MAAU,KACV0E,EAAY,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACtEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,MACpB,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,eAAgBF,EAAa,eAC7B,WAAYpG,EACZ,aAAc2B,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQyE,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQrD,GAAO,CACrCqD,EAAerD,CAAG,IAAM,QAC1B,OAAOqD,EAAerD,CAAG,CAE7B,CAAC,EAGD,MAAMc,EAAU5C,EAAIb,EAAI,QAAS8F,CAAS,EAC1C,aAAMZ,EAAOzB,EAASuC,CAAc,EAE7BF,CACT,EAGA,MAAM,uBACJrG,EACAG,EACAqG,EACAC,EACA9D,EACmB,CACnB,MAAMqD,EAAQC,EAAW1F,CAAE,EACrBsC,EAA2B,CAAA,EAC3BlB,MAAU,KAEhB,OAAAgB,EAAM,QAASmB,GAAa,CAC1B,MAAM/D,EAAS,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACzE8C,EAAe,KAAK9C,CAAM,EAE1B,MAAMiE,EAAU5C,EAAIb,EAAI,QAASR,CAAM,EACjC2G,EAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEnE9C,EAAO,CACX,QAAS7D,EACT,YAAa+D,EAAS,YACtB,OAAQ2C,EACR,IAAK3C,EAAS,KAAO,GACrB,eAAgBA,EAAS,eACzB,cAAeA,EAAS,cACxB,aAAcA,EAAS,cAAgB,GACvC,eAAgB,cAChB,YAAa,OACb,MAAOA,EAAS,MAChB,OAAQ4C,EACR,SAAU,GACV,eAAgBvG,EAChB,WAAYH,EACZ,aAAcwG,EACd,aAAc7E,EAAI,YAAA,EAClB,OAAQ,CAAA,CAAC,EAGXqE,EAAM,IAAIhC,EAASJ,CAAI,CACzB,CAAC,EAED,MAAMoC,EAAM,OAAA,EACLnD,CACT,CACF,EAGa8D,EAA2B,CAEtC,MAAM,0BACJpD,EACAC,EACiB,CACjB,MAAMC,EAAWnD,EAAWC,EAAI,oBAAoB,EACpD,IAAIS,EAAIC,EAAMwC,CAAQ,EAGlBF,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMiB,EAAQ,MAAM,CAAC,GAI9DvC,EAAIC,EAAMD,EAAGE,EAAQ,eAAgB,MAAM,CAAC,EAExCsC,IACFxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAK,CAAC,EAChCA,EAAW,KAAO,IACpBxC,EAAIC,EAAMD,EAAG2C,EAAMH,EAAW,KAAOA,EAAW,KAAK,CAAC,IAM1D,IAAIb,GAFkB,MAAMxB,EAAQH,CAAC,GAEX,KAAK,IAAII,IAAQ,CACzC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,KAC1CG,EAAAD,EAAK,8BAAL,YAAAC,EAAkC,cAAc,SAASH,IAAU,CAEvE,CAEA,OAAOf,CACT,EAGA,MAAM,yBAAyB5C,EAAsC,CACnE,MAAMiE,EAAU5C,EAAIb,EAAI,qBAAsBR,CAAM,EAC9CmG,EAAW,MAAMzE,EAAOuC,CAAO,EAErC,OAAIkC,EAAS,SACJ,CACL,QAASA,EAAS,GAClB,GAAGA,EAAS,KAAA,CAAK,EAGd,IACT,EAGA,MAAM,+BAA+BC,EAAyC,CAE5E,MAAMC,EAAe,MAAM,KAAK,yBAAyBD,CAAc,EACvE,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,4CAA4C,EAG9D,MAAMzE,MAAU,KACV0E,EAAY,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACvEC,EAAW,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAItEC,EAAsB,CAC1B,QAASF,EACT,YAAaD,EAAa,YAC1B,OAAQA,EAAa,OACrB,IAAKA,EAAa,KAAO,GACzB,eAAgBA,EAAa,gBAAkB,GAC/C,cAAeA,EAAa,eAAiB,GAC7C,aAAcA,EAAa,cAAgB,GAC3C,eAAgBA,EAAa,eAC7B,YAAa,OACb,MAAOA,EAAa,MACpB,MAAOA,EAAa,OAAS,GAC7B,OAAQE,EACR,SAAU,GACV,iBAAkB,YAClB,4BAA6BF,EAAa,6BAA+B,GACzE,eAAgBA,EAAa,eAC7B,aAAczE,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,EAClB,OAAQyE,EAAa,QAAU,CAAA,CAAC,EAIlC,OAAO,KAAKG,CAAc,EAAE,QAAQrD,GAAO,CACrCqD,EAAerD,CAAG,IAAM,QAC1B,OAAOqD,EAAerD,CAAG,CAE7B,CAAC,EAGD,MAAMc,EAAU5C,EAAIb,EAAI,qBAAsB8F,CAAS,EACvD,aAAMZ,EAAOzB,EAASuC,CAAc,EAE7BF,CACT,EAGA,MAAM,4BAA4BvC,EAAoF,CACpH,MAAML,EAAWnD,EAAWC,EAAI,oBAAoB,EAC9CoB,MAAU,KAEVoC,EAAU,CACd,GAAGD,EACH,iBAAkBA,EAAS,kBAAoB,YAC/C,aAAcnC,EAAI,YAAA,EAClB,aAAcA,EAAI,YAAA,CAAY,EAIhC,OADe,MAAMnB,EAAOiD,EAAUM,CAAO,GAC/B,EAChB,EAGA,MAAM,4BAA4BhE,EAAgB8B,EAAuC,CACvF,MAAMmC,EAAU5C,EAAIb,EAAI,qBAAsBR,CAAM,EAE9CkE,EAAuB,CAC3B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGnCpC,EAAQ,mBAAqB,SAAWoC,EAAgB,iBAAmBpC,EAAQ,kBACnFA,EAAQ,8BAAgC,SAAWoC,EAAgB,4BAA8BpC,EAAQ,6BACzGA,EAAQ,iBAAmB,SAAWoC,EAAgB,eAAiBpC,EAAQ,gBAC/EA,EAAQ,gBAAkB,SAAWoC,EAAgB,cAAgBpC,EAAQ,eAC7EA,EAAQ,cAAgB,SAAWoC,EAAgB,YAAcpC,EAAQ,aACzEA,EAAQ,SAAW,SAAWoC,EAAgB,OAASpC,EAAQ,QAC/DA,EAAQ,MAAQ,SAAWoC,EAAgB,IAAMpC,EAAQ,KACzDA,EAAQ,eAAiB,SAAWoC,EAAgB,aAAepC,EAAQ,cAC3EA,EAAQ,iBAAmB,SAAWoC,EAAgB,eAAiBpC,EAAQ,gBAC/EA,EAAQ,cAAgB,SAAWoC,EAAgB,YAAcpC,EAAQ,aACzEA,EAAQ,QAAU,SAAWoC,EAAgB,MAAQpC,EAAQ,OAC7DA,EAAQ,QAAU,SAAWoC,EAAgB,MAAQpC,EAAQ,OAC7DA,EAAQ,WAAa,SAAWoC,EAAgB,SAAWpC,EAAQ,UACnEA,EAAQ,SAAW,SAAWoC,EAAgB,OAASpC,EAAQ,QAEnE,MAAMC,EAAUkC,EAASC,CAAe,CAC1C,EAGA,MAAM,4BAA4BlE,EAA+B,CAC/D,MAAMiE,EAAU5C,EAAIb,EAAI,qBAAsBR,CAAM,EACpD,MAAMgC,EAAUiC,CAAO,CACzB,EAGA,MAAM,2BAA6D,CACjE,MAAMP,EAAWnD,EAAWC,EAAI,oBAAoB,EAC9C2B,EAAW,MAAM0E,EAAmBnD,CAAQ,EAE5CoD,EAAgB5F,EAAMwC,CAAQ,EAC9BqD,EAAe,MAAM3F,EAAQ0F,CAAa,EAEhD,IAAIE,EAAiB,EACjBC,EAAiB,EACjBC,EAAY,EAEhB,OAAAH,EAAa,KAAK,QAAQ1F,GAAO,CAE/B,OADaA,EAAI,KAAA,EACJ,iBAAA,CACX,IAAK,YACH2F,IACA,MACF,IAAK,YACHC,IACA,MACF,IAAK,OACHC,IACA,KAAA,CAEN,CAAC,EAEM,CACL,WAAY/E,EAAS,KAAA,EAAO,MAC5B,eAAA6E,EACA,eAAAC,EACA,UAAAC,CAAA,CAEJ,EAGA,6BACEjF,EACAuB,EACA,CACA,MAAME,EAAWnD,EAAWC,EAAI,oBAAoB,EACpD,IAAIS,EAAIC,EAAMwC,EAAUvC,EAAQ,eAAgB,MAAM,CAAC,EAEvD,OAAIqC,GAAA,MAAAA,EAAS,SACXvC,EAAIC,EAAMD,EAAGsB,EAAM,mBAAoB,KAAMiB,EAAQ,MAAM,CAAC,GAGvDtB,EAAWjB,EAAIkB,GAAa,CACjC,IAAIS,EAAQT,EAAS,KAAK,IAAId,IAAQ,CACpC,QAASA,EAAI,GACb,GAAGA,EAAI,KAAA,CAAK,EACJ,EAGV,GAAImC,GAAA,MAAAA,EAAS,YAAa,CACxB,MAAMG,EAAaH,EAAQ,YAAY,YAAA,EACvCZ,EAAQA,EAAM,OAAOiB,GAAA,OACnB,OAAAA,EAAK,YAAY,YAAA,EAAc,SAASF,CAAU,GAClDE,EAAK,OAAO,YAAA,EAAc,SAASF,CAAU,GAC7CE,EAAK,IAAI,YAAA,EAAc,SAASF,CAAU,KAC1CG,EAAAD,EAAK,8BAAL,YAAAC,EAAkC,cAAc,SAASH,IAAU,CAEvE,CAEA1B,EAASW,CAAK,CAChB,CAAC,CACH,EAGA,MAAM,sBACJ5C,EACAC,EACAV,EACA4E,EACiB,CAEjB,MAAMN,EAAO,MAAM,KAAK,yBAAyB7D,CAAM,EACvD,GAAI,CAAC6D,EACH,MAAM,IAAI,MAAM,mCAAmC,EAErD,MAAMQ,EAAc9E,GAAUsE,EAAK,eAAiBA,EAAK,cAAgB,OAGzE,IAAI4B,EAAc,UAClB,GAAI,CACF,MAAMD,EAAU,MAAM1E,EAAe,WAAWb,CAAS,EACzDwF,GAAcD,GAAA,YAAAA,EAAS,OAAQ,SACjC,OAASzG,EAAO,CACd,QAAQ,KAAK,sDAAuDA,CAAK,CAC3E,CAGA,MAAMyD,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQ,YACR,iBAAkB,WAClB,eAAgB,UAChB,OAAQ4E,EACR,gBAAiB,cACjB,MAAOF,GAAS,GAAGsB,CAAW,sBAC9B,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXnD,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiB,MAAMjC,EAAO6B,EAAiBE,CAAe,EAGpE,aAAM,KAAK,4BAA4BxC,EAAQ,CAC7C,iBAAkB,YAClB,eAAgB0C,EAAe,EAAA,CAChC,EAEMA,EAAe,EACxB,EAGA,MAAM,4BACJiD,EACA1F,EACA2F,EAII,CAAA,EACe,CACnB,MAAMK,EAAQC,EAAW1F,CAAE,EACrB2G,EAA2B,CAAA,EAC3BvF,MAAU,KAGVwF,EAAmB7G,EAAWC,EAAI,oBAAoB,EACtD6G,EAAqBnG,EAAMkG,EAAkB7E,EAAM,WAAY,KAAMoD,CAAO,CAAC,EAC7E2B,EAAwB,MAAMlG,EAAQiG,CAAkB,EAE9D,GAAIC,EAAsB,MACxB,MAAM,IAAI,MAAM,mCAAmC,EAIrD,IAAI7B,EAAc,UAClB,GAAI,CACF,MAAMD,EAAU,MAAM1E,EAAe,WAAWb,CAAS,EACzDwF,GAAcD,GAAA,YAAAA,EAAS,OAAQ,SACjC,OAASzG,EAAO,CACd,QAAQ,KAAK,sDAAuDA,CAAK,CAC3E,CAGA,MAAMyD,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiBmC,CAAG,EACtC,OAAQ,YACR,iBAAkB,WAClB,eAAgB,UAChB,OAAQgE,EAAe,QAAU,OACjC,gBAAiB,cACjB,MAAOA,EAAe,OAAS,GAAGH,CAAW,sBAC7C,WAAY,SACZ,OAAQ,UACR,mBAAoB,cACpB,cAAe,sBAAA,EAGXnD,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiBrB,EAAIiB,CAAe,EAC1C2D,EAAM,IAAIvD,EAAgBF,CAAe,EACzC2E,EAAe,KAAKzE,EAAe,EAAE,EAGrC4E,EAAsB,KAAK,QAASC,GAAoB,CACtD,MAAMC,EAAmBD,EAAgB,KAAA,EAGnCE,EAAgB,KAAK,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAC1EC,EAAiBrG,EAAIb,EAAI,WAAYP,EAAW,QAASwH,CAAa,EAEtEE,EAAkB,CACtB,QAASF,EACT,YAAaD,EAAiB,YAC9B,OAAQA,EAAiB,OACzB,IAAKA,EAAiB,IACtB,cAAeA,EAAiB,cAChC,aAAcA,EAAiB,cAAgB,GAC/C,eAAgB,OAChB,YAAa,OACb,MAAOA,EAAiB,MACxB,MAAO5B,EAAe,OAAS,GAC/B,OAAQ,MAAM,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GACnE,SAAU,GACV,eAAgBlD,EAAe,GAC/B,WAAYzC,EACZ,aAAcuH,EAAiB,aAC/B,aAAc5F,EAAI,YAAA,EAClB,OAAQ4F,EAAiB,QAAU,CAAA,CAAC,EAGtCvB,EAAM,IAAIyB,EAAgBC,CAAe,CAC3C,CAAC,EAGDhC,EAAQ,QAAQ3F,GAAU,CACxB,MAAMiE,EAAU5C,EAAIb,EAAI,qBAAsBR,CAAM,EACpDiG,EAAM,OAAOhC,EAAS,CACpB,iBAAkB,OAClB,eAAgBvB,EAAe,GAC/B,aAAcd,EAAI,YAAA,CAAY,CAC/B,CACH,CAAC,EAED,MAAMqE,EAAM,OAAA,EAIZ,MAAM2B,GADe,MAAM7E,EAAoB,kBAAkB9C,CAAS,GACpC,OACtC,aAAMa,EAAe,cAAcb,EAAW,CAC5C,SAAU,CACR,WAAY2H,EACZ,aAAchG,CAAA,CAChB,CACmB,EAEduF,CACT,EAGE,MAAM,sBAAsBnH,EAAgBI,EAAuBH,EAAkC,CAErG,MAAMyC,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EACnF,MAAM2B,EAAUW,EAAgB,CAC9B,OAAQ,WACR,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAM,KAAK,4BAA4B1C,EAAQ,CAC7C,iBAAkB,YAClB,eAAgB,MAAA,CACjB,CACH,EAGA,MAAM,eACJA,EACAI,EACAH,EACA+F,EACe,CAEf,MAAMtD,EAAiBrB,EAAIb,EAAI,WAAYP,EAAW,eAAgBG,CAAa,EACnF,MAAM2B,EAAUW,EAAgB,CAC9B,OAAQ,YACR,iBAAkBjD,EAAiB,IAAI,IAAM,EAC7C,eAAgBuG,EAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,MAAM,KAAK,4BAA4BhG,EAAQ,CAC7C,iBAAkB,OAClB,eAAgB,MAAA,CACjB,CACH,EAGA,MAAM,4BACJA,EACAC,EACAV,EACA4E,EACiB,CAEjB,MAAM0D,EAAkBtH,EAAWC,EAAI,WAAYP,EAAW,OAAO,EAC/D6H,EAAY5G,EAAM2G,EAAiBtF,EAAM,UAAW,KAAMvC,CAAM,CAAC,EACjEmG,EAAW,MAAM/E,EAAQ0G,CAAS,EAExC,GAAI3B,EAAS,MACX,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAMpC,EAAWoC,EAAS,KAAK,CAAC,EAAE,KAAA,EAG5B3D,EAAkB,CACtB,WAAYvC,EACZ,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQ,kBACR,iBAAkB,WAClB,eAAgB,UAChB,OAAAF,EACA,gBAAiB,cACjB,MAAO4E,GAAS,oDAChB,WAAY,SACZ,OAAQ,UACR,mBAAoB,SACpB,cAAe,sBAAA,EAGX7B,EAAkB/B,EAAWC,EAAI,WAAYP,EAAW,cAAc,EACtEyC,EAAiB,MAAMjC,EAAO6B,EAAiBE,CAAe,EAG9DuF,EAAkB,CACtB,YAAahE,EAAS,YACtB,OAAQA,EAAS,OACjB,IAAKA,EAAS,IACd,MAAOA,EAAS,MAChB,aAAcA,EAAS,aACvB,eAAgBA,EAAS,eACzB,YAAaA,EAAS,aAAe,OACrC,MAAOA,EAAS,MAChB,MAAOA,EAAS,MAChB,OAAQA,EAAS,OACjB,SAAUA,EAAS,UAAY,GAC/B,iBAAkB,YAClB,4BAA6B,8BAC7B,eAAgBrB,EAAe,GAC/B,OAAQqB,EAAS,QAAU,CAAA,CAAC,EAG9B,aAAM,KAAK,4BAA4BgE,CAAe,EAGtD,MAAM/F,EAAUmE,EAAS,KAAK,CAAC,EAAE,GAAG,EAE7BzD,EAAe,EACxB,CACF,EAGasF,EAAsB,CAEjC,MAAM,2BACJhI,EACAC,EACAgI,EACe,CAGf,GAFA,QAAQ,IAAI,wCAAyC,CAAE,OAAAjI,EAAQ,UAAAC,EAAW,YAAAgI,EAAa,EAEnFA,IAAgB,YAAa,CAC/B,QAAQ,IAAI,8CAA+CA,CAAW,EACtE,MACF,CAEA,GAAI,CACF,QAAQ,IAAI,+BAAgCjI,CAAM,EAElD,MAAM6D,EAAO,MAAMd,EAAoB,YAAY/C,CAAM,EACzD,GAAI,CAAC6D,EACH,MAAM,IAAI,MAAM,gBAAgB,EASlC,GAPA,QAAQ,IAAI,gBAAiBA,EAAK,QAAS,eAAgBA,EAAK,YAAa,cAAeA,EAAK,UAAU,EAOvGA,EAAK,gBAAkBA,EAAK,eAAe,WAAW,eAAe,GAC7CA,EAAK,eAAe,QAAQ,gBAAiB,EAAE,IAC/C5D,EAAW,CACnC,QAAQ,IAAI,uFAAuF,EAGnG,MAAM8C,EAAoB,0BAA0Bc,EAAK,QAASA,EAAK,eAAgBA,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EAGxI,MAAMd,EAAoB,WAAWc,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAED,GAAI,CACF,MAAM/D,EAAa,mBAAmB,eAAgBE,EAAQ,KAAM6D,EAAK,eAAgB,CACvF,OAAQ,yBACR,SAAU,qBACV,iBAAkBA,EAAK,eACvB,UAAW,YACX,OAAQA,EAAK,eAAiBA,EAAK,cAAgB,MAAA,CACpD,CACH,OAASU,EAAY,CACnB,QAAQ,KAAK,mEAAoEA,CAAU,CAC7F,CAEA,QAAQ,IAAI,oFAAoF,EAChG,MACF,CAIF,QAAQ,IAAI,iEAAiE,EAG7E,GAAI,CACF,MAAOzE,EAAa,mBAA2B,eAAgBE,EAAQ6D,EAAK,WAAYA,EAAK,eAAgB,CAC3G,OAAQ,uBACR,cAAe,YACf,uBAAwBA,EAAK,cAAA,CAC9B,CACH,OAASU,EAAY,CACnB,QAAQ,KAAK,uCAAwCA,CAAU,CACjE,CAEA,MAAMnE,EAAgB,MAAM,KAAK,sBAC/ByD,EACA5D,EACA,8EAAA,EAGF,QAAQ,IAAI,yCAAyC,EAErD,MAAM8C,EAAoB,WAAWc,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgBzD,EAChB,MAAO,GACP,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGD,GAAI,CACF,MAAMN,EAAa,mBAAmB,eAAgBE,EAAQ,KAAMI,EAAe,CACjF,OAAQ,yBACR,gBAAiByD,EAAK,WACtB,eAAgBzD,EAChB,OAAQyD,EAAK,eAAiBA,EAAK,cAAgB,MAAA,CACpD,CACH,OAASU,EAAY,CACnB,QAAQ,KAAK,4CAA6CA,CAAU,CACtE,CAEA,QAAQ,IAAI,iDAAiD,EAE7D,QAAQ,IAAI,uCAAuC,CACrD,OAASxF,EAAO,CACd,cAAQ,MAAM,0CAA2CA,CAAK,EACxDA,CACR,CACF,EAGA,MAAM,sBACJ8E,EACA5D,EACAiI,EACwB,CACxB,QAAQ,IAAI,kDAAmDrE,EAAK,OAAO,EAG3E,IAAI4B,EAAc,QAClB,GAAI,CACF,MAAMD,EAAU,MAAM1E,EAAe,WAAWb,CAAS,EACzDwF,GAAcD,GAAA,YAAAA,EAAS,OAAQ,OACjC,OAASzG,EAAO,CACd,QAAQ,KAAK,uDAAwDA,CAAK,CAC5E,CAIA,GAAI8E,EAAK,gBAAkBA,EAAK,eAAe,WAAW,eAAe,GAC7CA,EAAK,eAAe,QAAQ,gBAAiB,EAAE,IAC/C5D,EACxB,eAAQ,IAAI,sIAAsI,EAGlJ,MAAM8C,EAAoB,0BAA0Bc,EAAK,QAASA,EAAK,eAAgBA,EAAK,eAAiBA,EAAK,cAAgB,MAAM,EACxI,MAAMd,EAAoB,WAAWc,EAAK,QAAS,CACjD,WAAY,KACZ,iBAAkB,YAClB,eAAgB,KAChB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,CACtC,EAGM,KAIX,MAAMiC,EAAyB,YAAY7F,CAAS,GACpD,QAAQ,IAAI,+BAAgC6F,CAAsB,EAGlE,MAAMpD,EAAiBrB,EAAIb,EAAI,eAAgBsF,CAAsB,EAC/DnD,EAAkB,MAAMjB,EAAOgB,CAAc,EAEnD,GAAIC,EAAgB,SAAU,CAE5B,QAAQ,IAAI,gEAAgE,EAC5E,MAAMkC,EAAelC,EAAgB,KAAA,EAC/B4C,EAAkBV,EAAa,UAAY,CAAA,EAC3CC,EAAiB,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGS,EAAiB1B,EAAK,OAAO,CAAC,CAAC,EAGhEH,EAAWnD,EAAWC,EAAI,OAAO,EACjCwE,EAAa9D,EAAMwC,EAAUnB,EAAM,WAAY,KAAMuC,CAAc,CAAC,EAGpEG,GAFgB,MAAM7D,EAAQ4D,CAAU,GAEZ,KAC/B,IAAI3D,GAAOA,EAAI,KAAA,EAAO,eAAiBA,EAAI,KAAA,EAAO,cAAgB,MAAM,EACxE,OAAO,CAAC6D,EAAaC,IAAkBD,EAAM,WAAWC,GAAS,GAAG,EAAG,CAAC,EACxE,QAAQ,CAAC,EAENgD,EAAyB,CAC7B,GAAGtD,EACH,SAAUC,EACV,OAAQG,EACR,MAAOiD,GAAmB,+EAC1B,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,MAAMxC,EAAOhD,EAAgByF,EAAwB,CAAE,MAAO,GAAM,EAEpE,QAAQ,IAAI,uCAAwCrD,EAAe,OAAQ,iBAAkBG,CAAW,CAC1G,KAAO,CAEL,MAAMmD,EAAmBvE,EAAK,eAAiBA,EAAK,cAAgB,OAG9DrB,EAAkB,CACtB,WAAYvC,EACZ,aAAc,KACd,iBAAkBR,EAAiB,IAAI,IAAM,EAC7C,OAAQgG,EACR,iBAAkB,eAClB,eAAgB,UAChB,OAAQ,WAAW2C,CAAuB,EAAE,QAAQ,CAAC,EACrD,gBAAiB,cACjB,MAAOF,GAAmB,+EAC1B,OAAQ,UACR,mBAAoB,SACpB,cAAe,iBACf,SAAU,CAACrE,EAAK,OAAO,EACvB,WAAY,SACZ,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,aAAc,IAAI,KAAA,EAAO,YAAA,CAAY,EAGvC,QAAQ,IAAI,oDAAqDrB,EAAgB,MAAM,EAEvF,MAAMkD,EAAOhD,EAAgBF,EAAiB,CAAE,MAAO,GAAM,CAC/D,CAEA,eAAQ,IAAI,iDAAiD,EACtDsD,CACT,CACF,EAGauC,EAAqB,CAEhC,MAAM,mCACJrI,EACAC,EACAV,EACA4E,EACiB,CACjB,OAAO,MAAMpB,EAAoB,sBAAsB/C,EAAQC,EAAWV,EAAQ4E,CAAK,CACzF,EAGA,MAAM,8BACJnE,EACAsI,EACArI,EACe,CAEf,MAAM8C,EAAoB,sBAAsB/C,EAAQC,CAAS,CACnE,EAGA,MAAM,2BACJsI,EACAD,EACArI,EACA+F,EACe,CAEf,OAAO,MAAMjD,EAAoB,2BAA2B,OAAQ9C,EAAW+F,CAAa,CAC9F,EAGA,MAAM,uBACJhG,EACAC,EACAgI,EACe,CACf,OAAO,MAAMD,EAAoB,2BAA2BhI,EAAQC,EAAWgI,CAAW,CAC5F,CACF"}