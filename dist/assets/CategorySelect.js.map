{"version":3,"file":"CategorySelect.js","sources":["../../src/services/budgetCategoriesService.ts","../../src/components/CategorySelect.tsx"],"sourcesContent":["import { supabase } from './supabase'\nimport { convertTimestamps, handleSupabaseError, ensureAuthenticatedForDatabase } from './databaseService'\nimport { BudgetCategory } from '@/types'\n\n/**\n * Budget Categories Service\n * \n * Provides CRUD operations for account-scoped budget categories.\n * Categories are scoped to accounts and can be archived (not hard deleted)\n * to preserve historical integrity.\n */\nexport const budgetCategoriesService = {\n  /**\n   * Get all budget categories for an account\n   * @param accountId - The account ID to fetch categories for\n   * @param includeArchived - If true, includes archived categories (default: false)\n   * @returns Array of budget categories\n   */\n  async getCategories(accountId: string, includeArchived: boolean = false): Promise<BudgetCategory[]> {\n    await ensureAuthenticatedForDatabase()\n\n    let query = supabase\n      .from('budget_categories')\n      .select('*')\n      .eq('account_id', accountId)\n      .order('name', { ascending: true })\n\n    if (!includeArchived) {\n      query = query.eq('is_archived', false)\n    }\n\n    const { data, error } = await query\n\n    handleSupabaseError(error)\n\n    return (data || []).map(category => {\n      const converted = convertTimestamps(category)\n      return {\n        id: converted.id,\n        accountId: converted.account_id,\n        name: converted.name,\n        slug: converted.slug,\n        isArchived: converted.is_archived || false,\n        metadata: converted.metadata || null,\n        createdAt: converted.created_at,\n        updatedAt: converted.updated_at\n      } as BudgetCategory\n    })\n  },\n\n  /**\n   * Get a single budget category by ID\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to fetch\n   * @returns The budget category or null if not found\n   */\n  async getCategory(accountId: string, categoryId: string): Promise<BudgetCategory | null> {\n    await ensureAuthenticatedForDatabase()\n\n    const { data, error } = await supabase\n      .from('budget_categories')\n      .select('*')\n      .eq('id', categoryId)\n      .eq('account_id', accountId)\n      .single()\n\n    handleSupabaseError(error, { returnNullOnNotFound: true })\n\n    if (!data) {\n      return null\n    }\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      slug: converted.slug,\n      isArchived: converted.is_archived || false,\n      metadata: converted.metadata || null,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at\n    } as BudgetCategory\n  },\n\n  /**\n   * Create a new budget category\n   * @param accountId - The account ID to create the category for\n   * @param name - The display name of the category\n   * @param slug - URL-friendly identifier (unique per account)\n   * @param metadata - Optional metadata JSON object\n   * @returns The created budget category\n   */\n  async createCategory(\n    accountId: string,\n    name: string,\n    // slug is generated internally now\n    metadata?: Record<string, any> | null\n  ): Promise<BudgetCategory> {\n    await ensureAuthenticatedForDatabase()\n\n    // Validate inputs\n    if (!name || name.trim().length === 0) {\n      throw new Error('Category name is required')\n    }\n    // Generate slug internally from name\n    const normalizedSlug = (name || '')\n      .toLowerCase()\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '')\n\n    const { data, error } = await supabase\n      .from('budget_categories')\n      .insert({\n        account_id: accountId,\n        name: name.trim(),\n        slug: normalizedSlug,\n        metadata: metadata || null,\n        is_archived: false\n      })\n      .select()\n      .single()\n\n    handleSupabaseError(error)\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      slug: converted.slug,\n      isArchived: converted.is_archived || false,\n      metadata: converted.metadata || null,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at\n    } as BudgetCategory\n  },\n\n  /**\n   * Update a budget category\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to update\n   * @param updates - Partial updates to apply\n   * @returns The updated budget category\n   */\n  async updateCategory(\n    accountId: string,\n    categoryId: string,\n    updates: {\n      name?: string\n      slug?: string\n      metadata?: Record<string, any> | null\n    }\n  ): Promise<BudgetCategory> {\n    await ensureAuthenticatedForDatabase()\n\n    // Verify category belongs to account\n    const existing = await this.getCategory(accountId, categoryId)\n    if (!existing) {\n      throw new Error('Category not found or does not belong to this account')\n    }\n\n    const updateData: Record<string, any> = {\n      updated_at: new Date().toISOString()\n    }\n\n    if (updates.name !== undefined) {\n      if (!updates.name || updates.name.trim().length === 0) {\n        throw new Error('Category name cannot be empty')\n      }\n      updateData.name = updates.name.trim()\n    }\n\n    if (updates.slug !== undefined) {\n      if (!updates.slug || updates.slug.trim().length === 0) {\n        throw new Error('Category slug cannot be empty')\n      }\n      // Normalize slug\n      updateData.slug = updates.slug\n        .toLowerCase()\n        .trim()\n        .replace(/\\s+/g, '-')\n        .replace(/[^a-z0-9-]/g, '')\n    }\n\n    if (updates.metadata !== undefined) {\n      updateData.metadata = updates.metadata\n    }\n\n    const { data, error } = await supabase\n      .from('budget_categories')\n      .update(updateData)\n      .eq('id', categoryId)\n      .eq('account_id', accountId)\n      .select()\n      .single()\n\n    handleSupabaseError(error)\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      slug: converted.slug,\n      isArchived: converted.is_archived || false,\n      metadata: converted.metadata || null,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at\n    } as BudgetCategory\n  },\n\n  /**\n   * Archive a budget category (soft delete)\n   * Prevents archiving if the category is referenced by transactions.\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to archive\n   * @returns The archived budget category\n   */\n  async archiveCategory(accountId: string, categoryId: string): Promise<BudgetCategory> {\n    await ensureAuthenticatedForDatabase()\n\n    // Verify category belongs to account\n    const existing = await this.getCategory(accountId, categoryId)\n    if (!existing) {\n      throw new Error('Category not found or does not belong to this account')\n    }\n\n    // Archive the category (allow archiving even if referenced to preserve history)\n    const { data, error } = await supabase\n      .from('budget_categories')\n      .update({\n        is_archived: true,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', categoryId)\n      .eq('account_id', accountId)\n      .select()\n      .single()\n\n    handleSupabaseError(error)\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      slug: converted.slug,\n      isArchived: converted.is_archived || false,\n      metadata: converted.metadata || null,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at\n    } as BudgetCategory\n  },\n\n  /**\n   * Unarchive a budget category\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to unarchive\n   * @returns The unarchived budget category\n   */\n  async unarchiveCategory(accountId: string, categoryId: string): Promise<BudgetCategory> {\n    await ensureAuthenticatedForDatabase()\n\n    // Verify category belongs to account\n    const existing = await this.getCategory(accountId, categoryId)\n    if (!existing) {\n      throw new Error('Category not found or does not belong to this account')\n    }\n\n    const { data, error } = await supabase\n      .from('budget_categories')\n      .update({\n        is_archived: false,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', categoryId)\n      .eq('account_id', accountId)\n      .select()\n      .single()\n\n    handleSupabaseError(error)\n\n    const converted = convertTimestamps(data)\n    return {\n      id: converted.id,\n      accountId: converted.account_id,\n      name: converted.name,\n      slug: converted.slug,\n      isArchived: converted.is_archived || false,\n      metadata: converted.metadata || null,\n      createdAt: converted.created_at,\n      updatedAt: converted.updated_at\n    } as BudgetCategory\n  },\n\n  /**\n   * Delete a budget category (hard delete)\n   * This is a convenience method that calls archiveCategory.\n   * Hard deletes are prevented if the category is referenced.\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to delete\n   * @deprecated Use archiveCategory instead. This method archives the category.\n   */\n  async deleteCategory(accountId: string, categoryId: string): Promise<void> {\n    // Delegate to archiveCategory which handles reference checking\n    await this.archiveCategory(accountId, categoryId)\n  },\n\n  /**\n   * Get transaction count for a category\n   * @param accountId - The account ID (for scoping)\n   * @param categoryId - The category ID to check\n   * @returns The number of transactions using this category\n   */\n  async getTransactionCount(accountId: string, categoryId: string): Promise<number> {\n    await ensureAuthenticatedForDatabase()\n\n    const { count, error } = await supabase\n      .from('transactions')\n      .select('*', { count: 'exact', head: true })\n      .eq('account_id', accountId)\n      .eq('category_id', categoryId)\n\n    handleSupabaseError(error)\n\n    return count || 0\n  },\n\n  /**\n   * Get transaction counts for multiple categories\n   * @param accountId - The account ID (for scoping)\n   * @param categoryIds - Array of category IDs to check\n   * @returns Map of categoryId -> transaction count\n   */\n  async getTransactionCounts(accountId: string, categoryIds: string[]): Promise<Map<string, number>> {\n    await ensureAuthenticatedForDatabase()\n\n    const countsMap = new Map<string, number>()\n\n    // Query all transactions for this account with these category IDs\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('category_id')\n      .eq('account_id', accountId)\n      .in('category_id', categoryIds)\n\n    handleSupabaseError(error)\n\n    // Initialize all category IDs with 0\n    categoryIds.forEach(id => countsMap.set(id, 0))\n\n    // Count transactions per category\n    if (data) {\n      data.forEach(tx => {\n        if (tx.category_id) {\n          const currentCount = countsMap.get(tx.category_id) || 0\n          countsMap.set(tx.category_id, currentCount + 1)\n        }\n      })\n    }\n\n    return countsMap\n  },\n\n  /**\n   * Bulk archive multiple categories\n   * Only archives categories that are not referenced by transactions.\n   * @param accountId - The account ID (for scoping)\n   * @param categoryIds - Array of category IDs to archive\n   * @returns Object with successful and failed archive operations\n   */\n  async bulkArchiveCategories(\n    accountId: string,\n    categoryIds: string[]\n  ): Promise<{ successful: string[]; failed: Array<{ categoryId: string; reason: string }> }> {\n    await ensureAuthenticatedForDatabase()\n\n    const successful: string[] = []\n    const failed: Array<{ categoryId: string; reason: string }> = []\n\n    // Get transaction counts for all categories\n    // Try to archive each category (archive always allowed)\n    for (const categoryId of categoryIds) {\n      try {\n        await this.archiveCategory(accountId, categoryId)\n        successful.push(categoryId)\n      } catch (error) {\n        failed.push({\n          categoryId,\n          reason: error instanceof Error ? error.message : 'Failed to archive category'\n        })\n      }\n    }\n\n    return { successful, failed }\n  }\n}\n\n","import { useState, useEffect, useCallback } from 'react'\nimport { budgetCategoriesService } from '@/services/budgetCategoriesService'\nimport { BudgetCategory } from '@/types'\nimport { useAccount } from '@/contexts/AccountContext'\n\ninterface CategorySelectProps {\n  value?: string\n  onChange?: (categoryId: string) => void\n  label?: string\n  error?: string\n  helperText?: string\n  disabled?: boolean\n  includeArchived?: boolean\n  id?: string\n  className?: string\n  required?: boolean\n  asDropdown?: boolean\n}\n\n/**\n * CategorySelect Component\n * \n * A reusable select component for choosing budget categories.\n * Automatically loads categories for the current account and hides archived categories by default.\n * \n * @returns { id: string, name: string } format via onChange callback\n */\nexport default function CategorySelect({\n  value,\n  onChange,\n  label = 'Budget Category',\n  error,\n  helperText,\n  disabled = false,\n  includeArchived = false,\n  id,\n  className,\n  required = false,\n  asDropdown = false\n}: CategorySelectProps) {\n  const { currentAccountId, loading: accountLoading } = useAccount()\n  const [categories, setCategories] = useState<BudgetCategory[]>([])\n  const [isLoading, setIsLoading] = useState(true)\n  const [loadError, setLoadError] = useState<string | null>(null)\n\n  const loadCategories = useCallback(async () => {\n    if (!currentAccountId) return\n\n    try {\n      setIsLoading(true)\n      setLoadError(null)\n      const loadedCategories = await budgetCategoriesService.getCategories(\n        currentAccountId,\n        includeArchived\n      )\n      setCategories(loadedCategories)\n    } catch (err) {\n      console.error('Error loading budget categories:', err)\n      setLoadError('Failed to load categories')\n    } finally {\n      setIsLoading(false)\n    }\n  }, [currentAccountId, includeArchived])\n\n  useEffect(() => {\n    // Wait for account to finish loading\n    if (accountLoading) {\n      return\n    }\n\n    if (currentAccountId) {\n      loadCategories()\n    } else {\n      setIsLoading(false)\n    }\n  }, [currentAccountId, accountLoading, loadCategories])\n\n  const handleRadioChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const categoryId = e.target.value\n    if (onChange) {\n      onChange(categoryId)\n    }\n  }\n\n  const handleSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const categoryId = e.target.value\n    if (onChange) {\n      onChange(categoryId)\n    }\n  }\n\n  // Show error from loading or from props\n  const displayError = error || loadError\n\n  return (\n    <div className=\"space-y-1\">\n      {label && (\n        <label htmlFor={id} className=\"block text-sm font-medium text-gray-700\" style={{ color: '#374151' }}>\n          {label}\n        </label>\n      )}\n\n      <div className={className}>\n        {isLoading ? (\n          <p className=\"text-sm text-gray-500\">Loading categories...</p>\n        ) : categories.length === 0 ? (\n          <p className=\"text-sm text-gray-500\">No categories available</p>\n        ) : (\n          <>\n            {asDropdown ? (\n              <div>\n                <select\n                  id={id}\n                  value={value || ''}\n                  onChange={handleSelectChange}\n                  disabled={disabled}\n                  className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm\"\n                >\n                  {!required && <option value=\"\">None</option>}\n                  {categories.map(cat => (\n                    <option key={cat.id} value={cat.id}>{cat.name}</option>\n                  ))}\n                </select>\n              </div>\n            ) : (\n              <fieldset id={id}>\n                <div className=\"grid grid-cols-2 md:grid-cols-3 gap-3 mb-3\">\n                  {required ? null : (\n                    <div className=\"flex items-center\">\n                      <input\n                        id={id ? `${id}-none` : 'category-none'}\n                        name={id || 'category'}\n                        type=\"radio\"\n                        value=\"\"\n                        checked={!value}\n                        onChange={handleRadioChange}\n                        disabled={disabled}\n                        className=\"h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300\"\n                      />\n                      <label htmlFor={id ? `${id}-none` : 'category-none'} className=\"ml-2 block text-sm text-gray-900\">\n                        None\n                      </label>\n                    </div>\n                  )}\n\n                  {categories.map((category) => (\n                    <div key={category.id} className=\"flex items-center\">\n                      <input\n                        id={id ? `${id}-${category.id}` : `category-${category.id}`}\n                        name={id || 'category'}\n                        type=\"radio\"\n                        value={category.id}\n                        checked={value === category.id}\n                        onChange={handleRadioChange}\n                        disabled={disabled}\n                        className=\"h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300\"\n                      />\n                      <label htmlFor={id ? `${id}-${category.id}` : `category-${category.id}`} className=\"ml-2 block text-sm text-gray-900\">\n                        {category.name}\n                      </label>\n                    </div>\n                  ))}\n                </div>\n              </fieldset>\n            )}\n          </>\n        )}\n      </div>\n\n      {displayError && (\n        <p className=\"text-sm text-red-600\" style={{ color: '#dc2626' }}>{displayError}</p>\n      )}\n\n      {helperText && !displayError && (\n        <p className=\"text-sm text-gray-500\" style={{ color: '#6b7280' }}>{helperText}</p>\n      )}\n    </div>\n  )\n}\n\n/**\n * Hook to get categories as { id, name } array\n * Useful when you need the category list but not a select component\n */\nexport function useCategories(includeArchived: boolean = false): {\n  categories: Array<{ id: string; name: string }>\n  isLoading: boolean\n  error: string | null\n} {\n  const { currentAccountId, loading: accountLoading } = useAccount()\n  const [categories, setCategories] = useState<Array<{ id: string; name: string }>>([])\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    if (accountLoading || !currentAccountId) {\n      if (!accountLoading && !currentAccountId) {\n        setIsLoading(false)\n        setError('No account found')\n      }\n      return\n    }\n\n    const loadCategories = async () => {\n      try {\n        setIsLoading(true)\n        setError(null)\n        const loadedCategories = await budgetCategoriesService.getCategories(\n          currentAccountId,\n          includeArchived\n        )\n        setCategories(\n          loadedCategories.map(cat => ({\n            id: cat.id,\n            name: cat.name\n          }))\n        )\n      } catch (err) {\n        console.error('Error loading budget categories:', err)\n        setError('Failed to load categories')\n      } finally {\n        setIsLoading(false)\n      }\n    }\n\n    loadCategories()\n  }, [currentAccountId, accountLoading, includeArchived])\n\n  return { categories, isLoading, error }\n}\n\n"],"names":["budgetCategoriesService","accountId","includeArchived","ensureAuthenticatedForDatabase","query","supabase","data","error","handleSupabaseError","category","converted","convertTimestamps","categoryId","name","metadata","normalizedSlug","updates","updateData","count","categoryIds","countsMap","id","tx","currentCount","successful","failed","CategorySelect","value","onChange","label","helperText","disabled","className","required","asDropdown","currentAccountId","accountLoading","useAccount","categories","setCategories","useState","isLoading","setIsLoading","loadError","setLoadError","loadCategories","useCallback","loadedCategories","err","useEffect","handleRadioChange","e","handleSelectChange","displayError","jsxs","jsx","Fragment","cat","useCategories","setError"],"mappings":"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"}