import{s as _,v as f,w as C,C as N,f as U,x as D}from"./index.js";import{a as L}from"./taxPresetsService.js";const V=e=>{if(!e)return null;if(e instanceof Date)return e;if(typeof e=="object"&&e){if("toDate"in e&&typeof e.toDate=="function")try{return e.toDate()}catch(t){return console.warn("Failed to convert timestamp to Date:",t),null}if("seconds"in e&&"nanoseconds"in e)try{return new Date(e.seconds*1e3+e.nanoseconds/1e6)}catch(t){return console.warn("Failed to convert timestamp to Date:",t),null}}if(typeof e=="string")try{if(/^\d{4}-\d{2}-\d{2}$/.test(e)){const[n,o,a]=e.split("-").map(Number),s=new Date(n,o-1,a);return isNaN(s.getTime())?null:s}const t=new Date(e);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to parse date string:",e,t),null}if(typeof e=="number")try{const t=new Date(e);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to convert number to Date:",e,t),null}return null},G=(e,t="Unknown",n)=>{const o=V(e);if(!o)return t;try{const s={...{year:"numeric",month:"short",day:"numeric"},...n};return o.toLocaleDateString("en-US",s)}catch(a){return console.warn("Failed to format date:",e,a),t}},K=(e,t="$0.00")=>{const n=typeof e=="string"?parseFloat(e):e;return isNaN(n)?t:n.toLocaleString("en-US",{style:"currency",currency:"USD",minimumFractionDigits:2,maximumFractionDigits:2})},q=e=>{if(!e)return"";if(typeof e=="string"&&/^\d{4}-\d{2}-\d{2}$/.test(e))return e;const t=V(e);if(!t)return"";const n=t.getFullYear(),o=String(t.getMonth()+1).padStart(2,"0"),a=String(t.getDate()).padStart(2,"0");return`${n}-${o}-${a}`},w={async appendItemLineageEdge(e,t,n,o,a){if(await f(),n===o)return console.log("â­ï¸ Skipping lineage edge: from === to",{itemId:t,fromTransactionId:n,toTransactionId:o}),null;const s=await C(),i=(s==null?void 0:s.id)||null,r=new Date(Date.now()-5e3).toISOString(),{data:c}=await _.from("item_lineage_edges").select("id, created_at").eq("account_id",e).eq("item_id",t).eq("from_transaction_id",n??null).eq("to_transaction_id",o??null).gte("created_at",r).order("created_at",{ascending:!1}).limit(1);if(c&&c.length>0)return console.log("â­ï¸ Skipping duplicate lineage edge (recent match found)",{itemId:t,fromTransactionId:n,toTransactionId:o,existingEdgeId:c[0].id}),await this.getLineageEdgeById(c[0].id);const{data:d,error:l}=await _.from("item_lineage_edges").insert({account_id:e,item_id:t,from_transaction_id:n??null,to_transaction_id:o??null,created_by:i,note:a??null}).select().single();if(l){if((l==null?void 0:l.code)==="PGRST205"||(l==null?void 0:l.status)===404||typeof(l==null?void 0:l.message)=="string"&&l.message.includes("Could not find the table"))return console.warn("âš ï¸ Lineage table not found / PostgREST schema cache issue. Lineage writes are non-fatal while the migration is pending."),console.warn("Read dev_docs/troubleshooting/transaction-lineage-troubleshooting.md for diagnostic steps and remediation."),console.debug("Lineage append error details:",l),null;throw console.error("âŒ Failed to append lineage edge:",l),l}return console.log("âœ… Lineage edge appended:",{itemId:t,fromTransactionId:n,toTransactionId:o,edgeId:d.id}),this._convertEdgeFromDb(d)},async updateItemLineagePointers(e,t,n,o){await f();const a={latest_transaction_id:n??null};if(o!==void 0){const{data:i}=await _.from("items").select("origin_transaction_id").eq("account_id",e).eq("item_id",t).single();!(i!=null&&i.origin_transaction_id)&&o&&(a.origin_transaction_id=o)}const{error:s}=await _.from("items").update(a).eq("account_id",e).eq("item_id",t);if(s)throw console.error("âŒ Failed to update item lineage pointers:",s),s;console.log("âœ… Updated item lineage pointers:",{itemId:t,latestTransactionId:n,originTransactionId:a.origin_transaction_id})},async getItemLineageHistory(e,t){await f();const{data:n,error:o}=await _.from("item_lineage_edges").select("*").eq("account_id",t).eq("item_id",e).order("created_at",{ascending:!0});if(o)throw console.error("âŒ Failed to fetch item lineage history:",o),o;return(n||[]).map(a=>this._convertEdgeFromDb(a))},async getEdgesFromTransaction(e,t){await f();const{data:n,error:o}=await _.from("item_lineage_edges").select("*").eq("account_id",t).eq("from_transaction_id",e).order("created_at",{ascending:!0});if(o)throw console.error("âŒ Failed to fetch edges from transaction:",o),o;return(n||[]).map(a=>this._convertEdgeFromDb(a))},async getLineageEdgeById(e){await f();const{data:t,error:n}=await _.from("item_lineage_edges").select("*").eq("id",e).single();if(n){if(n.code==="PGRST116")return null;throw console.error("âŒ Failed to fetch lineage edge:",n),n}return t?this._convertEdgeFromDb(t):null},subscribeToItemLineageForItem(e,t,n){const o=[`account_id=eq.${e}`];t&&o.push(`item_id=eq.${t}`);const a=o.join(","),s=`item_lineage:${e}${t?`:${t}`:""}`,i=_.channel(s).on("postgres_changes",{event:"INSERT",schema:"public",table:"item_lineage_edges",filter:a},r=>{try{const c=this._convertEdgeFromDb(r.new);n(c)}catch(c){console.debug("lineageService.subscribeToItemLineageForItem - callback error",c)}}).subscribe((r,c)=>{r==="SUBSCRIBED"&&console.log("Subscribed to item_lineage_edges channel",s),c&&console.error("Error subscribing to item_lineage_edges channel",c)});return()=>{try{i.unsubscribe()}catch(r){console.debug("Failed to unsubscribe from lineage channel",r)}}},subscribeToEdgesFromTransaction(e,t,n){const o=`account_id=eq.${e},from_transaction_id=eq.${t}`,a=`item_lineage:from_tx:${e}:${t}`,s=_.channel(a).on("postgres_changes",{event:"INSERT",schema:"public",table:"item_lineage_edges",filter:o},i=>{try{const r=this._convertEdgeFromDb(i.new);n(r)}catch(r){console.debug("lineageService.subscribeToEdgesFromTransaction - callback error",r)}}).subscribe((i,r)=>{i==="SUBSCRIBED"&&console.log("Subscribed to item_lineage_edges from_transaction channel",a),r&&console.error("Error subscribing to item_lineage_edges from_transaction channel",r)});return()=>{try{s.unsubscribe()}catch(i){console.debug("Failed to unsubscribe from lineage from_tx channel",i)}}},_convertEdgeFromDb(e){return{id:e.id,accountId:e.account_id,itemId:e.item_id,fromTransactionId:e.from_transaction_id??null,toTransactionId:e.to_transaction_id??null,createdAt:e.created_at,createdBy:e.created_by??null,note:e.note??null}}},S={async logAllocationEvent(e,t,n,o,a,s){try{let i=null,r={};typeof a=="string"?(i=a,r=s||{}):(i=null,r=a||{});const{error:c}=await _.from("audit_logs").insert({account_id:e,event_type:t,item_id:n,project_id:o,transaction_id:i,details:r,timestamp:new Date().toISOString(),created_at:new Date().toISOString()});c?console.warn("âš ï¸ Failed to log audit event (non-critical):",c):console.log(`ðŸ“‹ Audit logged: ${t} for item ${n}`)}catch(i){console.warn("âš ï¸ Failed to log audit event (non-critical):",i)}},async logTransactionStateChange(e,t,n,o,a){try{const{error:s}=await _.from("transaction_audit_logs").insert({account_id:e,transaction_id:t,change_type:n,old_state:o||null,new_state:a||null,timestamp:new Date().toISOString(),created_at:new Date().toISOString()});s?console.warn("âš ï¸ Failed to log transaction audit (non-critical):",s):console.log(`ðŸ“‹ Transaction audit logged: ${n} for ${t}`)}catch(s){console.warn("âš ï¸ Failed to log transaction audit (non-critical):",s)}}},A={async getProjects(e){await f();const{data:t,error:n}=await _.from("projects").select("*").eq("account_id",e).order("updated_at",{ascending:!1});if(n)throw n;return(t||[]).map(o=>{const a=D(o);return{id:a.id,accountId:a.account_id,name:a.name,description:a.description||"",clientName:a.client_name||"",budget:a.budget?parseFloat(a.budget):void 0,designFee:a.design_fee?parseFloat(a.design_fee):void 0,budgetCategories:a.budget_categories||void 0,createdAt:a.created_at,updatedAt:a.updated_at,createdBy:a.created_by,settings:a.settings||void 0,metadata:a.metadata||void 0,itemCount:a.item_count||0,transactionCount:a.transaction_count||0,totalValue:a.total_value?parseFloat(a.total_value):0}})},async getProject(e,t){await f();const{data:n,error:o}=await _.from("projects").select("*").eq("id",t).eq("account_id",e).single();if(o){if(o.code==="PGRST116")return null;throw o}if(!n)return null;const a=D(n);return{id:a.id,accountId:a.account_id,name:a.name,description:a.description||"",clientName:a.client_name||"",budget:a.budget?parseFloat(a.budget):void 0,designFee:a.design_fee?parseFloat(a.design_fee):void 0,budgetCategories:a.budget_categories||void 0,createdAt:a.created_at,updatedAt:a.updated_at,createdBy:a.created_by,settings:a.settings||void 0,metadata:a.metadata||void 0,itemCount:a.item_count||0,transactionCount:a.transaction_count||0,totalValue:a.total_value?parseFloat(a.total_value):0}},async createProject(e,t){await f();const{data:n,error:o}=await _.from("projects").insert({account_id:e,name:t.name,description:t.description||null,client_name:t.clientName||null,budget:t.budget||null,design_fee:t.designFee||null,budget_categories:t.budgetCategories||{},settings:t.settings||{},metadata:t.metadata||{},created_by:t.createdBy,item_count:0,transaction_count:0,total_value:0,created_at:new Date().toISOString(),updated_at:new Date().toISOString()}).select("id").single();if(o)throw o;return n.id},async updateProject(e,t,n){await f();const o={updated_at:new Date().toISOString()};n.name!==void 0&&(o.name=n.name),n.description!==void 0&&(o.description=n.description),n.clientName!==void 0&&(o.client_name=n.clientName),n.budget!==void 0&&(o.budget=n.budget),n.designFee!==void 0&&(o.design_fee=n.designFee),n.budgetCategories!==void 0&&(o.budget_categories=n.budgetCategories),n.settings!==void 0&&(o.settings=n.settings),n.metadata!==void 0&&(o.metadata=n.metadata);const{error:a}=await _.from("projects").update(o).eq("id",t).eq("account_id",e);if(a)throw a},async deleteProject(e,t){await f();const{error:n}=await _.from("projects").delete().eq("id",t).eq("account_id",e);if(n)throw n},subscribeToProjects(e,t,n){let o=[...n||[]];const a=_.channel(`projects:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"projects",filter:`account_id=eq.${e}`},s=>{console.log("Projects change received!",s);const{eventType:i,new:r,old:c}=s;if(i==="INSERT")o=[A._convertProjectFromDb(r),...o];else if(i==="UPDATE"){const d=A._convertProjectFromDb(r);o=o.map(l=>l.id===d.id?d:l)}else if(i==="DELETE"){const d=c.id;o=o.filter(l=>l.id!==d)}t([...o])}).subscribe((s,i)=>{s==="SUBSCRIBED"&&console.log("Subscribed to projects channel"),i&&console.error("Error subscribing to projects channel:",i)});return()=>{a.unsubscribe()}},_convertProjectFromDb(e){const t=D(e);return{id:t.id,accountId:t.account_id,name:t.name,description:t.description||"",clientName:t.client_name||"",budget:t.budget?parseFloat(t.budget):void 0,designFee:t.design_fee?parseFloat(t.design_fee):void 0,budgetCategories:t.budget_categories||void 0,createdAt:t.created_at,updatedAt:t.updated_at,createdBy:t.created_by,settings:t.settings||void 0,metadata:t.metadata||void 0,itemCount:t.item_count||0,transactionCount:t.transaction_count||0,totalValue:t.total_value?parseFloat(t.total_value):0}}};function P(e){const t=D(e);return{transactionId:t.transaction_id,projectId:t.project_id||void 0,projectName:t.project_name||void 0,transactionDate:t.transaction_date,source:t.source||"",transactionType:t.transaction_type||"",paymentMethod:t.payment_method||"",amount:t.amount||"0.00",budgetCategory:t.budget_category||void 0,notes:t.notes||void 0,transactionImages:Array.isArray(t.transaction_images)?t.transaction_images:[],receiptImages:Array.isArray(t.receipt_images)?t.receipt_images:[],otherImages:Array.isArray(t.other_images)?t.other_images:[],receiptEmailed:t.receipt_emailed||!1,createdAt:t.created_at,createdBy:t.created_by||"",status:t.status||"completed",reimbursementType:t.reimbursement_type||void 0,triggerEvent:t.trigger_event||void 0,itemIds:Array.isArray(t.item_ids)?t.item_ids:[],taxRatePreset:t.tax_rate_preset||void 0,taxRatePct:t.tax_rate_pct?parseFloat(t.tax_rate_pct):void 0,subtotal:t.subtotal||void 0,needsReview:t.needs_review===!0,sumItemPurchasePrices:t.sum_item_purchase_prices!==void 0?String(t.sum_item_purchase_prices):"0.00"}}async function T(e,t,n){if([...new Set(t.map(s=>s.projectId).filter(s=>!!s))].length===0)return t;const a=new Map;try{(await A.getProjects(e)).forEach(i=>{a.set(i.id,i.name)})}catch(s){console.warn("Failed to fetch projects for transaction enrichment:",s)}return t.map(s=>{if(s.projectId&&!s.projectName){const i=a.get(s.projectId);if(i)return{...s,projectName:i}}return s})}function B(e){const t={};return e.transactionId!==void 0&&(t.transaction_id=e.transactionId),e.projectId!==void 0&&(t.project_id=e.projectId??null),e.transactionDate!==void 0&&(t.transaction_date=e.transactionDate),e.source!==void 0&&(t.source=e.source),e.transactionType!==void 0&&(t.transaction_type=e.transactionType),e.paymentMethod!==void 0&&(t.payment_method=e.paymentMethod),e.amount!==void 0&&(t.amount=e.amount),e.budgetCategory!==void 0&&(t.budget_category=e.budgetCategory),e.notes!==void 0&&(t.notes=e.notes),e.transactionImages!==void 0&&(t.transaction_images=e.transactionImages),e.receiptImages!==void 0&&(t.receipt_images=e.receiptImages),e.otherImages!==void 0&&(t.other_images=e.otherImages),e.receiptEmailed!==void 0&&(t.receipt_emailed=e.receiptEmailed),e.createdAt!==void 0&&(t.created_at=e.createdAt),e.createdBy!==void 0&&(t.created_by=e.createdBy),e.status!==void 0&&(t.status=e.status),e.reimbursementType!==void 0&&(t.reimbursement_type=e.reimbursementType),e.triggerEvent!==void 0&&(t.trigger_event=e.triggerEvent),e.itemIds!==void 0&&(t.item_ids=e.itemIds),e.taxRatePreset!==void 0&&(t.tax_rate_preset=e.taxRatePreset),e.taxRatePct!==void 0&&(t.tax_rate_pct=e.taxRatePct),e.subtotal!==void 0&&(t.subtotal=e.subtotal),e.needsReview!==void 0&&(t.needs_review=e.needsReview),e.sumItemPurchasePrices!==void 0&&(t.sum_item_purchase_prices=e.sumItemPurchasePrices),t}async function O(e,t,n){await f();const{data:o,error:a}=await _.from("transactions").select("sum_item_purchase_prices").eq("account_id",e).eq("transaction_id",t).single();if(a)throw a;const s=o&&o.sum_item_purchase_prices||"0",i=parseFloat(String(s)||"0"),r=parseFloat(String(n)||"0"),d=(i+r).toFixed(2),{error:l}=await _.from("transactions").update({sum_item_purchase_prices:d}).eq("account_id",e).eq("transaction_id",t);if(l)throw l;return d}const j={async adjustSumItemPurchasePrices(e,t,n){return await O(e,t,n)},async notifyTransactionChanged(e,t,n){if(n&&n.deltaSum!==void 0)try{await O(e,t,n.deltaSum)}catch(a){console.warn("notifyTransactionChanged - failed to adjust sum_item_purchase_prices:",a)}const o=n&&n.flushImmediately?0:void 0;try{o===0?this._enqueueRecomputeNeedsReview(e,null,t,0).catch(a=>{console.warn("Failed to recompute needs_review in notifyTransactionChanged (immediate):",a)}):this._enqueueRecomputeNeedsReview(e,null,t).catch(a=>{console.warn("Failed to recompute needs_review in notifyTransactionChanged:",a)})}catch(a){console.warn("notifyTransactionChanged - enqueue failed:",a)}},async getTransactions(e,t){await f();const{data:n,error:o}=await _.from("transactions").select("*").eq("account_id",e).eq("project_id",t).order("created_at",{ascending:!1});if(o)throw o;const a=(n||[]).map(s=>P(s));return await T(e,a)},async getTransactionsForProjects(e,t,n){if(await f(),t.length===0)return[];const{data:o,error:a}=await _.from("transactions").select("*").eq("account_id",e).in("project_id",t).order("created_at",{ascending:!1});if(a)throw a;const s=(o||[]).map(i=>P(i));return await T(e,s)},async getTransaction(e,t,n){await f();const{data:o,error:a}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",n).single();if(a){if(a.code==="PGRST116")return null;throw a}if(!o)return null;const s=P(o);return(await T(e,[s]))[0]||null},async getTransactionById(e,t){await f();const{data:n,error:o}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",t).single();if(o||!n)return{transaction:null,projectId:null};const a=D(n),s=P(n);return{transaction:(await T(e,[s]))[0]||s,projectId:a.project_id||null}},async getTransactionCompleteness(e,t,n){await f();const[o,a]=await Promise.all([this.getTransaction(e,t,n),I.getItemsForTransaction(e,t,n)]);if(!o)throw new Error("Transaction not found");let s=a.slice();try{const v=await w.getEdgesFromTransaction(n,e),x=Array.from(new Set(v.map(F=>F.itemId))).filter(F=>!s.some(R=>R.itemId===F));if(x.length>0){const F=x.map($=>I.getItemById(e,$)),k=(await Promise.all(F)).filter($=>$!==null);s=s.concat(k)}}catch(v){console.debug("getTransactionCompleteness - failed to fetch lineage edges:",v)}const i=s.reduce((v,E)=>{const x=parseFloat(E.purchasePrice||"0");return v+(isNaN(x)?0:x)},0),r=s.length,c=s.filter(v=>{const E=v.purchasePrice;return!E||E.trim()===""||parseFloat(E)===0}).length,d=parseFloat(o.amount||"0");let l=0,u,m,p=!1;if(o.subtotal)l=parseFloat(o.subtotal);else if(o.taxRatePct!==void 0&&o.taxRatePct!==null){const v=o.taxRatePct/100;l=d/(1+v),u=d-l,l=Math.round(l*100)/100,u=Math.round(u*100)/100}else l=d,p=!0;const h=l>0?i/l:(r>0,0),g=i-l,y=l>0?g/l*100:r>0?-100:0,b=this._calculateCompletenessStatus(h,y);return{itemsNetTotal:Math.round(i*100)/100,itemsCount:r,itemsMissingPriceCount:c,transactionSubtotal:Math.round(l*100)/100,completenessRatio:h,completenessStatus:b,missingTaxData:p,inferredTax:u,taxAmount:m,varianceDollars:Math.round(g*100)/100,variancePercent:Math.round(y*100)/100}},_calculateCompletenessStatus(e,t){return e>1.2?"over":Math.abs(t)>20?"incomplete":Math.abs(t)>1?"near":"complete"},async _recomputeNeedsReview(e,t,n){try{const a=(await this.getTransactionCompleteness(e,t||"",n)).completenessStatus!=="complete";await f();const s={needs_review:a,updated_at:new Date().toISOString()},{error:i}=await _.from("transactions").update(s).eq("account_id",e).eq("transaction_id",n);i?console.warn("Failed to persist needs_review for transaction",n,i):console.log(`Recomputed needs_review=${a} for transaction ${n}`)}catch(o){console.warn("Failed to recompute needs_review for transaction",n,o)}},_needsReviewTimers:{},_ongoingNeedsReviewPromises:{},_enqueueCounts:{},_needsReviewDirty:{},_batchCounters:{},beginNeedsReviewBatch(e,t){const n=`${e}:${t}`;this._batchCounters[n]=(this._batchCounters[n]||0)+1},_isBatchActive(e,t){const n=`${e}:${t}`;return(this._batchCounters[n]||0)>0},async flushNeedsReviewBatch(e,t,n){const o=`${e}:${t}`,a=(this._batchCounters[o]||0)-1;if(a<=0){delete this._batchCounters[o];try{let s=null;try{await f();const{data:i}=await _.from("transactions").select("project_id").eq("account_id",e).eq("transaction_id",t).single();s=(i==null?void 0:i.project_id)??null}catch{}n!=null&&n.flushImmediately?this._enqueueRecomputeNeedsReview(e,s,t,0).catch(i=>{console.warn("Failed to recompute needs_review in flushNeedsReviewBatch:",i)}):this._enqueueRecomputeNeedsReview(e,s,t).catch(i=>{console.warn("Failed to recompute needs_review in flushNeedsReviewBatch:",i)})}catch(s){console.warn("Failed during flushNeedsReviewBatch:",s)}}else this._batchCounters[o]=a},_enqueueRecomputeNeedsReview(e,t,n,o=1e3){const a=`${e}:${n}`;if(this._ongoingNeedsReviewPromises[a]){try{this._needsReviewDirty[a]=!0}catch{}return this._ongoingNeedsReviewPromises[a]}if(this._needsReviewTimers[a]){const c=new Promise((d,l)=>{const u=setInterval(()=>{!this._needsReviewTimers[a]&&!this._ongoingNeedsReviewPromises[a]&&(clearInterval(u),d())},50)});return this._ongoingNeedsReviewPromises[a]=c,c}try{this._enqueueCounts[a]=(this._enqueueCounts[a]||0)+1;const c=this._enqueueCounts[a],l=(new Error().stack||"").split(`
`).slice(2,6).join(" | ");console.debug(`[needs_review] enqueue requested for ${n} count=${c} ts=${new Date().toISOString()} caller=${l}`)}catch{}let s=null,i=null;const r=new Promise((c,d)=>{s=c,i=d});return this._ongoingNeedsReviewPromises[a]=r,this._needsReviewTimers[a]=setTimeout(async()=>{try{await this._recomputeNeedsReview(e,t,n),s&&s()}catch(c){i&&i(c)}finally{this._needsReviewTimers[a]&&clearTimeout(this._needsReviewTimers[a]),delete this._needsReviewTimers[a],delete this._ongoingNeedsReviewPromises[a];try{delete this._enqueueCounts[a]}catch{}try{this._needsReviewDirty[a]&&(delete this._needsReviewDirty[a],setTimeout(()=>{try{this._enqueueRecomputeNeedsReview(e,t,n,25).catch(c=>{console.warn("Failed trailing recompute needs_review:",c)})}catch(c){console.warn("Failed scheduling trailing recompute:",c)}},25))}catch{}}},o),r},async getSuggestedItemsForTransaction(e,t,n=5){await f();const{data:o,error:a}=await _.from("items").select("*").eq("account_id",e).eq("source",t).is("transaction_id",null).order("date_created",{ascending:!1}).limit(n);if(a)throw a;return(o||[]).map(s=>I._convertItemFromDb(s))},async createTransaction(e,t,n,o){try{await f();const a=await C();if(!(n.createdBy||(a==null?void 0:a.id)||null))throw new Error("User must be authenticated to create transactions");const i=new Date,r=crypto.randomUUID(),c=B({...n,transactionId:r,createdAt:i.toISOString()});if(c.account_id=e,c.created_at=i.toISOString(),c.updated_at=i.toISOString(),c.status||(c.status="completed"),console.log("Creating transaction:",c),console.log("Transaction items:",o),c.tax_rate_preset)if(c.tax_rate_preset==="Other"){const l=parseFloat(c.amount||"0"),u=parseFloat(c.subtotal||"0");if(isNaN(u)||u<=0)throw new Error("Subtotal must be greater than 0 when Tax Rate Preset is Other.");if(isNaN(l)||l<u)throw new Error("Subtotal cannot exceed the total amount.");const m=(l-u)/u*100;c.tax_rate_pct=Math.round(m*1e4)/1e4}else{const l=await L(e,c.tax_rate_preset);if(!l)throw new Error(`Tax preset with ID '${c.tax_rate_preset}' not found.`);c.tax_rate_pct=l.rate,c.subtotal=null}const{error:d}=await _.from("transactions").insert(c);if(d)throw d;if(console.log("Transaction created successfully:",r),o&&o.length>0){console.log("Creating items for transaction:",r);const l=o.map(m=>({...m})),u=await I.createTransactionItems(e,t||"",r,n.transactionDate,n.source,l,c.tax_rate_pct);console.log("Created items:",u)}try{this._enqueueRecomputeNeedsReview(e,t,r).catch(l=>{console.warn("Failed to set needs_review after transaction creation:",l)})}catch(l){console.warn("Failed to set needs_review after transaction creation:",l)}return r}catch(a){throw console.error("Error creating transaction:",a),a}},async updateTransaction(e,t,n,o){await f();const a={...o};if(a.status==="completed"&&a.reimbursementType!==void 0&&(a.reimbursementType=null),a.reimbursementType===""&&(a.reimbursementType=null),a.reimbursementType&&a.status==="completed"&&(a.status="pending"),a.taxRatePreset!==void 0)if(a.taxRatePreset==="Other"){const{data:r}=await _.from("transactions").select("amount, subtotal").eq("account_id",e).eq("transaction_id",n).single(),c=r,d=a.amount!==void 0?parseFloat(a.amount):parseFloat((c==null?void 0:c.amount)||"0"),l=a.subtotal!==void 0?parseFloat(a.subtotal):parseFloat((c==null?void 0:c.subtotal)||"0");if(!isNaN(d)&&!isNaN(l)&&l>0&&d>=l){const u=(d-l)/l*100;a.taxRatePct=Math.round(u*1e4)/1e4}}else try{const r=await L(e,a.taxRatePreset);r?(a.taxRatePct=r.rate,a.subtotal=void 0):console.warn(`Tax preset with ID '${a.taxRatePreset}' not found during update`)}catch(r){console.warn("Tax preset lookup failed during update:",r)}const s=B(a);s.updated_at=new Date().toISOString();const{error:i}=await _.from("transactions").update(s).eq("account_id",e).eq("transaction_id",n);if(i)throw i;if(a.taxRatePct!==void 0)try{const r=await I.getItemsForTransaction(e,t,n);if(r&&r.length>0)for(const c of r)await I.updateItem(e,c.itemId,{taxRatePct:a.taxRatePct})}catch(r){console.warn("Failed to propagate tax_rate_pct to items:",r)}a.needsReview===void 0&&this._enqueueRecomputeNeedsReview(e,t,n).catch(r=>{console.warn("Failed to recompute needs_review after transaction update:",r)})},async deleteTransaction(e,t,n){await f();const{error:o}=await _.from("transactions").delete().eq("account_id",e).eq("transaction_id",n);if(o)throw o},subscribeToTransactions(e,t,n,o){let a=[...o||[]];const s=_.channel(`transactions:${e}:${t}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e}`},async i=>{console.log("Transactions change received (account scope)!",i);const{eventType:r,new:c,old:d}=i,l=(c==null?void 0:c.project_id)??null,u=(d==null?void 0:d.project_id)??null,m=h=>h===t;if(r==="INSERT"){if(m(l)){const h=P(c),[g]=await T(e,[h]);a=[g,...a.filter(y=>y.transactionId!==g.transactionId)]}}else if(r==="UPDATE"){const h=P(c),[g]=await T(e,[h]),y=a.some(v=>v.transactionId===g.transactionId),b=m(l);b&&!y?a=[g,...a]:!b&&y?a=a.filter(v=>v.transactionId!==g.transactionId):b&&y&&(a=a.map(v=>v.transactionId===g.transactionId?g:v))}else if(r==="DELETE"&&m(u)){const h=d.transaction_id;a=a.filter(g=>g.transactionId!==h)}const p=[...a].sort((h,g)=>new Date(g.createdAt).getTime()-new Date(h.createdAt).getTime());n(p)}).subscribe((i,r)=>{i==="SUBSCRIBED"&&console.log("Subscribed to transactions channel"),r&&console.error("Error subscribing to transactions channel:",r)});return()=>{s.unsubscribe()}},subscribeToAllTransactions(e,t,n){let o=[...n||[]];const a=_.channel(`transactions:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e}`},async s=>{console.log("All transactions change received!",s);const{eventType:i,new:r,old:c}=s;if(i==="INSERT"){const l=P(r),[u]=await T(e,[l]);o=[u,...o.filter(m=>m.transactionId!==u.transactionId)]}else if(i==="UPDATE"){const l=P(r),[u]=await T(e,[l]);o=o.map(m=>m.transactionId===u.transactionId?u:m)}else if(i==="DELETE"){const l=c.transaction_id;o=o.filter(u=>u.transactionId!==l)}const d=[...o].sort((l,u)=>new Date(u.createdAt).getTime()-new Date(l.createdAt).getTime());t(d)}).subscribe((s,i)=>{s==="SUBSCRIBED"&&console.log("Subscribed to all transactions channel"),i&&console.error("Error subscribing to all transactions channel:",i)});return()=>{a.unsubscribe()}},subscribeToTransaction(e,t,n,o){const a=_.channel(`transaction:${e}:${n}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e} AND transaction_id=eq.${n}`},async()=>{try{const{data:i,error:r}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",n).single();if(r){if(r.code==="PGRST116"){o(null);return}console.error("Error fetching transaction in subscription:",r);return}if(i){const c=P(i),d=await T(e,[c]);o(d[0]||null)}else o(null)}catch(i){console.error("Error in transaction subscription callback:",i)}}).subscribe();return(async()=>{try{const{data:i,error:r}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",n).single();if(r){if(r.code==="PGRST116"){o(null);return}console.error("Error fetching initial transaction:",r);return}if(i){const c=P(i),d=await T(e,[c]);o(d[0]||null)}else o(null)}catch(i){console.error("Error in initial transaction fetch:",i)}})(),()=>{a.unsubscribe()}},async getPendingTransactions(e,t){await f();const{data:n,error:o}=await _.from("transactions").select("*").eq("account_id",e).eq("project_id",t).eq("status","pending").order("created_at",{ascending:!1});if(o)throw o;const a=(n||[]).map(s=>P(s));return await T(e,a)},async updateTransactionStatus(e,t,n,o,a){await f();const s={status:o,updated_at:new Date().toISOString()};a&&(a.transactionDate!==void 0&&(s.transaction_date=a.transactionDate),a.paymentMethod!==void 0&&(s.payment_method=a.paymentMethod),a.amount!==void 0&&(s.amount=a.amount),a.notes!==void 0&&(s.notes=a.notes)),o==="completed"&&!(a!=null&&a.transactionDate)&&(s.transaction_date=q(new Date));const{error:i}=await _.from("transactions").update(s).eq("account_id",e).eq("transaction_id",n);if(i)throw i},async getInventoryRelatedTransactions(e){await f();const{data:t,error:n}=await _.from("transactions").select("*").eq("account_id",e).in("reimbursement_type",[U,N]).order("created_at",{ascending:!1});if(n)throw n;const o=(t||[]).map(a=>P(a));return await T(e,o)},async getBusinessInventoryTransactions(e){await f();const{data:t,error:n}=await _.from("transactions").select("*").eq("account_id",e).is("project_id",null).order("created_at",{ascending:!1});if(n)throw n;const o=(t||[]).map(a=>P(a));return await T(e,o)}},I={_convertItemFromDb(e){const t=D(e);return{itemId:t.item_id,accountId:t.account_id,projectId:t.project_id||void 0,transactionId:t.transaction_id||void 0,previousProjectTransactionId:t.previous_project_transaction_id??null,previousProjectId:t.previous_project_id??null,name:t.name||void 0,description:t.description||"",sku:t.sku||"",source:t.source||"",purchasePrice:t.purchase_price||void 0,projectPrice:t.project_price||void 0,marketValue:t.market_value||void 0,paymentMethod:t.payment_method||"",disposition:t.disposition||void 0,notes:t.notes||void 0,space:t.space||void 0,qrKey:t.qr_key||"",bookmark:t.bookmark||!1,dateCreated:t.date_created||"",lastUpdated:t.last_updated?typeof t.last_updated=="string"?t.last_updated:t.last_updated.toISOString():"",images:Array.isArray(t.images)?t.images:[],inventoryStatus:t.inventory_status||void 0,businessInventoryLocation:t.business_inventory_location||void 0,taxRatePct:t.tax_rate_pct?parseFloat(t.tax_rate_pct):void 0,taxAmount:t.tax_amount||void 0,taxAmountPurchasePrice:t.tax_amount_purchase_price||void 0,taxAmountProjectPrice:t.tax_amount_project_price||void 0,createdBy:t.created_by||void 0,createdAt:t.created_at,originTransactionId:t.origin_transaction_id??null,latestTransactionId:t.latest_transaction_id??null}},_convertItemToDb(e){const t={};return e.itemId!==void 0&&(t.item_id=e.itemId),e.accountId!==void 0&&(t.account_id=e.accountId),e.projectId!==void 0&&(t.project_id=e.projectId??null),e.transactionId!==void 0&&(t.transaction_id=e.transactionId??null),e.previousProjectTransactionId!==void 0&&(t.previous_project_transaction_id=e.previousProjectTransactionId??null),e.previousProjectId!==void 0&&(t.previous_project_id=e.previousProjectId??null),e.name!==void 0&&(t.name=e.name),e.description!==void 0&&(t.description=e.description),e.sku!==void 0&&(t.sku=e.sku),e.source!==void 0&&(t.source=e.source),e.purchasePrice!==void 0&&(t.purchase_price=e.purchasePrice),e.projectPrice!==void 0&&(t.project_price=e.projectPrice),e.marketValue!==void 0&&(t.market_value=e.marketValue),e.paymentMethod!==void 0&&(t.payment_method=e.paymentMethod),e.disposition!==void 0&&(t.disposition=e.disposition),e.notes!==void 0&&(t.notes=e.notes),e.space!==void 0&&(t.space=e.space),e.qrKey!==void 0&&(t.qr_key=e.qrKey),e.bookmark!==void 0&&(t.bookmark=e.bookmark),e.dateCreated!==void 0&&(t.date_created=e.dateCreated),e.lastUpdated!==void 0&&(t.last_updated=e.lastUpdated),e.images!==void 0&&(t.images=e.images),e.inventoryStatus!==void 0&&(t.inventory_status=e.inventoryStatus),e.businessInventoryLocation!==void 0&&(t.business_inventory_location=e.businessInventoryLocation),e.taxRatePct!==void 0&&(t.tax_rate_pct=e.taxRatePct),e.taxAmount!==void 0&&(t.tax_amount=e.taxAmount),e.taxAmountPurchasePrice!==void 0&&(t.tax_amount_purchase_price=e.taxAmountPurchasePrice),e.taxAmountProjectPrice!==void 0&&(t.tax_amount_project_price=e.taxAmountProjectPrice),e.createdBy!==void 0&&(t.created_by=e.createdBy),e.createdAt!==void 0&&(t.created_at=e.createdAt),e.originTransactionId!==void 0&&(t.origin_transaction_id=e.originTransactionId??null),e.latestTransactionId!==void 0&&(t.latest_transaction_id=e.latestTransactionId??null),t},async getItemsByProject(e,t,n,o){await f();let a=_.from("items").select("*").eq("account_id",e).eq("project_id",t);if(n!=null&&n.status&&(a=a.eq("disposition",n.status)),n!=null&&n.category&&(a=a.eq("source",n.category)),n!=null&&n.priceRange&&(a=a.gte("project_price",n.priceRange.min.toString()),a=a.lte("project_price",n.priceRange.max.toString())),n!=null&&n.searchQuery&&(a=a.or(`description.ilike.%${n.searchQuery}%,source.ilike.%${n.searchQuery}%,sku.ilike.%${n.searchQuery}%,payment_method.ilike.%${n.searchQuery}%`)),a=a.order("last_updated",{ascending:!1}),o){const r=o.page>0?(o.page-1)*o.limit:0;a=a.range(r,r+o.limit-1)}const{data:s,error:i}=await a;if(i)throw i;return(s||[]).map(r=>this._convertItemFromDb(r))},subscribeToProjectItems(e,t,n,o){let a=[...o||[]];const s=_.channel(`project-items:${e}:${t}`).on("postgres_changes",{event:"*",schema:"public",table:"items",filter:`account_id=eq.${e}`},i=>{console.log("Project items change received (broad filter)!",i);const{eventType:r,new:c,old:d}=i;if(r==="INSERT")c.project_id===t&&(a=[this._convertItemFromDb(c),...a]);else if(r==="UPDATE"){const l=this._convertItemFromDb(c),u=a.some(p=>p.itemId===l.itemId),m=l.projectId===t;m&&!u?a=[l,...a]:!m&&u?a=a.filter(p=>p.itemId!==l.itemId):m&&u&&(a=a.map(p=>p.itemId===l.itemId?l:p))}else if(r==="DELETE"){const l=d.item_id;a=a.filter(u=>u.itemId!==l)}n([...a])}).subscribe((i,r)=>{i==="SUBSCRIBED"&&console.log("Subscribed to project items channel"),r&&console.error("Error subscribing to project items channel:",r)});return()=>{s.unsubscribe()}},async getBusinessInventoryItems(e,t,n){await f();let o=_.from("items").select("*").eq("account_id",e).is("project_id",null);if(t!=null&&t.status&&(o=o.eq("inventory_status",t.status)),t!=null&&t.searchQuery&&(o=o.or(`description.ilike.%${t.searchQuery}%,source.ilike.%${t.searchQuery}%,sku.ilike.%${t.searchQuery}%,business_inventory_location.ilike.%${t.searchQuery}%`)),o=o.order("last_updated",{ascending:!1}),n){const i=n.page>0?(n.page-1)*n.limit:0;o=o.range(i,i+n.limit-1)}const{data:a,error:s}=await o;if(s)throw s;return(a||[]).map(i=>this._convertItemFromDb(i))},subscribeToBusinessInventory(e,t,n,o){let a=[...o||[]];const s=_.channel(`business-inventory:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"items",filter:`account_id=eq.${e}`},i=>{console.log("Business inventory change received!",i);const{eventType:r,new:c,old:d}=i;if(r==="INSERT")c.project_id||(a=[this._convertItemFromDb(c),...a]);else if(r==="UPDATE"){const l=this._convertItemFromDb(c);l.projectId?a=a.filter(u=>u.itemId!==l.itemId):a=a.map(u=>u.itemId===l.itemId?l:u)}else if(r==="DELETE"){const l=d.item_id;a=a.filter(u=>u.itemId!==l)}t([...a])}).subscribe((i,r)=>{i==="SUBSCRIBED"&&console.log("Subscribed to business inventory channel"),r&&console.error("Error subscribing to business inventory channel:",r)});return()=>{s.unsubscribe()}},async createItem(e,t){await f();const n=new Date,o=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,a=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,s=this._convertItemToDb({...t,itemId:o,qrKey:t.qrKey||a});s.date_created=q(n),s.last_updated=n.toISOString(),s.account_id=e,s.created_at=n.toISOString(),s.date_created||(s.date_created=q(n)),s.last_updated||(s.last_updated=n.toISOString()),s.inventory_status||(s.inventory_status="available");try{if(s.transaction_id&&s.tax_rate_pct===null){const{data:c}=await _.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",s.transaction_id).single();c&&c.tax_rate_pct!==void 0&&c.tax_rate_pct!==null&&(s.tax_rate_pct=c.tax_rate_pct)}}catch(c){console.warn("Failed to inherit tax_rate_pct when creating item:",c)}const i=(c,d)=>{const l=parseFloat(c||"0"),u=d!=null?Number(d)/100:0;return(Math.round(l*u*1e4)/1e4).toFixed(4)};s.tax_amount_purchase_price=i(s.purchase_price,s.tax_rate_pct),s.tax_amount_project_price=i(s.project_price,s.tax_rate_pct);const{error:r}=await _.from("items").insert(s);if(r)throw r;try{if(s.transaction_id){const c=s.transaction_id;if(!j._isBatchActive(e,c))try{const d=s.purchase_price??s.price??"0",l=parseFloat(String(d)||"0");j.notifyTransactionChanged(e,c,{deltaSum:l}).catch(u=>{console.warn("Failed to notifyTransactionChanged after creating item:",u)})}catch(d){console.warn("Failed computing delta for created item:",d)}}}catch(c){console.warn("Failed to notifyTransactionChanged after creating item (sync path):",c)}return o},async updateItem(e,t,n){await f();let o=null;try{o=await this.getItemById(e,t)}catch(i){console.warn("Failed to fetch existing item before update:",i)}const a=this._convertItemToDb({...n,lastUpdated:new Date().toISOString()});try{const i=n.transactionId!==void 0&&n.transactionId!==null,r=n.taxRatePct===void 0||n.taxRatePct===null;if(i&&r){const c=n.transactionId;if(c){const{data:d}=await _.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",c).single();d&&d.tax_rate_pct!==void 0&&d.tax_rate_pct!==null&&(a.tax_rate_pct=d.tax_rate_pct)}}}catch(i){console.warn("Failed to inherit tax_rate_pct when updating item:",i)}try{if(n.transactionId!==void 0&&n.transactionId!==null&&(o==null?void 0:o.disposition)==="to return"){const r=n.transactionId;if(r){const{data:c}=await _.from("transactions").select("transaction_type").eq("account_id",e).eq("transaction_id",r).single();c&&c.transaction_type==="Return"&&a.disposition===void 0&&(a.disposition="returned")}}}catch(i){console.warn("Failed to auto-update disposition when assigning return transaction:",i)}const{error:s}=await _.from("items").update(a).eq("account_id",e).eq("item_id",t);if(s)throw s;try{const i=(o==null?void 0:o.transactionId)??null,r=n.transactionId!==void 0?n.transactionId:i,c=(n.projectId!==void 0?n.projectId:o==null?void 0:o.projectId)??null,d=Array.from(new Set([i,r]).values()).filter(Boolean),l=parseFloat((o==null?void 0:o.purchasePrice)||"0"),u=n.purchasePrice!==void 0?parseFloat(String(n.purchasePrice||"0")):l;for(const m of d)try{if(!j._isBatchActive(e,m))if(i&&r&&i===r&&m===i){const p=u-l;p!==0&&j.notifyTransactionChanged(e,m,{deltaSum:p}).catch(h=>{console.warn("Failed to notifyTransactionChanged after updating item for tx",m,h)})}else{if(m===i){const p=-l;j.notifyTransactionChanged(e,m,{deltaSum:p}).catch(h=>{console.warn("Failed to notifyTransactionChanged for old tx after moving item",m,h)})}if(m===r){const p=u;j.notifyTransactionChanged(e,m,{deltaSum:p}).catch(h=>{console.warn("Failed to notifyTransactionChanged for new tx after moving item",m,h)})}}}catch(p){console.warn("Failed to schedule notifyTransactionChanged after updating item for tx",m,p)}}catch(i){console.warn("Failed to schedule notifyTransactionChanged after updateItem:",i)}},async deleteItem(e,t){await f();let n=null;try{n=await this.getItemById(e,t)}catch(a){console.warn("Failed to fetch item before deletion:",a)}const{error:o}=await _.from("items").delete().eq("account_id",e).eq("item_id",t);if(o)throw o;try{const a=(n==null?void 0:n.transactionId)??null;if(a&&!j._isBatchActive(e,a)){const i=-parseFloat((n==null?void 0:n.purchasePrice)||"0");j.notifyTransactionChanged(e,a,{deltaSum:i}).catch(r=>{console.warn("Failed to notifyTransactionChanged after deleting item:",r)})}}catch(a){console.warn("Failed to notifyTransactionChanged after deleting item:",a)}},async getItemsForTransaction(e,t,n){await f();const{data:o,error:a}=await _.from("items").select("*").eq("account_id",e).eq("transaction_id",n).order("date_created",{ascending:!0});if(a)throw a;return(o||[]).map(s=>this._convertItemFromDb(s))},async allocateItemToProject(e,t,n,o,a,s){await f();const i=await this.getItemById(e,t);if(!i)throw new Error("Item not found");const r=o||i.projectPrice||i.marketValue||"0.00",c=i.transactionId||null;console.log("ðŸ”„ Starting allocation process:",{itemId:t,projectId:n,currentTransactionId:c,itemProjectId:i.projectId,finalAmount:r});try{await S.logAllocationEvent(e,"allocation",t,i.projectId??null,c??null,{action:"allocation_started",target_project_id:n,current_transaction_id:c,amount:r})}catch(d){console.warn("âš ï¸ Failed to log allocation start:",d)}return c!=null&&c.startsWith("INV_SALE_")?c.replace("INV_SALE_","")===n?(console.log("ðŸ“‹ Scenario A.1: Item in Sale, allocating to same project â†’ move to inventory"),await this.handleSaleToInventoryMove(e,i,c,n,r,a,s)):(console.log("ðŸ“‹ Scenario A.2: Item in Sale, allocating to different project"),await this.handleSaleToDifferentProjectMove(e,t,c,n,r,a,s)):c!=null&&c.startsWith("INV_PURCHASE_")?c.replace("INV_PURCHASE_","")===n?(console.log("ðŸ“‹ Scenario B.1: Item in Purchase, allocating to same project"),await this.handlePurchaseToInventoryMove(e,t,c,n,r,a,s)):(console.log("ðŸ“‹ Scenario B.2: Item in Purchase, allocating to different project"),await this.handlePurchaseToDifferentProjectMove(e,t,c,n,r,a,s)):c?(console.log("ðŸ“‹ Fallback: Unknown scenario, treating as new allocation"),await this.handleInventoryToPurchaseMove(e,t,n,r,a,s)):(console.log("ðŸ“‹ Scenario C: Item in inventory, allocating to project"),await this.handleInventoryToPurchaseMove(e,t,n,r,a,s))},async handleSaleToPurchaseMove(e,t,n,o,a,s,i){const r=`INV_PURCHASE_${o}`;await this.removeItemFromTransaction(e,t,n,a),await this.addItemToTransaction(e,t,r,a,"Purchase","Inventory allocation",s),await this.updateItem(e,t,{projectId:o,inventoryStatus:"allocated",transactionId:r,disposition:"keep",space:i,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,n,r,s),await w.updateItemLineagePointers(e,t,r)}catch(c){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",c)}console.log("âœ… A.1 completed: Sale â†’ Purchase (same project)");try{await S.logAllocationEvent(e,"allocation",t,o,r,{action:"allocation_completed",scenario:"A.1",from_transaction:n,to_transaction:r,amount:a})}catch(c){console.warn("âš ï¸ Failed to log allocation completion:",c)}return r},async _restoreItemAfterSaleRemoval(e,t,n,o,a,s){let i=null,r="missing_previous_link";const c=t.previousProjectTransactionId,d=t.previousProjectId,l={projectId:n,inventoryStatus:"allocated",transactionId:null,disposition:"keep",notes:a,space:s??"",previousProjectTransactionId:null,previousProjectId:null};if(c&&d)if(d===n){const{data:u,error:m}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",c).single();!m&&u?(await this.addItemToTransaction(e,t.itemId,c,o,"Purchase","Inventory allocation",a),await this.updateItem(e,t.itemId,{...l,transactionId:c}),i=c,r="restored"):(console.warn("âš ï¸ Stored previous project transaction not found; falling back to allocation without restoration",{itemId:t.itemId,previousTransactionId:c}),r="transaction_missing",await this.updateItem(e,t.itemId,l))}else r="previous_project_mismatch",await this.updateItem(e,t.itemId,l);else await this.updateItem(e,t.itemId,l);return{restoredTransactionId:i,restorationStatus:r}},async handleSaleToInventoryMove(e,t,n,o,a,s,i){await this.removeItemFromTransaction(e,t.itemId,n,a);const{restoredTransactionId:r,restorationStatus:c}=await this._restoreItemAfterSaleRemoval(e,t,o,a,s,i);try{r?(await w.appendItemLineageEdge(e,t.itemId,n,r,s),await w.updateItemLineagePointers(e,t.itemId,r)):(await w.appendItemLineageEdge(e,t.itemId,n,null,s),await w.updateItemLineagePointers(e,t.itemId,null))}catch(d){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",d)}console.log("âœ… A.1 completed: Sale â†’ Inventory (same project)",{restorationStatus:c,restoredTransactionId:r});try{const d={action:"allocation_completed",scenario:"A.1",from_transaction:n,amount:a,restoration_status:c,to_status:r?"allocated_with_purchase":"allocated"};r&&(d.restored_transaction_id=r),await S.logAllocationEvent(e,"allocation",t.itemId,o,r??null,d)}catch(d){console.warn("âš ï¸ Failed to log allocation completion (A.1):",d)}return r??n},async handleSaleToDifferentProjectMove(e,t,n,o,a,s,i){const r=`INV_PURCHASE_${o}`;await this.removeItemFromTransaction(e,t,n,a),await this.addItemToTransaction(e,t,r,a,"Purchase","Inventory allocation",s),await this.updateItem(e,t,{projectId:o,inventoryStatus:"allocated",transactionId:r,disposition:"keep",space:i,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,n,r,s),await w.updateItemLineagePointers(e,t,r)}catch(c){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",c)}console.log("âœ… A.2 completed: Sale â†’ Purchase (different project)");try{await S.logAllocationEvent(e,"allocation",t,o,r,{action:"allocation_completed",scenario:"A.2",from_transaction:n,to_transaction:r,amount:a})}catch(c){console.warn("âš ï¸ Failed to log allocation completion:",c)}return r},async handlePurchaseToInventoryMove(e,t,n,o,a,s,i){await this.removeItemFromTransaction(e,t,n,a),await this.updateItem(e,t,{projectId:null,inventoryStatus:"available",transactionId:null,disposition:"inventory",notes:s,space:i??"",previousProjectTransactionId:n,previousProjectId:o});try{await w.appendItemLineageEdge(e,t,n,null,s),await w.updateItemLineagePointers(e,t,null)}catch(r){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",r)}console.log("âœ… B.1 completed: Purchase â†’ Inventory (same project)");try{await S.logAllocationEvent(e,"deallocation",t,null,"inventory",{action:"deallocation_completed",scenario:"B.1",from_transaction:n,to_status:"inventory",amount:a})}catch(r){console.warn("âš ï¸ Failed to log deallocation completion:",r)}return n},async handlePurchaseToDifferentProjectMove(e,t,n,o,a,s,i){const r=`INV_SALE_${o}`;await this.removeItemFromTransaction(e,t,n,a),await this.addItemToTransaction(e,t,r,a,"To Inventory","Inventory sale",s),await this.updateItem(e,t,{projectId:null,inventoryStatus:"available",transactionId:r,disposition:"inventory",space:i??"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,n,r,s),await w.updateItemLineagePointers(e,t,r)}catch(c){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",c)}console.log("âœ… B.2 completed: Purchase â†’ Sale (different project)");try{await S.logAllocationEvent(e,"allocation",t,null,r,{action:"allocation_completed",scenario:"B.2",from_transaction:n,to_transaction:r,amount:a})}catch(c){console.warn("âš ï¸ Failed to log allocation completion:",c)}return r},async handleInventoryToPurchaseMove(e,t,n,o,a,s){const i=`INV_PURCHASE_${n}`;await this.addItemToTransaction(e,t,i,o,"Purchase","Inventory allocation",a),await this.updateItem(e,t,{projectId:n,inventoryStatus:"allocated",transactionId:i,disposition:"keep",space:s,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,null,i,a),await w.updateItemLineagePointers(e,t,i,i)}catch(r){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",r)}console.log("âœ… C completed: Inventory â†’ Purchase (new allocation)");try{await S.logAllocationEvent(e,"allocation",t,n,i,{action:"allocation_completed",scenario:"C",from_status:"inventory",to_transaction:i,amount:o})}catch(r){console.warn("âš ï¸ Failed to log allocation completion:",r)}return i},async removeItemFromTransaction(e,t,n,o){await f();const{data:a,error:s}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",n).single();if(s||!a){console.warn("âš ï¸ Transaction not found for removal:",n);return}const r=(a.item_ids||[]).filter(c=>c!==t);if(r.length===0)try{const{error:c}=await _.from("transactions").delete().eq("account_id",e).eq("transaction_id",n);if(c)throw c;console.log("ðŸ—‘ï¸ Deleted empty transaction:",n);try{await S.logTransactionStateChange(e,n,"deleted",a,null)}catch(d){console.warn("âš ï¸ Failed to log transaction deletion:",d)}}catch(c){console.error("âŒ Failed to delete empty transaction:",n,c)}else try{const{data:c,error:d}=await _.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",r);if(d)throw d;const l=(c||[]).map(h=>h.project_price||h.market_value||"0.00").reduce((h,g)=>h+parseFloat(g||"0"),0).toFixed(2),u=parseFloat(l)<0?"0.00":l,m={item_ids:r,amount:u,updated_at:new Date().toISOString()},{error:p}=await _.from("transactions").update(m).eq("account_id",e).eq("transaction_id",n);if(p)throw p;console.log("ðŸ”„ Updated transaction after removal:",n,"new amount:",u);try{await S.logTransactionStateChange(e,n,"updated",a,m)}catch(h){console.warn("âš ï¸ Failed to log transaction update:",h)}}catch(c){console.error("âŒ Failed to update transaction after removal:",n,c)}},async addItemToTransaction(e,t,n,o,a,s,i){await f();const{data:r,error:c}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",n).single();if(r&&!c)try{const d=r.item_ids||[],l=[...new Set([...d,t])],{data:u,error:m}=await _.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",l);if(m)throw m;const p=(u||[]).map(b=>b.project_price||b.market_value||"0.00").reduce((b,v)=>b+parseFloat(v||"0"),0).toFixed(2),h=parseFloat(p)<0?"0.00":p,g={item_ids:l,amount:h,updated_at:new Date().toISOString()},{error:y}=await _.from("transactions").update(g).eq("account_id",e).eq("transaction_id",n);if(y)throw y;console.log("ðŸ”„ Added item to existing transaction:",n,"new amount:",h);try{await S.logTransactionStateChange(e,n,"updated",r,g)}catch(b){console.warn("âš ï¸ Failed to log transaction update:",b)}try{const b=r.tax_rate_pct;b!=null&&await this.updateItem(e,t,{tax_rate_pct:b})}catch(b){console.warn("Failed to set tax_rate_pct on added item:",t,b)}try{await this.updateItem(e,t,{transactionId:n})}catch(b){console.warn("Failed to link item to transaction after adding to existing transaction:",t,b)}}catch(d){console.error("âŒ Failed to update existing transaction:",n,d)}else try{const d=await C();if(!(d!=null&&d.id))throw new Error("User must be authenticated to create transactions");const l=n.replace(a==="Purchase"?"INV_PURCHASE_":"INV_SALE_",""),u=await A.getProject(e,l),m=(u==null?void 0:u.name)||"Other",p=new Date,h={account_id:e,transaction_id:n,project_id:l,transaction_date:q(p),source:a==="Purchase"?"Inventory":m,transaction_type:a,payment_method:"Pending",amount:o,budget_category:"Furnishings",notes:i||`Transaction for items ${a==="Purchase"?"purchased from":"sold to"} ${a==="Purchase"?"inventory":"project"}`,status:"pending",reimbursement_type:a==="Purchase"?U:N,trigger_event:s,item_ids:[t],created_by:d.id,created_at:p.toISOString(),updated_at:p.toISOString()},{error:g}=await _.from("transactions").insert(h);if(g)throw g;console.log("ðŸ†• Created new transaction:",n,"amount:",o);try{await S.logTransactionStateChange(e,n,"created",null,h)}catch(y){console.warn("âš ï¸ Failed to log transaction creation:",y)}try{await this.updateItem(e,t,{transactionId:n})}catch(y){console.warn("Failed to link item to transaction after creating new transaction:",t,y)}}catch(d){console.error("âŒ Failed to create new transaction:",n,d)}},async batchAllocateItemsToProject(e,t,n,o={}){await f();const{data:a,error:s}=await _.from("items").select("*").eq("account_id",e).in("item_id",t);if(s||!a||a.length===0)throw new Error("No items found for allocation");const i=`INV_PURCHASE_${n}`;for(const r of a){const c=this._convertItemFromDb(r),d=c.itemId,l=o.amount||r.project_price||r.market_value||"0.00",u=r.transaction_id||null;if(u!=null&&u.startsWith("INV_SALE_"))if(u.replace("INV_SALE_","")===n){console.log("ðŸ“‹ Batch A.1: Item in sale for target project â€” removing from sale and assigning to project",d),await this.removeItemFromTransaction(e,d,u,l);const{restoredTransactionId:p}=await this._restoreItemAfterSaleRemoval(e,c,n,l,o.notes,o.space);try{p?(await w.appendItemLineageEdge(e,d,u,p,o.notes),await w.updateItemLineagePointers(e,d,p)):(await w.appendItemLineageEdge(e,d,u,null,o.notes),await w.updateItemLineagePointers(e,d,null))}catch(h){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",h)}continue}else{console.log("ðŸ“‹ Batch A.2: Item in sale for different project â€” moving to purchase for target project",d),await this.removeItemFromTransaction(e,d,u,l),await this.addItemToTransaction(e,d,i,l,"Purchase","Inventory allocation",o.notes),await this.updateItem(e,d,{projectId:n,inventoryStatus:"allocated",transactionId:i,disposition:"keep",space:o.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,u,i,o.notes),await w.updateItemLineagePointers(e,d,i)}catch(p){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",p)}continue}if(!u){console.log("ðŸ“‹ Batch C: Item in inventory â€” adding to purchase",d),await this.addItemToTransaction(e,d,i,l,"Purchase","Inventory allocation",o.notes),await this.updateItem(e,d,{projectId:n,inventoryStatus:"allocated",transactionId:i,disposition:"keep",space:o.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,null,i,o.notes),await w.updateItemLineagePointers(e,d,i,i)}catch(m){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",m)}continue}console.log("ðŸ“‹ Batch Fallback: Item in other transaction â€” adding to purchase",d,u),await this.addItemToTransaction(e,d,i,l,"Purchase","Inventory allocation",o.notes),await this.updateItem(e,d,{projectId:n,inventoryStatus:"allocated",transactionId:i,disposition:"keep",space:o.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,u,i,o.notes),await w.updateItemLineagePointers(e,d,i)}catch(m){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",m)}}return i},async returnItemFromProject(e,t,n,o,a){await f();const s=await this.getItemById(e,t);if(!s)throw new Error("Item not found");const i=o||s.projectPrice||s.marketValue||"0.00",r=s.transactionId||null;console.log("ðŸ”„ Starting return process:",{itemId:t,projectId:n,currentTransactionId:r,itemProjectId:s.projectId,finalAmount:i});try{await S.logAllocationEvent(e,"return",t,s.projectId??null,r??null,{action:"return_started",target_project_id:n,current_transaction_id:r,amount:i})}catch(c){console.warn("âš ï¸ Failed to log return start:",c)}return r!=null&&r.startsWith("INV_PURCHASE_")&&r.replace("INV_PURCHASE_","")===n?(console.log("ðŸ“‹ Return Scenario: Item in Purchase, returning from same project"),await this.handleReturnFromPurchase(e,s,r,n,i,a)):(console.log("ðŸ“‹ Return Scenario: Item not in transaction or new return"),await this.handleNewReturn(e,s,n,i,a))},async handleReturnFromPurchase(e,t,n,o,a,s){await this.removeItemFromTransaction(e,t.itemId,n,a),await this.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,disposition:"inventory",notes:s,previousProjectTransactionId:n,previousProjectId:t.projectId??o});try{await w.appendItemLineageEdge(e,t.itemId,n,null,s),await w.updateItemLineagePointers(e,t.itemId,null)}catch(i){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",i)}console.log("âœ… Return completed: Purchase â†’ Inventory (same project)");try{await S.logAllocationEvent(e,"return",t.itemId,null,n,{action:"return_completed",scenario:"return_from_purchase",from_transaction:n,to_status:"inventory",amount:a})}catch(i){console.warn("âš ï¸ Failed to log return completion:",i)}return n},async handleNewReturn(e,t,n,o,a){var p,h;await f();const s=await C();if(!(s!=null&&s.id))throw new Error("User must be authenticated to create transactions");let i="Other";try{const g=await A.getProject(e,n);i=(g==null?void 0:g.name)||"Other"}catch(g){console.warn("Could not fetch project name for transaction source:",g)}const r=`INV_SALE_${n}`,{data:c,error:d}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",r).single(),l=new Date;if(c&&!d){console.log("ðŸ“‹ Existing INV_SALE transaction found, updating with new item");const g=c.item_ids||[],y=[...new Set([...g,t.itemId])],{data:b,error:v}=await _.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",y);if(v)throw v;const E=(b||[]).map(R=>R.project_price||R.market_value||"0.00").reduce((R,k)=>R+parseFloat(k||"0"),0).toFixed(2),x={item_ids:y,amount:E,notes:a||"Transaction for items purchased from project and moved to business inventory",updated_at:l.toISOString()},{error:F}=await _.from("transactions").update(x).eq("account_id",e).eq("transaction_id",r);if(F)throw F;console.log("ðŸ”„ Updated INV_SALE transaction with",y.length,"items, amount:",E)}else{const g={account_id:e,transaction_id:r,project_id:n,transaction_date:q(l),source:i,transaction_type:"To Inventory",payment_method:"Pending",amount:o,budget_category:"Furnishings",notes:a||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:N,trigger_event:"Inventory sale",item_ids:[t.itemId],created_by:s.id,created_at:l.toISOString(),updated_at:l.toISOString()};console.log("ðŸ†• Creating new INV_SALE transaction with amount:",g.amount);const{error:y}=await _.from("transactions").insert(g);if(y)throw y}const u=(p=t.transactionId)!=null&&p.startsWith("INV_PURCHASE_")?t.transactionId:t.previousProjectTransactionId??null,m=(h=t.transactionId)!=null&&h.startsWith("INV_PURCHASE_")?t.projectId??n:t.previousProjectId??null;await this.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:r,disposition:"inventory",previousProjectTransactionId:u,previousProjectId:m});try{const g=t.transactionId||null;await w.appendItemLineageEdge(e,t.itemId,g,r,a),await w.updateItemLineagePointers(e,t.itemId,r)}catch(g){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",g)}console.log("âœ… New return completed: Inventory â†’ Sale");try{await S.logAllocationEvent(e,"return",t.itemId,null,r,{action:"return_completed",scenario:"new_return",from_status:"inventory",to_transaction:r,amount:o})}catch(g){console.warn("âš ï¸ Failed to log return completion:",g)}return r},async completePendingTransaction(e,t,n,o){await f();const a=t==="sale"?`INV_SALE_${n}`:`INV_PURCHASE_${n}`,{data:s,error:i}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",a).single();if(i||!s)throw new Error("Transaction not found");const r=s.item_ids||[],c=new Date,{error:d}=await _.from("transactions").update({status:"completed",payment_method:o,transaction_date:q(c),updated_at:c.toISOString()}).eq("account_id",e).eq("transaction_id",a);if(d)throw d;for(const l of r)if(t==="sale"){await this.updateItem(e,l,{transactionId:null,inventoryStatus:"available"});try{await w.appendItemLineageEdge(e,l,a,null),await w.updateItemLineagePointers(e,l,null)}catch(u){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",u)}}else{await this.updateItem(e,l,{projectId:null,transactionId:null,inventoryStatus:"available"});try{await w.appendItemLineageEdge(e,l,a,null),await w.updateItemLineagePointers(e,l,null)}catch(u){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",u)}}},async getItemById(e,t){await f();const{data:n,error:o}=await _.from("items").select("*").eq("account_id",e).eq("item_id",t).single();if(o){if(o.code==="PGRST116")return null;throw o}return n?this._convertItemFromDb(n):null},async duplicateItem(e,t,n){await f();const o=await this.getItemById(e,n);if(!o)throw new Error("Original item not found");const a=new Date,s=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,i=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,r={account_id:e,item_id:s,description:o.description||"",source:o.source||"",sku:o.sku||"",purchase_price:o.purchasePrice||null,project_price:o.projectPrice||null,market_value:o.marketValue||null,payment_method:o.paymentMethod||"",disposition:"keep",notes:o.notes||null,space:o.space||null,qr_key:i,bookmark:!1,transaction_id:o.transactionId||null,project_id:t,inventory_status:o.inventoryStatus||"available",business_inventory_location:o.businessInventoryLocation||null,date_created:o.dateCreated||q(a),last_updated:a.toISOString(),images:o.images||[],tax_rate_pct:o.taxRatePct||null,tax_amount:o.taxAmount||null,created_by:o.createdBy||null,created_at:a.toISOString()};Object.keys(r).forEach(d=>{r[d]===void 0&&delete r[d]});const{error:c}=await _.from("items").insert(r);if(c)throw c;return s},async createTransactionItems(e,t,n,o,a,s,i){await f();const r=[],c=new Date;let d;try{if(i==null&&n){const{data:m,error:p}=await _.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",n).single();!p&&m&&m.tax_rate_pct!==void 0&&m.tax_rate_pct!==null&&(d=m.tax_rate_pct)}}catch{}const l=[],u=(m,p)=>{const h=parseFloat(m||"0"),g=p!=null?Number(p)/100:0;return(Math.round(h*g*1e4)/1e4).toFixed(4)};for(const m of s){const p=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`;r.push(p);const h=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,g={account_id:e,item_id:p,description:m.description||"",source:a,sku:m.sku||"",purchase_price:m.purchasePrice||null,project_price:m.projectPrice||null,market_value:m.marketValue||null,payment_method:"Client Card",disposition:"keep",notes:m.notes||null,qr_key:h,bookmark:!1,transaction_id:n,project_id:t,inventory_status:"allocated",date_created:o,last_updated:c.toISOString(),images:[],created_at:c.toISOString()};i!=null?g.tax_rate_pct=i:d!==void 0&&(g.tax_rate_pct=d),g.tax_amount_purchase_price=u(g.purchase_price,g.tax_rate_pct),g.tax_amount_project_price=u(g.project_price,g.tax_rate_pct),l.push(g)}if(l.length>0){const{error:m}=await _.from("items").insert(l);if(m)throw m}try{if(!j._isBatchActive(e,n))try{const m=l.reduce((p,h)=>{const g=parseFloat(String(h.purchase_price??h.price??"0")||"0");return p+(isNaN(g)?0:g)},0);m!==0?j.notifyTransactionChanged(e,n,{deltaSum:m}).catch(p=>{console.warn("Failed to notifyTransactionChanged after creating transaction items:",p)}):j.notifyTransactionChanged(e,n).catch(p=>{console.warn("Failed to notifyTransactionChanged after creating transaction items (no delta):",p)})}catch(m){console.warn("Failed computing deltaSum for created transaction items:",m)}}catch(m){console.warn("Failed to notifyTransactionChanged after creating transaction items (sync path):",m)}return r}},M={async _resolvePreviousProjectLink(e,t,n){const o=t.transactionId,a=t.projectId??n,s=o?o.startsWith("INV_SALE_"):!1;return o&&!s?{previousProjectTransactionId:o,previousProjectId:a}:{previousProjectTransactionId:t.previousProjectTransactionId??null,previousProjectId:t.previousProjectId??null}},async handleInventoryDesignation(e,t,n,o){if(console.log("ðŸ”„ handleInventoryDesignation called:",{itemId:t,projectId:n,disposition:o}),o!=="inventory"){console.log("â­ï¸ Skipping - disposition is not inventory:",o);return}try{console.log("ðŸ” Getting item details for:",t);const a=await I.getItemById(e,t);if(!a)throw new Error("Item not found");console.log("âœ… Item found:",a.itemId,"disposition:",a.disposition,"projectId:",a.projectId);const{previousProjectTransactionId:s,previousProjectId:i}=await this._resolvePreviousProjectLink(e,a,n);if(a.transactionId&&a.transactionId.startsWith("INV_PURCHASE_")&&a.transactionId.replace("INV_PURCHASE_","")===n){console.log("ðŸ” Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory"),await I.removeItemFromTransaction(e,a.itemId,a.transactionId,a.projectPrice||a.marketValue||"0.00"),await I.updateItem(e,a.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,previousProjectTransactionId:s,previousProjectId:i,lastUpdated:new Date().toISOString()});try{await S.logAllocationEvent(e,"deallocation",t,null,a.transactionId,{action:"deallocation_completed",scenario:"purchase_reversion",from_transaction:a.transactionId,to_status:"inventory",amount:a.projectPrice||a.marketValue||"0.00"})}catch(d){console.warn("âš ï¸ Failed to log deallocation completion for purchase-reversion:",d)}console.log("âœ… Purchase-reversion handled: item returned to inventory without creating INV_SALE");return}console.log("ðŸ¦ Creating/updating Sale transaction for inventory designation");try{await S.logAllocationEvent(e,"deallocation",t,a.projectId??null,a.transactionId??null,{action:"deallocation_started",target_status:"inventory",current_transaction_id:a.transactionId})}catch(c){console.warn("âš ï¸ Failed to log deallocation start:",c)}const r=await this.ensureSaleTransaction(e,a,n,"Transaction for items purchased from project and moved to business inventory",{previousProjectTransactionId:s,previousProjectId:i});console.log("ðŸ“¦ Moving item to business inventory..."),await I.updateItem(e,a.itemId,{projectId:null,inventoryStatus:"available",transactionId:r,space:"",previousProjectTransactionId:s,previousProjectId:i,lastUpdated:new Date().toISOString()});try{const c=a.transactionId||null;await w.appendItemLineageEdge(e,a.itemId,c,r),await w.updateItemLineagePointers(e,a.itemId,r)}catch(c){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",c)}try{await S.logAllocationEvent(e,"deallocation",t,null,r,{action:"deallocation_completed",from_project_id:a.projectId,to_transaction:r,amount:a.projectPrice||a.marketValue||"0.00"})}catch(c){console.warn("âš ï¸ Failed to log deallocation completion:",c)}console.log("âœ… Item moved to business inventory successfully"),console.log("âœ… Deallocation completed successfully")}catch(a){throw console.error("âŒ Error handling inventory designation:",a),a}},async ensureSaleTransaction(e,t,n,o,a){await f();const s=await C();if(!(s!=null&&s.id))throw new Error("User must be authenticated to create transactions");console.log("ðŸ¦ Creating/updating sale transaction for item:",t.itemId);let i="Other";try{const l=await A.getProject(e,n);i=(l==null?void 0:l.name)||"Other"}catch(l){console.warn("Could not fetch project name for transaction source:",l)}if(t.transactionId&&t.transactionId.startsWith("INV_PURCHASE_")&&t.transactionId.replace("INV_PURCHASE_","")===n)return console.log("â„¹ï¸ ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE"),await I.removeItemFromTransaction(e,t.itemId,t.transactionId,t.projectPrice||t.marketValue||"0.00"),await I.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,previousProjectTransactionId:(a==null?void 0:a.previousProjectTransactionId)??t.transactionId,previousProjectId:(a==null?void 0:a.previousProjectId)??t.projectId??n}),null;const r=`INV_SALE_${n}`;console.log("ðŸ”‘ Canonical transaction ID:",r);const{data:c,error:d}=await _.from("transactions").select("*").eq("account_id",e).eq("transaction_id",r).single();if(c&&!d){console.log("ðŸ“‹ Existing INV_SALE transaction found, updating with new item");const l=c.item_ids||[],u=[...new Set([...l,t.itemId])],{data:m,error:p}=await _.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",u);if(p)throw p;const h=(m||[]).map(v=>v.project_price||v.market_value||"0.00").reduce((v,E)=>v+parseFloat(E||"0"),0).toFixed(2),y={item_ids:u,amount:h,notes:o||"Transaction for items purchased from project and moved to business inventory",updated_at:new Date().toISOString()},{error:b}=await _.from("transactions").update(y).eq("account_id",e).eq("transaction_id",r);if(b)throw b;console.log("ðŸ”„ Updated INV_SALE transaction with",u.length,"items, amount:",h)}else{const l=t.projectPrice||t.marketValue||"0.00",u=new Date,m={account_id:e,transaction_id:r,project_id:n,transaction_date:q(u),source:i,transaction_type:"To Inventory",payment_method:"Pending",amount:parseFloat(l).toFixed(2),budget_category:"Furnishings",notes:o||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:N,trigger_event:"Inventory sale",item_ids:[t.itemId],created_by:s.id,created_at:u.toISOString(),updated_at:u.toISOString()};console.log("ðŸ†• Creating new INV_SALE transaction with amount:",m.amount);const{error:p}=await _.from("transactions").insert(m);if(p)throw p}return console.log("âœ… Sale transaction created/updated successfully"),r}},H={async allocateBusinessInventoryToProject(e,t,n,o,a){return await I.allocateItemToProject(e,t,n,o,a)},async returnItemToBusinessInventory(e,t,n,o){await I.returnItemFromProject(e,t,o)},async completePendingTransaction(e,t,n,o,a){return await I.completePendingTransaction(e,"sale",o,a)},async handleItemDeallocation(e,t,n,o){return await M.handleInventoryDesignation(e,t,n,o)}},Y=Object.freeze(Object.defineProperty({__proto__:null,auditService:S,deallocationService:M,integrationService:H,projectService:A,transactionService:j,unifiedItemsService:I},Symbol.toStringTag,{value:"Module"}));export{G as a,q as b,Y as c,K as f,H as i,w as l,A as p,j as t,I as u};
//# sourceMappingURL=inventoryService.js.map
