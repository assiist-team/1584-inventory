import{s as m,v as f,y as C,C as N,f as M,x as A}from"./index.js";import{d as L}from"./taxPresetsService.js";const U=e=>{if(!e)return null;if(e instanceof Date)return e;if(typeof e=="object"&&e){if("toDate"in e&&typeof e.toDate=="function")try{return e.toDate()}catch(t){return console.warn("Failed to convert timestamp to Date:",t),null}if("seconds"in e&&"nanoseconds"in e)try{return new Date(e.seconds*1e3+e.nanoseconds/1e6)}catch(t){return console.warn("Failed to convert timestamp to Date:",t),null}}if(typeof e=="string")try{if(/^\d{4}-\d{2}-\d{2}$/.test(e)){const[o,n,a]=e.split("-").map(Number),i=new Date(o,n-1,a);return isNaN(i.getTime())?null:i}const t=new Date(e);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to parse date string:",e,t),null}if(typeof e=="number")try{const t=new Date(e);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to convert number to Date:",e,t),null}return null},G=(e,t="Unknown",o)=>{const n=U(e);if(!n)return t;try{const i={...{year:"numeric",month:"short",day:"numeric"},...o};return n.toLocaleDateString("en-US",i)}catch(a){return console.warn("Failed to format date:",e,a),t}},K=(e,t="$0.00")=>{const o=typeof e=="string"?parseFloat(e):e;return isNaN(o)?t:o.toLocaleString("en-US",{style:"currency",currency:"USD",minimumFractionDigits:2,maximumFractionDigits:2})},q=e=>{if(!e)return"";if(typeof e=="string"&&/^\d{4}-\d{2}-\d{2}$/.test(e))return e;const t=U(e);if(!t)return"";const o=t.getFullYear(),n=String(t.getMonth()+1).padStart(2,"0"),a=String(t.getDate()).padStart(2,"0");return`${o}-${n}-${a}`},w={async appendItemLineageEdge(e,t,o,n,a){if(await f(),o===n)return console.log("â­ï¸ Skipping lineage edge: from === to",{itemId:t,fromTransactionId:o,toTransactionId:n}),null;const i=await C(),c=(i==null?void 0:i.id)||null,r=new Date(Date.now()-5e3).toISOString(),{data:s}=await m.from("item_lineage_edges").select("id, created_at").eq("account_id",e).eq("item_id",t).eq("from_transaction_id",o??null).eq("to_transaction_id",n??null).gte("created_at",r).order("created_at",{ascending:!1}).limit(1);if(s&&s.length>0)return console.log("â­ï¸ Skipping duplicate lineage edge (recent match found)",{itemId:t,fromTransactionId:o,toTransactionId:n,existingEdgeId:s[0].id}),await this.getLineageEdgeById(s[0].id);const{data:d,error:l}=await m.from("item_lineage_edges").insert({account_id:e,item_id:t,from_transaction_id:o??null,to_transaction_id:n??null,created_by:c,note:a??null}).select().single();if(l){if((l==null?void 0:l.code)==="PGRST205"||(l==null?void 0:l.status)===404||typeof(l==null?void 0:l.message)=="string"&&l.message.includes("Could not find the table"))return console.warn("âš ï¸ Lineage table not found / PostgREST schema cache issue. Lineage writes are non-fatal while the migration is pending."),console.warn("Read dev_docs/troubleshooting/transaction-lineage-troubleshooting.md for diagnostic steps and remediation."),console.debug("Lineage append error details:",l),null;throw console.error("âŒ Failed to append lineage edge:",l),l}return console.log("âœ… Lineage edge appended:",{itemId:t,fromTransactionId:o,toTransactionId:n,edgeId:d.id}),this._convertEdgeFromDb(d)},async updateItemLineagePointers(e,t,o,n){await f();const a={latest_transaction_id:o??null};if(n!==void 0){const{data:c}=await m.from("items").select("origin_transaction_id").eq("account_id",e).eq("item_id",t).single();!(c!=null&&c.origin_transaction_id)&&n&&(a.origin_transaction_id=n)}const{error:i}=await m.from("items").update(a).eq("account_id",e).eq("item_id",t);if(i)throw console.error("âŒ Failed to update item lineage pointers:",i),i;console.log("âœ… Updated item lineage pointers:",{itemId:t,latestTransactionId:o,originTransactionId:a.origin_transaction_id})},async getItemLineageHistory(e,t){await f();const{data:o,error:n}=await m.from("item_lineage_edges").select("*").eq("account_id",t).eq("item_id",e).order("created_at",{ascending:!0});if(n)throw console.error("âŒ Failed to fetch item lineage history:",n),n;return(o||[]).map(a=>this._convertEdgeFromDb(a))},async getEdgesFromTransaction(e,t){await f();const{data:o,error:n}=await m.from("item_lineage_edges").select("*").eq("account_id",t).eq("from_transaction_id",e).order("created_at",{ascending:!0});if(n)throw console.error("âŒ Failed to fetch edges from transaction:",n),n;return(o||[]).map(a=>this._convertEdgeFromDb(a))},async getLineageEdgeById(e){await f();const{data:t,error:o}=await m.from("item_lineage_edges").select("*").eq("id",e).single();if(o){if(o.code==="PGRST116")return null;throw console.error("âŒ Failed to fetch lineage edge:",o),o}return t?this._convertEdgeFromDb(t):null},subscribeToItemLineageForItem(e,t,o){const n=[`account_id=eq.${e}`];t&&n.push(`item_id=eq.${t}`);const a=n.join(","),i=`item_lineage:${e}${t?`:${t}`:""}`,c=m.channel(i).on("postgres_changes",{event:"INSERT",schema:"public",table:"item_lineage_edges",filter:a},r=>{try{const s=this._convertEdgeFromDb(r.new);o(s)}catch(s){console.debug("lineageService.subscribeToItemLineageForItem - callback error",s)}}).subscribe((r,s)=>{r==="SUBSCRIBED"&&console.log("Subscribed to item_lineage_edges channel",i),s&&console.error("Error subscribing to item_lineage_edges channel",s)});return()=>{try{c.unsubscribe()}catch(r){console.debug("Failed to unsubscribe from lineage channel",r)}}},subscribeToEdgesFromTransaction(e,t,o){const n=`account_id=eq.${e},from_transaction_id=eq.${t}`,a=`item_lineage:from_tx:${e}:${t}`,i=m.channel(a).on("postgres_changes",{event:"INSERT",schema:"public",table:"item_lineage_edges",filter:n},c=>{try{const r=this._convertEdgeFromDb(c.new);o(r)}catch(r){console.debug("lineageService.subscribeToEdgesFromTransaction - callback error",r)}}).subscribe((c,r)=>{c==="SUBSCRIBED"&&console.log("Subscribed to item_lineage_edges from_transaction channel",a),r&&console.error("Error subscribing to item_lineage_edges from_transaction channel",r)});return()=>{try{i.unsubscribe()}catch(c){console.debug("Failed to unsubscribe from lineage from_tx channel",c)}}},_convertEdgeFromDb(e){return{id:e.id,accountId:e.account_id,itemId:e.item_id,fromTransactionId:e.from_transaction_id??null,toTransactionId:e.to_transaction_id??null,createdAt:e.created_at,createdBy:e.created_by??null,note:e.note??null}}},P={async logAllocationEvent(e,t,o,n,a,i){try{let c=null,r={};typeof a=="string"?(c=a,r=i||{}):(c=null,r=a||{});const{error:s}=await m.from("item_audit_logs").insert({account_id:e,event_type:t,item_id:o,project_id:n,transaction_id:c,details:r,timestamp:new Date().toISOString(),created_at:new Date().toISOString()});s?console.warn("âš ï¸ Failed to log audit event (non-critical):",s):console.log(`ðŸ“‹ Audit logged: ${t} for item ${o}`)}catch(c){console.warn("âš ï¸ Failed to log audit event (non-critical):",c)}},async logTransactionStateChange(e,t,o,n,a){try{const{error:i}=await m.from("transaction_audit_logs").insert({account_id:e,transaction_id:t,change_type:o,old_state:n||null,new_state:a||null,timestamp:new Date().toISOString(),created_at:new Date().toISOString()});i?console.warn("âš ï¸ Failed to log transaction audit (non-critical):",i):console.log(`ðŸ“‹ Transaction audit logged: ${o} for ${t}`)}catch(i){console.warn("âš ï¸ Failed to log transaction audit (non-critical):",i)}}},D={async getProjects(e){await f();const{data:t,error:o}=await m.from("projects").select("*").eq("account_id",e).order("updated_at",{ascending:!1});if(o)throw o;return(t||[]).map(n=>{const a=A(n);return{id:a.id,accountId:a.account_id,name:a.name,description:a.description||"",clientName:a.client_name||"",budget:a.budget?parseFloat(a.budget):void 0,designFee:a.design_fee?parseFloat(a.design_fee):void 0,budgetCategories:a.budget_categories||void 0,createdAt:a.created_at,updatedAt:a.updated_at,createdBy:a.created_by,settings:a.settings||void 0,metadata:a.metadata||void 0,itemCount:a.item_count||0,transactionCount:a.transaction_count||0,totalValue:a.total_value?parseFloat(a.total_value):0}})},async getProject(e,t){await f();const{data:o,error:n}=await m.from("projects").select("*").eq("id",t).eq("account_id",e).single();if(n){if(n.code==="PGRST116")return null;throw n}if(!o)return null;const a=A(o);return{id:a.id,accountId:a.account_id,name:a.name,description:a.description||"",clientName:a.client_name||"",budget:a.budget?parseFloat(a.budget):void 0,designFee:a.design_fee?parseFloat(a.design_fee):void 0,budgetCategories:a.budget_categories||void 0,createdAt:a.created_at,updatedAt:a.updated_at,createdBy:a.created_by,settings:a.settings||void 0,metadata:a.metadata||void 0,itemCount:a.item_count||0,transactionCount:a.transaction_count||0,totalValue:a.total_value?parseFloat(a.total_value):0}},async createProject(e,t){await f();const{data:o,error:n}=await m.from("projects").insert({account_id:e,name:t.name,description:t.description||null,client_name:t.clientName||null,budget:t.budget||null,design_fee:t.designFee||null,budget_categories:t.budgetCategories||{},settings:t.settings||{},metadata:t.metadata||{},created_by:t.createdBy,item_count:0,transaction_count:0,total_value:0,created_at:new Date().toISOString(),updated_at:new Date().toISOString()}).select("id").single();if(n)throw n;return o.id},async updateProject(e,t,o){await f();const n={updated_at:new Date().toISOString()};o.name!==void 0&&(n.name=o.name),o.description!==void 0&&(n.description=o.description),o.clientName!==void 0&&(n.client_name=o.clientName),o.budget!==void 0&&(n.budget=o.budget),o.designFee!==void 0&&(n.design_fee=o.designFee),o.budgetCategories!==void 0&&(n.budget_categories=o.budgetCategories),o.settings!==void 0&&(n.settings=o.settings),o.metadata!==void 0&&(n.metadata=o.metadata);const{error:a}=await m.from("projects").update(n).eq("id",t).eq("account_id",e);if(a)throw a},async deleteProject(e,t){await f();const{error:o}=await m.from("projects").delete().eq("id",t).eq("account_id",e);if(o)throw o},subscribeToProjects(e,t,o){let n=[...o||[]];const a=m.channel(`projects:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"projects",filter:`account_id=eq.${e}`},i=>{console.log("Projects change received!",i);const{eventType:c,new:r,old:s}=i;if(c==="INSERT")n=[D._convertProjectFromDb(r),...n];else if(c==="UPDATE"){const d=D._convertProjectFromDb(r);n=n.map(l=>l.id===d.id?d:l)}else if(c==="DELETE"){const d=s.id;n=n.filter(l=>l.id!==d)}t([...n])}).subscribe((i,c)=>{i==="SUBSCRIBED"&&console.log("Subscribed to projects channel"),c&&console.error("Error subscribing to projects channel:",c)});return()=>{a.unsubscribe()}},_convertProjectFromDb(e){const t=A(e);return{id:t.id,accountId:t.account_id,name:t.name,description:t.description||"",clientName:t.client_name||"",budget:t.budget?parseFloat(t.budget):void 0,designFee:t.design_fee?parseFloat(t.design_fee):void 0,budgetCategories:t.budget_categories||void 0,createdAt:t.created_at,updatedAt:t.updated_at,createdBy:t.created_by,settings:t.settings||void 0,metadata:t.metadata||void 0,itemCount:t.item_count||0,transactionCount:t.transaction_count||0,totalValue:t.total_value?parseFloat(t.total_value):0}}};function I(e){const t=A(e);return{transactionId:t.transaction_id,projectId:t.project_id||void 0,projectName:t.project_name||void 0,transactionDate:t.transaction_date,source:t.source||"",transactionType:t.transaction_type||"",paymentMethod:t.payment_method||"",amount:t.amount||"0.00",budgetCategory:t.budget_category||void 0,categoryId:t.category_id||void 0,notes:t.notes||void 0,transactionImages:Array.isArray(t.transaction_images)?t.transaction_images:[],receiptImages:Array.isArray(t.receipt_images)?t.receipt_images:[],otherImages:Array.isArray(t.other_images)?t.other_images:[],receiptEmailed:t.receipt_emailed||!1,createdAt:t.created_at,createdBy:t.created_by||"",status:t.status||"completed",reimbursementType:t.reimbursement_type||void 0,triggerEvent:t.trigger_event||void 0,itemIds:Array.isArray(t.item_ids)?t.item_ids:[],taxRatePreset:t.tax_rate_preset||void 0,taxRatePct:t.tax_rate_pct?parseFloat(t.tax_rate_pct):void 0,subtotal:t.subtotal||void 0,needsReview:t.needs_review===!0,sumItemPurchasePrices:t.sum_item_purchase_prices!==void 0?String(t.sum_item_purchase_prices):"0.00"}}async function T(e,t,o){if([...new Set(t.map(i=>i.projectId).filter(i=>!!i))].length===0)return t;const a=new Map;try{(await D.getProjects(e)).forEach(c=>{a.set(c.id,c.name)})}catch(i){console.warn("Failed to fetch projects for transaction enrichment:",i)}return t.map(i=>{if(i.projectId&&!i.projectName){const c=a.get(i.projectId);if(c)return{...i,projectName:c}}return i})}function B(e){const t={};return e.transactionId!==void 0&&(t.transaction_id=e.transactionId),e.projectId!==void 0&&(t.project_id=e.projectId??null),e.transactionDate!==void 0&&(t.transaction_date=e.transactionDate),e.source!==void 0&&(t.source=e.source),e.transactionType!==void 0&&(t.transaction_type=e.transactionType),e.paymentMethod!==void 0&&(t.payment_method=e.paymentMethod),e.amount!==void 0&&(t.amount=e.amount),e.budgetCategory!==void 0&&(t.budget_category=e.budgetCategory),e.categoryId!==void 0&&(t.category_id=e.categoryId??null),e.notes!==void 0&&(t.notes=e.notes),e.transactionImages!==void 0&&(t.transaction_images=e.transactionImages),e.receiptImages!==void 0&&(t.receipt_images=e.receiptImages),e.otherImages!==void 0&&(t.other_images=e.otherImages),e.receiptEmailed!==void 0&&(t.receipt_emailed=e.receiptEmailed),e.createdAt!==void 0&&(t.created_at=e.createdAt),e.createdBy!==void 0&&(t.created_by=e.createdBy),e.status!==void 0&&(t.status=e.status),e.reimbursementType!==void 0&&(t.reimbursement_type=e.reimbursementType),e.triggerEvent!==void 0&&(t.trigger_event=e.triggerEvent),e.itemIds!==void 0&&(t.item_ids=e.itemIds),e.taxRatePreset!==void 0&&(t.tax_rate_preset=e.taxRatePreset),e.taxRatePct!==void 0&&(t.tax_rate_pct=e.taxRatePct),e.subtotal!==void 0&&(t.subtotal=e.subtotal),e.needsReview!==void 0&&(t.needs_review=e.needsReview),e.sumItemPurchasePrices!==void 0&&(t.sum_item_purchase_prices=e.sumItemPurchasePrices),t}async function O(e,t,o){await f();const{data:n,error:a}=await m.from("transactions").select("sum_item_purchase_prices").eq("account_id",e).eq("transaction_id",t).single();if(a)throw a;const i=n&&n.sum_item_purchase_prices||"0",c=parseFloat(String(i)||"0"),r=parseFloat(String(o)||"0"),d=(c+r).toFixed(2),{error:l}=await m.from("transactions").update({sum_item_purchase_prices:d}).eq("account_id",e).eq("transaction_id",t);if(l)throw l;return d}const j={async adjustSumItemPurchasePrices(e,t,o){return await O(e,t,o)},async notifyTransactionChanged(e,t,o){if(o&&o.deltaSum!==void 0)try{await O(e,t,o.deltaSum)}catch(a){console.warn("notifyTransactionChanged - failed to adjust sum_item_purchase_prices:",a)}const n=o&&o.flushImmediately?0:void 0;try{n===0?this._enqueueRecomputeNeedsReview(e,null,t,0).catch(a=>{console.warn("Failed to recompute needs_review in notifyTransactionChanged (immediate):",a)}):this._enqueueRecomputeNeedsReview(e,null,t).catch(a=>{console.warn("Failed to recompute needs_review in notifyTransactionChanged:",a)})}catch(a){console.warn("notifyTransactionChanged - enqueue failed:",a)}},async getTransactions(e,t){await f();const{data:o,error:n}=await m.from("transactions").select("*").eq("account_id",e).eq("project_id",t).order("created_at",{ascending:!1});if(n)throw n;const a=(o||[]).map(i=>I(i));return await T(e,a)},async getTransactionsForProjects(e,t,o){if(await f(),t.length===0)return[];const{data:n,error:a}=await m.from("transactions").select("*").eq("account_id",e).in("project_id",t).order("created_at",{ascending:!1});if(a)throw a;const i=(n||[]).map(c=>I(c));return await T(e,i)},async getTransaction(e,t,o){await f();const{data:n,error:a}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",o).single();if(a){if(a.code==="PGRST116")return null;throw a}if(!n)return null;const i=I(n);return(await T(e,[i]))[0]||null},async getTransactionById(e,t){await f();const{data:o,error:n}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",t).single();if(n||!o)return{transaction:null,projectId:null};const a=A(o),i=I(o);return{transaction:(await T(e,[i]))[0]||i,projectId:a.project_id||null}},async getTransactionCompleteness(e,t,o){await f();const[n,a]=await Promise.all([this.getTransaction(e,t,o),S.getItemsForTransaction(e,t,o)]);if(!n)throw new Error("Transaction not found");let i=a.slice();try{const v=await w.getEdgesFromTransaction(o,e),x=Array.from(new Set(v.map(F=>F.itemId))).filter(F=>!i.some(R=>R.itemId===F));if(x.length>0){const F=x.map($=>S.getItemById(e,$)),k=(await Promise.all(F)).filter($=>$!==null);i=i.concat(k)}}catch(v){console.debug("getTransactionCompleteness - failed to fetch lineage edges:",v)}const c=i.reduce((v,E)=>{const x=parseFloat(E.purchasePrice||"0");return v+(isNaN(x)?0:x)},0),r=i.length,s=i.filter(v=>{const E=v.purchasePrice;return!E||E.trim()===""||parseFloat(E)===0}).length,d=parseFloat(n.amount||"0");let l=0,u,_,p=!1;if(n.subtotal)l=parseFloat(n.subtotal);else if(n.taxRatePct!==void 0&&n.taxRatePct!==null){const v=n.taxRatePct/100;l=d/(1+v),u=d-l,l=Math.round(l*100)/100,u=Math.round(u*100)/100}else l=d,p=!0;const h=l>0?c/l:(r>0,0),g=c-l,y=l>0?g/l*100:r>0?-100:0,b=this._calculateCompletenessStatus(h,y);return{itemsNetTotal:Math.round(c*100)/100,itemsCount:r,itemsMissingPriceCount:s,transactionSubtotal:Math.round(l*100)/100,completenessRatio:h,completenessStatus:b,missingTaxData:p,inferredTax:u,taxAmount:_,varianceDollars:Math.round(g*100)/100,variancePercent:Math.round(y*100)/100}},_calculateCompletenessStatus(e,t){return e>1.2?"over":Math.abs(t)>20?"incomplete":Math.abs(t)>1?"near":"complete"},async _recomputeNeedsReview(e,t,o){try{const a=(await this.getTransactionCompleteness(e,t||"",o)).completenessStatus!=="complete";await f();const i={needs_review:a,updated_at:new Date().toISOString()},{error:c}=await m.from("transactions").update(i).eq("account_id",e).eq("transaction_id",o);c?console.warn("Failed to persist needs_review for transaction",o,c):console.log(`Recomputed needs_review=${a} for transaction ${o}`)}catch(n){console.warn("Failed to recompute needs_review for transaction",o,n)}},_needsReviewTimers:{},_ongoingNeedsReviewPromises:{},_enqueueCounts:{},_needsReviewDirty:{},_batchCounters:{},beginNeedsReviewBatch(e,t){const o=`${e}:${t}`;this._batchCounters[o]=(this._batchCounters[o]||0)+1},_isBatchActive(e,t){const o=`${e}:${t}`;return(this._batchCounters[o]||0)>0},async flushNeedsReviewBatch(e,t,o){const n=`${e}:${t}`,a=(this._batchCounters[n]||0)-1;if(a<=0){delete this._batchCounters[n];try{let i=null;try{await f();const{data:c}=await m.from("transactions").select("project_id").eq("account_id",e).eq("transaction_id",t).single();i=(c==null?void 0:c.project_id)??null}catch{}o!=null&&o.flushImmediately?this._enqueueRecomputeNeedsReview(e,i,t,0).catch(c=>{console.warn("Failed to recompute needs_review in flushNeedsReviewBatch:",c)}):this._enqueueRecomputeNeedsReview(e,i,t).catch(c=>{console.warn("Failed to recompute needs_review in flushNeedsReviewBatch:",c)})}catch(i){console.warn("Failed during flushNeedsReviewBatch:",i)}}else this._batchCounters[n]=a},_enqueueRecomputeNeedsReview(e,t,o,n=1e3){const a=`${e}:${o}`;if(this._ongoingNeedsReviewPromises[a]){try{this._needsReviewDirty[a]=!0}catch{}return this._ongoingNeedsReviewPromises[a]}if(this._needsReviewTimers[a]){const s=new Promise((d,l)=>{const u=setInterval(()=>{!this._needsReviewTimers[a]&&!this._ongoingNeedsReviewPromises[a]&&(clearInterval(u),d())},50)});return this._ongoingNeedsReviewPromises[a]=s,s}try{this._enqueueCounts[a]=(this._enqueueCounts[a]||0)+1;const s=this._enqueueCounts[a],l=(new Error().stack||"").split(`
`).slice(2,6).join(" | ");console.debug(`[needs_review] enqueue requested for ${o} count=${s} ts=${new Date().toISOString()} caller=${l}`)}catch{}let i=null,c=null;const r=new Promise((s,d)=>{i=s,c=d});return this._ongoingNeedsReviewPromises[a]=r,this._needsReviewTimers[a]=setTimeout(async()=>{try{await this._recomputeNeedsReview(e,t,o),i&&i()}catch(s){c&&c(s)}finally{this._needsReviewTimers[a]&&clearTimeout(this._needsReviewTimers[a]),delete this._needsReviewTimers[a],delete this._ongoingNeedsReviewPromises[a];try{delete this._enqueueCounts[a]}catch{}try{this._needsReviewDirty[a]&&(delete this._needsReviewDirty[a],setTimeout(()=>{try{this._enqueueRecomputeNeedsReview(e,t,o,25).catch(s=>{console.warn("Failed trailing recompute needs_review:",s)})}catch(s){console.warn("Failed scheduling trailing recompute:",s)}},25))}catch{}}},n),r},async getSuggestedItemsForTransaction(e,t,o=5){await f();const{data:n,error:a}=await m.from("items").select("*").eq("account_id",e).eq("source",t).is("transaction_id",null).order("date_created",{ascending:!1}).limit(o);if(a)throw a;return(n||[]).map(i=>S._convertItemFromDb(i))},async createTransaction(e,t,o,n){try{await f();const a=await C();if(!(o.createdBy||(a==null?void 0:a.id)||null))throw new Error("User must be authenticated to create transactions");const c=new Date,r=crypto.randomUUID(),s=B({...o,transactionId:r,createdAt:c.toISOString()});if(s.account_id=e,s.created_at=c.toISOString(),s.updated_at=c.toISOString(),s.status||(s.status="completed"),s.category_id){const{data:l,error:u}=await m.from("budget_categories").select("id, account_id").eq("id",s.category_id).eq("account_id",e).single();if(u||!l)throw new Error(`Category ID '${s.category_id}' not found or does not belong to this account.`)}if(console.log("Creating transaction:",s),console.log("Transaction items:",n),s.tax_rate_preset)if(s.tax_rate_preset==="Other"){const l=parseFloat(s.amount||"0"),u=parseFloat(s.subtotal||"0");if(isNaN(u)||u<=0)throw new Error("Subtotal must be greater than 0 when Tax Rate Preset is Other.");if(isNaN(l)||l<u)throw new Error("Subtotal cannot exceed the total amount.");const _=(l-u)/u*100;s.tax_rate_pct=Math.round(_*1e4)/1e4}else{const l=await L(e,s.tax_rate_preset);if(!l)throw new Error(`Tax preset with ID '${s.tax_rate_preset}' not found.`);s.tax_rate_pct=l.rate,s.subtotal=null}const{error:d}=await m.from("transactions").insert(s);if(d)throw d;if(console.log("Transaction created successfully:",r),n&&n.length>0){console.log("Creating items for transaction:",r);const l=n.map(_=>({..._})),u=await S.createTransactionItems(e,t||"",r,o.transactionDate,o.source,l,s.tax_rate_pct);console.log("Created items:",u)}try{this._enqueueRecomputeNeedsReview(e,t,r).catch(l=>{console.warn("Failed to set needs_review after transaction creation:",l)})}catch(l){console.warn("Failed to set needs_review after transaction creation:",l)}return r}catch(a){throw console.error("Error creating transaction:",a),a}},async updateTransaction(e,t,o,n){await f();const a={...n};if(a.status==="completed"&&a.reimbursementType!==void 0&&(a.reimbursementType=null),a.reimbursementType===""&&(a.reimbursementType=null),a.reimbursementType&&a.status==="completed"&&(a.status="pending"),a.taxRatePreset!==void 0)if(a.taxRatePreset==="Other"){const{data:r}=await m.from("transactions").select("amount, subtotal").eq("account_id",e).eq("transaction_id",o).single(),s=r,d=a.amount!==void 0?parseFloat(a.amount):parseFloat((s==null?void 0:s.amount)||"0"),l=a.subtotal!==void 0?parseFloat(a.subtotal):parseFloat((s==null?void 0:s.subtotal)||"0");if(!isNaN(d)&&!isNaN(l)&&l>0&&d>=l){const u=(d-l)/l*100;a.taxRatePct=Math.round(u*1e4)/1e4}}else try{const r=await L(e,a.taxRatePreset);r?(a.taxRatePct=r.rate,a.subtotal=void 0):console.warn(`Tax preset with ID '${a.taxRatePreset}' not found during update`)}catch(r){console.warn("Tax preset lookup failed during update:",r)}const i=B(a);if(i.category_id!==void 0&&i.category_id!==null){const{data:r,error:s}=await m.from("budget_categories").select("id, account_id").eq("id",i.category_id).eq("account_id",e).single();if(s||!r)throw new Error(`Category ID '${i.category_id}' not found or does not belong to this account.`)}i.updated_at=new Date().toISOString();const{error:c}=await m.from("transactions").update(i).eq("account_id",e).eq("transaction_id",o);if(c)throw c;if(a.taxRatePct!==void 0)try{const r=await S.getItemsForTransaction(e,t,o);if(r&&r.length>0)for(const s of r)await S.updateItem(e,s.itemId,{taxRatePct:a.taxRatePct})}catch(r){console.warn("Failed to propagate tax_rate_pct to items:",r)}a.needsReview===void 0&&this._enqueueRecomputeNeedsReview(e,t,o).catch(r=>{console.warn("Failed to recompute needs_review after transaction update:",r)})},async deleteTransaction(e,t,o){await f();const{error:n}=await m.from("transactions").delete().eq("account_id",e).eq("transaction_id",o);if(n)throw n},subscribeToTransactions(e,t,o,n){let a=[...n||[]];const i=m.channel(`transactions:${e}:${t}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e}`},async c=>{console.log("Transactions change received (account scope)!",c);const{eventType:r,new:s,old:d}=c,l=(s==null?void 0:s.project_id)??null,u=(d==null?void 0:d.project_id)??null,_=h=>h===t;if(r==="INSERT"){if(_(l)){const h=I(s),[g]=await T(e,[h]);a=[g,...a.filter(y=>y.transactionId!==g.transactionId)]}}else if(r==="UPDATE"){const h=I(s),[g]=await T(e,[h]),y=a.some(v=>v.transactionId===g.transactionId),b=_(l);b&&!y?a=[g,...a]:!b&&y?a=a.filter(v=>v.transactionId!==g.transactionId):b&&y&&(a=a.map(v=>v.transactionId===g.transactionId?g:v))}else if(r==="DELETE"&&_(u)){const h=d.transaction_id;a=a.filter(g=>g.transactionId!==h)}const p=[...a].sort((h,g)=>new Date(g.createdAt).getTime()-new Date(h.createdAt).getTime());o(p)}).subscribe((c,r)=>{c==="SUBSCRIBED"&&console.log("Subscribed to transactions channel"),r&&console.error("Error subscribing to transactions channel:",r)});return()=>{i.unsubscribe()}},subscribeToAllTransactions(e,t,o){let n=[...o||[]];const a=m.channel(`transactions:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e}`},async i=>{console.log("All transactions change received!",i);const{eventType:c,new:r,old:s}=i;if(c==="INSERT"){const l=I(r),[u]=await T(e,[l]);n=[u,...n.filter(_=>_.transactionId!==u.transactionId)]}else if(c==="UPDATE"){const l=I(r),[u]=await T(e,[l]);n=n.map(_=>_.transactionId===u.transactionId?u:_)}else if(c==="DELETE"){const l=s.transaction_id;n=n.filter(u=>u.transactionId!==l)}const d=[...n].sort((l,u)=>new Date(u.createdAt).getTime()-new Date(l.createdAt).getTime());t(d)}).subscribe((i,c)=>{i==="SUBSCRIBED"&&console.log("Subscribed to all transactions channel"),c&&console.error("Error subscribing to all transactions channel:",c)});return()=>{a.unsubscribe()}},subscribeToTransaction(e,t,o,n){const a=m.channel(`transaction:${e}:${o}`).on("postgres_changes",{event:"*",schema:"public",table:"transactions",filter:`account_id=eq.${e} AND transaction_id=eq.${o}`},async()=>{try{const{data:c,error:r}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",o).single();if(r){if(r.code==="PGRST116"){n(null);return}console.error("Error fetching transaction in subscription:",r);return}if(c){const s=I(c),d=await T(e,[s]);n(d[0]||null)}else n(null)}catch(c){console.error("Error in transaction subscription callback:",c)}}).subscribe();return(async()=>{try{const{data:c,error:r}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",o).single();if(r){if(r.code==="PGRST116"){n(null);return}console.error("Error fetching initial transaction:",r);return}if(c){const s=I(c),d=await T(e,[s]);n(d[0]||null)}else n(null)}catch(c){console.error("Error in initial transaction fetch:",c)}})(),()=>{a.unsubscribe()}},async getPendingTransactions(e,t){await f();const{data:o,error:n}=await m.from("transactions").select("*").eq("account_id",e).eq("project_id",t).eq("status","pending").order("created_at",{ascending:!1});if(n)throw n;const a=(o||[]).map(i=>I(i));return await T(e,a)},async updateTransactionStatus(e,t,o,n,a){await f();const i={status:n,updated_at:new Date().toISOString()};a&&(a.transactionDate!==void 0&&(i.transaction_date=a.transactionDate),a.paymentMethod!==void 0&&(i.payment_method=a.paymentMethod),a.amount!==void 0&&(i.amount=a.amount),a.notes!==void 0&&(i.notes=a.notes)),n==="completed"&&!(a!=null&&a.transactionDate)&&(i.transaction_date=q(new Date));const{error:c}=await m.from("transactions").update(i).eq("account_id",e).eq("transaction_id",o);if(c)throw c},async getInventoryRelatedTransactions(e){await f();const{data:t,error:o}=await m.from("transactions").select("*").eq("account_id",e).in("reimbursement_type",[M,N]).order("created_at",{ascending:!1});if(o)throw o;const n=(t||[]).map(a=>I(a));return await T(e,n)},async getBusinessInventoryTransactions(e){await f();const{data:t,error:o}=await m.from("transactions").select("*").eq("account_id",e).is("project_id",null).order("created_at",{ascending:!1});if(o)throw o;const n=(t||[]).map(a=>I(a));return await T(e,n)}},S={_convertItemFromDb(e){const t=A(e);return{itemId:t.item_id,accountId:t.account_id,projectId:t.project_id||void 0,transactionId:t.transaction_id||void 0,previousProjectTransactionId:t.previous_project_transaction_id??null,previousProjectId:t.previous_project_id??null,name:t.name||void 0,description:t.description||"",sku:t.sku||"",source:t.source||"",purchasePrice:t.purchase_price||void 0,projectPrice:t.project_price||void 0,marketValue:t.market_value||void 0,paymentMethod:t.payment_method||"",disposition:t.disposition||void 0,notes:t.notes||void 0,space:t.space||void 0,qrKey:t.qr_key||"",bookmark:t.bookmark||!1,dateCreated:t.date_created||"",lastUpdated:t.last_updated?typeof t.last_updated=="string"?t.last_updated:t.last_updated.toISOString():"",images:Array.isArray(t.images)?t.images:[],inventoryStatus:t.inventory_status||void 0,businessInventoryLocation:t.business_inventory_location||void 0,taxRatePct:t.tax_rate_pct?parseFloat(t.tax_rate_pct):void 0,taxAmount:t.tax_amount||void 0,taxAmountPurchasePrice:t.tax_amount_purchase_price||void 0,taxAmountProjectPrice:t.tax_amount_project_price||void 0,createdBy:t.created_by||void 0,createdAt:t.created_at,originTransactionId:t.origin_transaction_id??null,latestTransactionId:t.latest_transaction_id??null}},_convertItemToDb(e){const t={};return e.itemId!==void 0&&(t.item_id=e.itemId),e.accountId!==void 0&&(t.account_id=e.accountId),e.projectId!==void 0&&(t.project_id=e.projectId??null),e.transactionId!==void 0&&(t.transaction_id=e.transactionId??null),e.previousProjectTransactionId!==void 0&&(t.previous_project_transaction_id=e.previousProjectTransactionId??null),e.previousProjectId!==void 0&&(t.previous_project_id=e.previousProjectId??null),e.name!==void 0&&(t.name=e.name),e.description!==void 0&&(t.description=e.description),e.sku!==void 0&&(t.sku=e.sku),e.source!==void 0&&(t.source=e.source),e.purchasePrice!==void 0&&(t.purchase_price=e.purchasePrice),e.projectPrice!==void 0&&(t.project_price=e.projectPrice),e.marketValue!==void 0&&(t.market_value=e.marketValue),e.paymentMethod!==void 0&&(t.payment_method=e.paymentMethod),e.disposition!==void 0&&(t.disposition=e.disposition),e.notes!==void 0&&(t.notes=e.notes),e.space!==void 0&&(t.space=e.space),e.qrKey!==void 0&&(t.qr_key=e.qrKey),e.bookmark!==void 0&&(t.bookmark=e.bookmark),e.dateCreated!==void 0&&(t.date_created=e.dateCreated),e.lastUpdated!==void 0&&(t.last_updated=e.lastUpdated),e.images!==void 0&&(t.images=e.images),e.inventoryStatus!==void 0&&(t.inventory_status=e.inventoryStatus),e.businessInventoryLocation!==void 0&&(t.business_inventory_location=e.businessInventoryLocation),e.taxRatePct!==void 0&&(t.tax_rate_pct=e.taxRatePct),e.taxAmount!==void 0&&(t.tax_amount=e.taxAmount),e.taxAmountPurchasePrice!==void 0&&(t.tax_amount_purchase_price=e.taxAmountPurchasePrice),e.taxAmountProjectPrice!==void 0&&(t.tax_amount_project_price=e.taxAmountProjectPrice),e.createdBy!==void 0&&(t.created_by=e.createdBy),e.createdAt!==void 0&&(t.created_at=e.createdAt),e.originTransactionId!==void 0&&(t.origin_transaction_id=e.originTransactionId??null),e.latestTransactionId!==void 0&&(t.latest_transaction_id=e.latestTransactionId??null),t},async getItemsByProject(e,t,o,n){await f();let a=m.from("items").select("*").eq("account_id",e).eq("project_id",t);if(o!=null&&o.status&&(a=a.eq("disposition",o.status)),o!=null&&o.category&&(a=a.eq("source",o.category)),o!=null&&o.priceRange&&(a=a.gte("project_price",o.priceRange.min.toString()),a=a.lte("project_price",o.priceRange.max.toString())),o!=null&&o.searchQuery&&(a=a.or(`description.ilike.%${o.searchQuery}%,source.ilike.%${o.searchQuery}%,sku.ilike.%${o.searchQuery}%,payment_method.ilike.%${o.searchQuery}%`)),a=a.order("last_updated",{ascending:!1}),n){const r=n.page>0?(n.page-1)*n.limit:0;a=a.range(r,r+n.limit-1)}const{data:i,error:c}=await a;if(c)throw c;return(i||[]).map(r=>this._convertItemFromDb(r))},subscribeToProjectItems(e,t,o,n){let a=[...n||[]];const i=m.channel(`project-items:${e}:${t}`).on("postgres_changes",{event:"*",schema:"public",table:"items",filter:`account_id=eq.${e}`},c=>{console.log("Project items change received (broad filter)!",c);const{eventType:r,new:s,old:d}=c;if(r==="INSERT")s.project_id===t&&(a=[this._convertItemFromDb(s),...a]);else if(r==="UPDATE"){const l=this._convertItemFromDb(s),u=a.some(p=>p.itemId===l.itemId),_=l.projectId===t;_&&!u?a=[l,...a]:!_&&u?a=a.filter(p=>p.itemId!==l.itemId):_&&u&&(a=a.map(p=>p.itemId===l.itemId?l:p))}else if(r==="DELETE"){const l=d.item_id;a=a.filter(u=>u.itemId!==l)}o([...a])}).subscribe((c,r)=>{c==="SUBSCRIBED"&&console.log("Subscribed to project items channel"),r&&console.error("Error subscribing to project items channel:",r)});return()=>{i.unsubscribe()}},async getBusinessInventoryItems(e,t,o){await f();let n=m.from("items").select("*").eq("account_id",e).is("project_id",null);if(t!=null&&t.status&&(n=n.eq("inventory_status",t.status)),t!=null&&t.searchQuery&&(n=n.or(`description.ilike.%${t.searchQuery}%,source.ilike.%${t.searchQuery}%,sku.ilike.%${t.searchQuery}%,business_inventory_location.ilike.%${t.searchQuery}%`)),n=n.order("last_updated",{ascending:!1}),o){const c=o.page>0?(o.page-1)*o.limit:0;n=n.range(c,c+o.limit-1)}const{data:a,error:i}=await n;if(i)throw i;return(a||[]).map(c=>this._convertItemFromDb(c))},subscribeToBusinessInventory(e,t,o,n){let a=[...n||[]];const i=m.channel(`business-inventory:${e}`).on("postgres_changes",{event:"*",schema:"public",table:"items",filter:`account_id=eq.${e}`},c=>{console.log("Business inventory change received!",c);const{eventType:r,new:s,old:d}=c;if(r==="INSERT")s.project_id||(a=[this._convertItemFromDb(s),...a]);else if(r==="UPDATE"){const l=this._convertItemFromDb(s);l.projectId?a=a.filter(u=>u.itemId!==l.itemId):a=a.map(u=>u.itemId===l.itemId?l:u)}else if(r==="DELETE"){const l=d.item_id;a=a.filter(u=>u.itemId!==l)}t([...a])}).subscribe((c,r)=>{c==="SUBSCRIBED"&&console.log("Subscribed to business inventory channel"),r&&console.error("Error subscribing to business inventory channel:",r)});return()=>{i.unsubscribe()}},async createItem(e,t){await f();const o=new Date,n=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,a=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,i=this._convertItemToDb({...t,itemId:n,qrKey:t.qrKey||a});i.date_created=q(o),i.last_updated=o.toISOString(),i.account_id=e,i.created_at=o.toISOString(),i.date_created||(i.date_created=q(o)),i.last_updated||(i.last_updated=o.toISOString()),i.inventory_status||(i.inventory_status="available");try{if(i.transaction_id&&i.tax_rate_pct===null){const{data:s}=await m.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",i.transaction_id).single();s&&s.tax_rate_pct!==void 0&&s.tax_rate_pct!==null&&(i.tax_rate_pct=s.tax_rate_pct)}}catch(s){console.warn("Failed to inherit tax_rate_pct when creating item:",s)}const c=(s,d)=>{const l=parseFloat(s||"0"),u=d!=null?Number(d)/100:0;return(Math.round(l*u*1e4)/1e4).toFixed(4)};i.tax_amount_purchase_price=c(i.purchase_price,i.tax_rate_pct),i.tax_amount_project_price=c(i.project_price,i.tax_rate_pct);const{error:r}=await m.from("items").insert(i);if(r)throw r;try{if(i.transaction_id){const s=i.transaction_id;if(!j._isBatchActive(e,s))try{const d=i.purchase_price??i.price??"0",l=parseFloat(String(d)||"0");j.notifyTransactionChanged(e,s,{deltaSum:l}).catch(u=>{console.warn("Failed to notifyTransactionChanged after creating item:",u)})}catch(d){console.warn("Failed computing delta for created item:",d)}}}catch(s){console.warn("Failed to notifyTransactionChanged after creating item (sync path):",s)}return n},async updateItem(e,t,o){await f();let n=null;try{n=await this.getItemById(e,t)}catch(r){console.warn("Failed to fetch existing item before update:",r)}const a=this._convertItemToDb({...o,lastUpdated:new Date().toISOString()});try{const r=o.transactionId!==void 0&&o.transactionId!==null,s=o.taxRatePct===void 0||o.taxRatePct===null;if(r&&s){const d=o.transactionId;if(d){const{data:l}=await m.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",d).single();l&&l.tax_rate_pct!==void 0&&l.tax_rate_pct!==null&&(a.tax_rate_pct=l.tax_rate_pct)}}}catch(r){console.warn("Failed to inherit tax_rate_pct when updating item:",r)}try{if(o.transactionId!==void 0&&o.transactionId!==null&&(n==null?void 0:n.disposition)==="to return"){const s=o.transactionId;if(s){const{data:d}=await m.from("transactions").select("transaction_type").eq("account_id",e).eq("transaction_id",s).single();d&&d.transaction_type==="Return"&&a.disposition===void 0&&(a.disposition="returned")}}}catch(r){console.warn("Failed to auto-update disposition when assigning return transaction:",r)}if(o.purchasePrice!==void 0||o.projectPrice!==void 0||o.taxRatePct!==void 0){const r=(u,_)=>{const p=parseFloat(u||"0"),h=_!=null?Number(_)/100:0;return(Math.round(p*h*1e4)/1e4).toFixed(4)},s=o.taxRatePct!==void 0?o.taxRatePct:a.tax_rate_pct!==void 0?a.tax_rate_pct:n==null?void 0:n.taxRatePct,d=o.purchasePrice!==void 0?String(o.purchasePrice):n==null?void 0:n.purchasePrice,l=o.projectPrice!==void 0?String(o.projectPrice):n==null?void 0:n.projectPrice;a.tax_amount_purchase_price=r(d,s),a.tax_amount_project_price=r(l,s)}const{error:c}=await m.from("items").update(a).eq("account_id",e).eq("item_id",t);if(c)throw c;try{const r=(n==null?void 0:n.transactionId)??null,s=o.transactionId!==void 0?o.transactionId:r,d=(o.projectId!==void 0?o.projectId:n==null?void 0:n.projectId)??null,l=Array.from(new Set([r,s]).values()).filter(Boolean),u=parseFloat((n==null?void 0:n.purchasePrice)||"0"),_=o.purchasePrice!==void 0?parseFloat(String(o.purchasePrice||"0")):u;for(const p of l)try{if(!j._isBatchActive(e,p))if(r&&s&&r===s&&p===r){const h=_-u;h!==0&&j.notifyTransactionChanged(e,p,{deltaSum:h}).catch(g=>{console.warn("Failed to notifyTransactionChanged after updating item for tx",p,g)})}else{if(p===r){const h=-u;j.notifyTransactionChanged(e,p,{deltaSum:h}).catch(g=>{console.warn("Failed to notifyTransactionChanged for old tx after moving item",p,g)})}if(p===s){const h=_;j.notifyTransactionChanged(e,p,{deltaSum:h}).catch(g=>{console.warn("Failed to notifyTransactionChanged for new tx after moving item",p,g)})}}}catch(h){console.warn("Failed to schedule notifyTransactionChanged after updating item for tx",p,h)}}catch(r){console.warn("Failed to schedule notifyTransactionChanged after updateItem:",r)}},async deleteItem(e,t){await f();let o=null;try{o=await this.getItemById(e,t)}catch(a){console.warn("Failed to fetch item before deletion:",a)}const{error:n}=await m.from("items").delete().eq("account_id",e).eq("item_id",t);if(n)throw n;try{const a=(o==null?void 0:o.transactionId)??null;if(a&&!j._isBatchActive(e,a)){const c=-parseFloat((o==null?void 0:o.purchasePrice)||"0");j.notifyTransactionChanged(e,a,{deltaSum:c}).catch(r=>{console.warn("Failed to notifyTransactionChanged after deleting item:",r)})}}catch(a){console.warn("Failed to notifyTransactionChanged after deleting item:",a)}},async getItemsForTransaction(e,t,o){await f();const{data:n,error:a}=await m.from("items").select("*").eq("account_id",e).eq("transaction_id",o).order("date_created",{ascending:!0});if(a)throw a;return(n||[]).map(i=>this._convertItemFromDb(i))},async allocateItemToProject(e,t,o,n,a,i){await f();const c=await this.getItemById(e,t);if(!c)throw new Error("Item not found");const r=n||c.projectPrice||c.marketValue||"0.00",s=c.transactionId||null;console.log("ðŸ”„ Starting allocation process:",{itemId:t,projectId:o,currentTransactionId:s,itemProjectId:c.projectId,finalAmount:r});try{await P.logAllocationEvent(e,"allocation",t,c.projectId??null,s??null,{action:"allocation_started",target_project_id:o,current_transaction_id:s,amount:r})}catch(d){console.warn("âš ï¸ Failed to log allocation start:",d)}return s!=null&&s.startsWith("INV_SALE_")?s.replace("INV_SALE_","")===o?(console.log("ðŸ“‹ Scenario A.1: Item in Sale, allocating to same project â†’ move to inventory"),await this.handleSaleToInventoryMove(e,c,s,o,r,a,i)):(console.log("ðŸ“‹ Scenario A.2: Item in Sale, allocating to different project"),await this.handleSaleToDifferentProjectMove(e,t,s,o,r,a,i)):s!=null&&s.startsWith("INV_PURCHASE_")?s.replace("INV_PURCHASE_","")===o?(console.log("ðŸ“‹ Scenario B.1: Item in Purchase, allocating to same project"),await this.handlePurchaseToInventoryMove(e,t,s,o,r,a,i)):(console.log("ðŸ“‹ Scenario B.2: Item in Purchase, allocating to different project"),await this.handlePurchaseToDifferentProjectMove(e,t,s,o,r,a,i)):s?(console.log("ðŸ“‹ Fallback: Unknown scenario, treating as new allocation"),await this.handleInventoryToPurchaseMove(e,t,o,r,a,i)):(console.log("ðŸ“‹ Scenario C: Item in inventory, allocating to project"),await this.handleInventoryToPurchaseMove(e,t,o,r,a,i))},async handleSaleToPurchaseMove(e,t,o,n,a,i,c){const r=`INV_PURCHASE_${n}`;await this.removeItemFromTransaction(e,t,o,a),await this.addItemToTransaction(e,t,r,a,"Purchase","Inventory allocation",i),await this.updateItem(e,t,{projectId:n,inventoryStatus:"allocated",transactionId:r,disposition:"keep",space:c,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,o,r,i),await w.updateItemLineagePointers(e,t,r)}catch(s){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",s)}console.log("âœ… A.1 completed: Sale â†’ Purchase (same project)");try{await P.logAllocationEvent(e,"allocation",t,n,r,{action:"allocation_completed",scenario:"A.1",from_transaction:o,to_transaction:r,amount:a})}catch(s){console.warn("âš ï¸ Failed to log allocation completion:",s)}return r},async _restoreItemAfterSaleRemoval(e,t,o,n,a,i){let c=null,r="missing_previous_link";const s=t.previousProjectTransactionId,d=t.previousProjectId,l={projectId:o,inventoryStatus:"allocated",transactionId:null,disposition:"keep",notes:a,space:i??"",previousProjectTransactionId:null,previousProjectId:null};if(s&&d)if(d===o){const{data:u,error:_}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",s).single();!_&&u?(await this.addItemToTransaction(e,t.itemId,s,n,"Purchase","Inventory allocation",a),await this.updateItem(e,t.itemId,{...l,transactionId:s}),c=s,r="restored"):(console.warn("âš ï¸ Stored previous project transaction not found; falling back to allocation without restoration",{itemId:t.itemId,previousTransactionId:s}),r="transaction_missing",await this.updateItem(e,t.itemId,l))}else r="previous_project_mismatch",await this.updateItem(e,t.itemId,l);else await this.updateItem(e,t.itemId,l);return{restoredTransactionId:c,restorationStatus:r}},async handleSaleToInventoryMove(e,t,o,n,a,i,c){await this.removeItemFromTransaction(e,t.itemId,o,a);const{restoredTransactionId:r,restorationStatus:s}=await this._restoreItemAfterSaleRemoval(e,t,n,a,i,c);try{r?(await w.appendItemLineageEdge(e,t.itemId,o,r,i),await w.updateItemLineagePointers(e,t.itemId,r)):(await w.appendItemLineageEdge(e,t.itemId,o,null,i),await w.updateItemLineagePointers(e,t.itemId,null))}catch(d){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",d)}console.log("âœ… A.1 completed: Sale â†’ Inventory (same project)",{restorationStatus:s,restoredTransactionId:r});try{const d={action:"allocation_completed",scenario:"A.1",from_transaction:o,amount:a,restoration_status:s,to_status:r?"allocated_with_purchase":"allocated"};r&&(d.restored_transaction_id=r),await P.logAllocationEvent(e,"allocation",t.itemId,n,r??null,d)}catch(d){console.warn("âš ï¸ Failed to log allocation completion (A.1):",d)}return r??o},async handleSaleToDifferentProjectMove(e,t,o,n,a,i,c){const r=`INV_PURCHASE_${n}`;await this.removeItemFromTransaction(e,t,o,a),await this.addItemToTransaction(e,t,r,a,"Purchase","Inventory allocation",i),await this.updateItem(e,t,{projectId:n,inventoryStatus:"allocated",transactionId:r,disposition:"keep",space:c,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,o,r,i),await w.updateItemLineagePointers(e,t,r)}catch(s){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",s)}console.log("âœ… A.2 completed: Sale â†’ Purchase (different project)");try{await P.logAllocationEvent(e,"allocation",t,n,r,{action:"allocation_completed",scenario:"A.2",from_transaction:o,to_transaction:r,amount:a})}catch(s){console.warn("âš ï¸ Failed to log allocation completion:",s)}return r},async handlePurchaseToInventoryMove(e,t,o,n,a,i,c){await this.removeItemFromTransaction(e,t,o,a),await this.updateItem(e,t,{projectId:null,inventoryStatus:"available",transactionId:null,disposition:"inventory",notes:i,space:c??"",previousProjectTransactionId:o,previousProjectId:n});try{await w.appendItemLineageEdge(e,t,o,null,i),await w.updateItemLineagePointers(e,t,null)}catch(r){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",r)}console.log("âœ… B.1 completed: Purchase â†’ Inventory (same project)");try{await P.logAllocationEvent(e,"deallocation",t,null,"inventory",{action:"deallocation_completed",scenario:"B.1",from_transaction:o,to_status:"inventory",amount:a})}catch(r){console.warn("âš ï¸ Failed to log deallocation completion:",r)}return o},async handlePurchaseToDifferentProjectMove(e,t,o,n,a,i,c){const r=`INV_SALE_${n}`;await this.removeItemFromTransaction(e,t,o,a),await this.addItemToTransaction(e,t,r,a,"To Inventory","Inventory sale",i),await this.updateItem(e,t,{projectId:null,inventoryStatus:"available",transactionId:r,disposition:"inventory",space:c??"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,o,r,i),await w.updateItemLineagePointers(e,t,r)}catch(s){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",s)}console.log("âœ… B.2 completed: Purchase â†’ Sale (different project)");try{await P.logAllocationEvent(e,"allocation",t,null,r,{action:"allocation_completed",scenario:"B.2",from_transaction:o,to_transaction:r,amount:a})}catch(s){console.warn("âš ï¸ Failed to log allocation completion:",s)}return r},async handleInventoryToPurchaseMove(e,t,o,n,a,i){const c=`INV_PURCHASE_${o}`;await this.addItemToTransaction(e,t,c,n,"Purchase","Inventory allocation",a),await this.updateItem(e,t,{projectId:o,inventoryStatus:"allocated",transactionId:c,disposition:"keep",space:i,previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,t,null,c,a),await w.updateItemLineagePointers(e,t,c,c)}catch(r){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",r)}console.log("âœ… C completed: Inventory â†’ Purchase (new allocation)");try{await P.logAllocationEvent(e,"allocation",t,o,c,{action:"allocation_completed",scenario:"C",from_status:"inventory",to_transaction:c,amount:n})}catch(r){console.warn("âš ï¸ Failed to log allocation completion:",r)}return c},async removeItemFromTransaction(e,t,o,n){await f();const{data:a,error:i}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",o).single();if(i||!a){console.warn("âš ï¸ Transaction not found for removal:",o);return}const r=(a.item_ids||[]).filter(s=>s!==t);if(r.length===0)try{const{error:s}=await m.from("transactions").delete().eq("account_id",e).eq("transaction_id",o);if(s)throw s;console.log("ðŸ—‘ï¸ Deleted empty transaction:",o);try{await P.logTransactionStateChange(e,o,"deleted",a,null)}catch(d){console.warn("âš ï¸ Failed to log transaction deletion:",d)}}catch(s){console.error("âŒ Failed to delete empty transaction:",o,s)}else try{const{data:s,error:d}=await m.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",r);if(d)throw d;const l=(s||[]).map(h=>h.project_price||h.market_value||"0.00").reduce((h,g)=>h+parseFloat(g||"0"),0).toFixed(2),u=parseFloat(l)<0?"0.00":l,_={item_ids:r,amount:u,updated_at:new Date().toISOString()},{error:p}=await m.from("transactions").update(_).eq("account_id",e).eq("transaction_id",o);if(p)throw p;console.log("ðŸ”„ Updated transaction after removal:",o,"new amount:",u);try{await P.logTransactionStateChange(e,o,"updated",a,_)}catch(h){console.warn("âš ï¸ Failed to log transaction update:",h)}}catch(s){console.error("âŒ Failed to update transaction after removal:",o,s)}},async addItemToTransaction(e,t,o,n,a,i,c){await f();const{data:r,error:s}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",o).single();if(r&&!s)try{const d=r.item_ids||[],l=[...new Set([...d,t])],{data:u,error:_}=await m.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",l);if(_)throw _;const p=(u||[]).map(b=>b.project_price||b.market_value||"0.00").reduce((b,v)=>b+parseFloat(v||"0"),0).toFixed(2),h=parseFloat(p)<0?"0.00":p,g={item_ids:l,amount:h,updated_at:new Date().toISOString()},{error:y}=await m.from("transactions").update(g).eq("account_id",e).eq("transaction_id",o);if(y)throw y;console.log("ðŸ”„ Added item to existing transaction:",o,"new amount:",h);try{await P.logTransactionStateChange(e,o,"updated",r,g)}catch(b){console.warn("âš ï¸ Failed to log transaction update:",b)}try{const b=r.tax_rate_pct;b!=null&&await this.updateItem(e,t,{tax_rate_pct:b})}catch(b){console.warn("Failed to set tax_rate_pct on added item:",t,b)}try{await this.updateItem(e,t,{transactionId:o})}catch(b){console.warn("Failed to link item to transaction after adding to existing transaction:",t,b)}}catch(d){console.error("âŒ Failed to update existing transaction:",o,d)}else try{const d=await C();if(!(d!=null&&d.id))throw new Error("User must be authenticated to create transactions");const l=o.replace(a==="Purchase"?"INV_PURCHASE_":"INV_SALE_",""),u=await D.getProject(e,l),_=(u==null?void 0:u.name)||"Other",p=new Date,h={account_id:e,transaction_id:o,project_id:l,transaction_date:q(p),source:a==="Purchase"?"Inventory":_,transaction_type:a,payment_method:"Pending",amount:n,budget_category:"Furnishings",notes:c||`Transaction for items ${a==="Purchase"?"purchased from":"sold to"} ${a==="Purchase"?"inventory":"project"}`,status:"pending",reimbursement_type:a==="Purchase"?M:N,trigger_event:i,item_ids:[t],created_by:d.id,created_at:p.toISOString(),updated_at:p.toISOString()},{error:g}=await m.from("transactions").insert(h);if(g)throw g;console.log("ðŸ†• Created new transaction:",o,"amount:",n);try{await P.logTransactionStateChange(e,o,"created",null,h)}catch(y){console.warn("âš ï¸ Failed to log transaction creation:",y)}try{await this.updateItem(e,t,{transactionId:o})}catch(y){console.warn("Failed to link item to transaction after creating new transaction:",t,y)}}catch(d){console.error("âŒ Failed to create new transaction:",o,d)}},async batchAllocateItemsToProject(e,t,o,n={}){await f();const{data:a,error:i}=await m.from("items").select("*").eq("account_id",e).in("item_id",t);if(i||!a||a.length===0)throw new Error("No items found for allocation");const c=`INV_PURCHASE_${o}`;for(const r of a){const s=this._convertItemFromDb(r),d=s.itemId,l=n.amount||r.project_price||r.market_value||"0.00",u=r.transaction_id||null;if(u!=null&&u.startsWith("INV_SALE_"))if(u.replace("INV_SALE_","")===o){console.log("ðŸ“‹ Batch A.1: Item in sale for target project â€” removing from sale and assigning to project",d),await this.removeItemFromTransaction(e,d,u,l);const{restoredTransactionId:p}=await this._restoreItemAfterSaleRemoval(e,s,o,l,n.notes,n.space);try{p?(await w.appendItemLineageEdge(e,d,u,p,n.notes),await w.updateItemLineagePointers(e,d,p)):(await w.appendItemLineageEdge(e,d,u,null,n.notes),await w.updateItemLineagePointers(e,d,null))}catch(h){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",h)}continue}else{console.log("ðŸ“‹ Batch A.2: Item in sale for different project â€” moving to purchase for target project",d),await this.removeItemFromTransaction(e,d,u,l),await this.addItemToTransaction(e,d,c,l,"Purchase","Inventory allocation",n.notes),await this.updateItem(e,d,{projectId:o,inventoryStatus:"allocated",transactionId:c,disposition:"keep",space:n.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,u,c,n.notes),await w.updateItemLineagePointers(e,d,c)}catch(p){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",p)}continue}if(!u){console.log("ðŸ“‹ Batch C: Item in inventory â€” adding to purchase",d),await this.addItemToTransaction(e,d,c,l,"Purchase","Inventory allocation",n.notes),await this.updateItem(e,d,{projectId:o,inventoryStatus:"allocated",transactionId:c,disposition:"keep",space:n.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,null,c,n.notes),await w.updateItemLineagePointers(e,d,c,c)}catch(_){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",_)}continue}console.log("ðŸ“‹ Batch Fallback: Item in other transaction â€” adding to purchase",d,u),await this.addItemToTransaction(e,d,c,l,"Purchase","Inventory allocation",n.notes),await this.updateItem(e,d,{projectId:o,inventoryStatus:"allocated",transactionId:c,disposition:"keep",space:n.space||"",previousProjectTransactionId:null,previousProjectId:null});try{await w.appendItemLineageEdge(e,d,u,c,n.notes),await w.updateItemLineagePointers(e,d,c)}catch(_){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",_)}}return c},async returnItemFromProject(e,t,o,n,a){await f();const i=await this.getItemById(e,t);if(!i)throw new Error("Item not found");const c=n||i.projectPrice||i.marketValue||"0.00",r=i.transactionId||null;console.log("ðŸ”„ Starting return process:",{itemId:t,projectId:o,currentTransactionId:r,itemProjectId:i.projectId,finalAmount:c});try{await P.logAllocationEvent(e,"to return",t,i.projectId??null,r??null,{action:"return_started",target_project_id:o,current_transaction_id:r,amount:c})}catch(s){console.warn("âš ï¸ Failed to log return start:",s)}return r!=null&&r.startsWith("INV_PURCHASE_")&&r.replace("INV_PURCHASE_","")===o?(console.log("ðŸ“‹ Return Scenario: Item in Purchase, returning from same project"),await this.handleReturnFromPurchase(e,i,r,o,c,a)):(console.log("ðŸ“‹ Return Scenario: Item not in transaction or new return"),await this.handleNewReturn(e,i,o,c,a))},async handleReturnFromPurchase(e,t,o,n,a,i){await this.removeItemFromTransaction(e,t.itemId,o,a),await this.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,disposition:"inventory",notes:i,previousProjectTransactionId:o,previousProjectId:t.projectId??n});try{await w.appendItemLineageEdge(e,t.itemId,o,null,i),await w.updateItemLineagePointers(e,t.itemId,null)}catch(c){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",c)}console.log("âœ… Return completed: Purchase â†’ Inventory (same project)");try{await P.logAllocationEvent(e,"to return",t.itemId,null,o,{action:"return_completed",scenario:"return_from_purchase",from_transaction:o,to_status:"inventory",amount:a})}catch(c){console.warn("âš ï¸ Failed to log return completion:",c)}return o},async handleNewReturn(e,t,o,n,a){var p,h;await f();const i=await C();if(!(i!=null&&i.id))throw new Error("User must be authenticated to create transactions");let c="Other";try{const g=await D.getProject(e,o);c=(g==null?void 0:g.name)||"Other"}catch(g){console.warn("Could not fetch project name for transaction source:",g)}const r=`INV_SALE_${o}`,{data:s,error:d}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",r).single(),l=new Date;if(s&&!d){console.log("ðŸ“‹ Existing INV_SALE transaction found, updating with new item");const g=s.item_ids||[],y=[...new Set([...g,t.itemId])],{data:b,error:v}=await m.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",y);if(v)throw v;const E=(b||[]).map(R=>R.project_price||R.market_value||"0.00").reduce((R,k)=>R+parseFloat(k||"0"),0).toFixed(2),x={item_ids:y,amount:E,notes:a||"Transaction for items purchased from project and moved to business inventory",updated_at:l.toISOString()},{error:F}=await m.from("transactions").update(x).eq("account_id",e).eq("transaction_id",r);if(F)throw F;console.log("ðŸ”„ Updated INV_SALE transaction with",y.length,"items, amount:",E)}else{const g={account_id:e,transaction_id:r,project_id:o,transaction_date:q(l),source:c,transaction_type:"To Inventory",payment_method:"Pending",amount:n,budget_category:"Furnishings",notes:a||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:N,trigger_event:"Inventory sale",item_ids:[t.itemId],created_by:i.id,created_at:l.toISOString(),updated_at:l.toISOString()};console.log("ðŸ†• Creating new INV_SALE transaction with amount:",g.amount);const{error:y}=await m.from("transactions").insert(g);if(y)throw y}const u=(p=t.transactionId)!=null&&p.startsWith("INV_PURCHASE_")?t.transactionId:t.previousProjectTransactionId??null,_=(h=t.transactionId)!=null&&h.startsWith("INV_PURCHASE_")?t.projectId??o:t.previousProjectId??null;await this.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:r,disposition:"inventory",previousProjectTransactionId:u,previousProjectId:_});try{const g=t.transactionId||null;await w.appendItemLineageEdge(e,t.itemId,g,r,a),await w.updateItemLineagePointers(e,t.itemId,r)}catch(g){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",g)}console.log("âœ… New return completed: Inventory â†’ Sale");try{await P.logAllocationEvent(e,"to return",t.itemId,null,r,{action:"return_completed",scenario:"new_return",from_status:"inventory",to_transaction:r,amount:n})}catch(g){console.warn("âš ï¸ Failed to log return completion:",g)}return r},async completePendingTransaction(e,t,o,n){await f();const a=t==="sale"?`INV_SALE_${o}`:`INV_PURCHASE_${o}`,{data:i,error:c}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",a).single();if(c||!i)throw new Error("Transaction not found");const r=i.item_ids||[],s=new Date,{error:d}=await m.from("transactions").update({status:"completed",payment_method:n,transaction_date:q(s),updated_at:s.toISOString()}).eq("account_id",e).eq("transaction_id",a);if(d)throw d;for(const l of r)if(t==="sale"){await this.updateItem(e,l,{transactionId:null,inventoryStatus:"available"});try{await w.appendItemLineageEdge(e,l,a,null),await w.updateItemLineagePointers(e,l,null)}catch(u){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",u)}}else{await this.updateItem(e,l,{projectId:null,transactionId:null,inventoryStatus:"available"});try{await w.appendItemLineageEdge(e,l,a,null),await w.updateItemLineagePointers(e,l,null)}catch(u){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",u)}}},async getItemById(e,t){await f();const{data:o,error:n}=await m.from("items").select("*").eq("account_id",e).eq("item_id",t).single();if(n){if(n.code==="PGRST116")return null;throw n}return o?this._convertItemFromDb(o):null},async duplicateItem(e,t,o){await f();const n=await this.getItemById(e,o);if(!n)throw new Error("Original item not found");const a=new Date,i=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,c=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,r={account_id:e,item_id:i,description:n.description||"",source:n.source||"",sku:n.sku||"",purchase_price:n.purchasePrice||null,project_price:n.projectPrice||null,market_value:n.marketValue||null,payment_method:n.paymentMethod||"",disposition:"keep",notes:n.notes||null,space:n.space||null,qr_key:c,bookmark:!1,transaction_id:n.transactionId||null,project_id:t,inventory_status:n.inventoryStatus||"available",business_inventory_location:n.businessInventoryLocation||null,date_created:n.dateCreated||q(a),last_updated:a.toISOString(),images:n.images||[],tax_rate_pct:n.taxRatePct||null,tax_amount:n.taxAmount||null,created_by:n.createdBy||null,created_at:a.toISOString()};Object.keys(r).forEach(d=>{r[d]===void 0&&delete r[d]});const{error:s}=await m.from("items").insert(r);if(s)throw s;return i},async createTransactionItems(e,t,o,n,a,i,c){await f();const r=[],s=new Date;let d;try{if(c==null&&o){const{data:_,error:p}=await m.from("transactions").select("tax_rate_pct").eq("account_id",e).eq("transaction_id",o).single();!p&&_&&_.tax_rate_pct!==void 0&&_.tax_rate_pct!==null&&(d=_.tax_rate_pct)}}catch{}const l=[],u=(_,p)=>{const h=parseFloat(_||"0"),g=p!=null?Number(p)/100:0;return(Math.round(h*g*1e4)/1e4).toFixed(4)};for(const _ of i){const p=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`;r.push(p);const h=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,g={account_id:e,item_id:p,description:_.description||"",source:a,sku:_.sku||"",purchase_price:_.purchasePrice||null,project_price:_.projectPrice||null,market_value:_.marketValue||null,payment_method:"Client Card",disposition:"keep",notes:_.notes||null,qr_key:h,bookmark:!1,transaction_id:o,project_id:t,inventory_status:"allocated",date_created:n,last_updated:s.toISOString(),images:[],created_at:s.toISOString()};c!=null?g.tax_rate_pct=c:d!==void 0&&(g.tax_rate_pct=d),g.tax_amount_purchase_price=u(g.purchase_price,g.tax_rate_pct),g.tax_amount_project_price=u(g.project_price,g.tax_rate_pct),l.push(g)}if(l.length>0){const{error:_}=await m.from("items").insert(l);if(_)throw _}try{if(!j._isBatchActive(e,o))try{const _=l.reduce((p,h)=>{const g=parseFloat(String(h.purchase_price??h.price??"0")||"0");return p+(isNaN(g)?0:g)},0);_!==0?j.notifyTransactionChanged(e,o,{deltaSum:_}).catch(p=>{console.warn("Failed to notifyTransactionChanged after creating transaction items:",p)}):j.notifyTransactionChanged(e,o).catch(p=>{console.warn("Failed to notifyTransactionChanged after creating transaction items (no delta):",p)})}catch(_){console.warn("Failed computing deltaSum for created transaction items:",_)}}catch(_){console.warn("Failed to notifyTransactionChanged after creating transaction items (sync path):",_)}return r}},V={async _resolvePreviousProjectLink(e,t,o){const n=t.transactionId,a=t.projectId??o,i=n?n.startsWith("INV_SALE_"):!1;return n&&!i?{previousProjectTransactionId:n,previousProjectId:a}:{previousProjectTransactionId:t.previousProjectTransactionId??null,previousProjectId:t.previousProjectId??null}},async handleInventoryDesignation(e,t,o,n){if(console.log("ðŸ”„ handleInventoryDesignation called:",{itemId:t,projectId:o,disposition:n}),n!=="inventory"){console.log("â­ï¸ Skipping - disposition is not inventory:",n);return}try{console.log("ðŸ” Getting item details for:",t);const a=await S.getItemById(e,t);if(!a)throw new Error("Item not found");console.log("âœ… Item found:",a.itemId,"disposition:",a.disposition,"projectId:",a.projectId);const{previousProjectTransactionId:i,previousProjectId:c}=await this._resolvePreviousProjectLink(e,a,o);if(a.transactionId&&a.transactionId.startsWith("INV_PURCHASE_")&&a.transactionId.replace("INV_PURCHASE_","")===o){console.log("ðŸ” Detected purchase-reversion: removing from INV_PURCHASE and returning to inventory"),await S.removeItemFromTransaction(e,a.itemId,a.transactionId,a.projectPrice||a.marketValue||"0.00"),await S.updateItem(e,a.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,previousProjectTransactionId:i,previousProjectId:c,lastUpdated:new Date().toISOString()});try{await P.logAllocationEvent(e,"deallocation",t,null,a.transactionId,{action:"deallocation_completed",scenario:"purchase_reversion",from_transaction:a.transactionId,to_status:"inventory",amount:a.projectPrice||a.marketValue||"0.00"})}catch(d){console.warn("âš ï¸ Failed to log deallocation completion for purchase-reversion:",d)}console.log("âœ… Purchase-reversion handled: item returned to inventory without creating INV_SALE");return}console.log("ðŸ¦ Creating/updating Sale transaction for inventory designation");try{await P.logAllocationEvent(e,"deallocation",t,a.projectId??null,a.transactionId??null,{action:"deallocation_started",target_status:"inventory",current_transaction_id:a.transactionId})}catch(s){console.warn("âš ï¸ Failed to log deallocation start:",s)}const r=await this.ensureSaleTransaction(e,a,o,"Transaction for items purchased from project and moved to business inventory",{previousProjectTransactionId:i,previousProjectId:c});console.log("ðŸ“¦ Moving item to business inventory..."),await S.updateItem(e,a.itemId,{projectId:null,inventoryStatus:"available",transactionId:r,space:"",previousProjectTransactionId:i,previousProjectId:c,lastUpdated:new Date().toISOString()});try{const s=a.transactionId||null;await w.appendItemLineageEdge(e,a.itemId,s,r),await w.updateItemLineagePointers(e,a.itemId,r)}catch(s){console.warn("âš ï¸ Failed to append lineage edge (non-critical):",s)}try{await P.logAllocationEvent(e,"deallocation",t,null,r,{action:"deallocation_completed",from_project_id:a.projectId,to_transaction:r,amount:a.projectPrice||a.marketValue||"0.00"})}catch(s){console.warn("âš ï¸ Failed to log deallocation completion:",s)}console.log("âœ… Item moved to business inventory successfully"),console.log("âœ… Deallocation completed successfully")}catch(a){throw console.error("âŒ Error handling inventory designation:",a),a}},async ensureSaleTransaction(e,t,o,n,a){await f();const i=await C();if(!(i!=null&&i.id))throw new Error("User must be authenticated to create transactions");console.log("ðŸ¦ Creating/updating sale transaction for item:",t.itemId);let c="Other";try{const l=await D.getProject(e,o);c=(l==null?void 0:l.name)||"Other"}catch(l){console.warn("Could not fetch project name for transaction source:",l)}if(t.transactionId&&t.transactionId.startsWith("INV_PURCHASE_")&&t.transactionId.replace("INV_PURCHASE_","")===o)return console.log("â„¹ï¸ ensureSaleTransaction detected existing INV_PURCHASE for same project; performing purchase-reversion instead of creating INV_SALE"),await S.removeItemFromTransaction(e,t.itemId,t.transactionId,t.projectPrice||t.marketValue||"0.00"),await S.updateItem(e,t.itemId,{projectId:null,inventoryStatus:"available",transactionId:null,previousProjectTransactionId:(a==null?void 0:a.previousProjectTransactionId)??t.transactionId,previousProjectId:(a==null?void 0:a.previousProjectId)??t.projectId??o}),null;const r=`INV_SALE_${o}`;console.log("ðŸ”‘ Canonical transaction ID:",r);const{data:s,error:d}=await m.from("transactions").select("*").eq("account_id",e).eq("transaction_id",r).single();if(s&&!d){console.log("ðŸ“‹ Existing INV_SALE transaction found, updating with new item");const l=s.item_ids||[],u=[...new Set([...l,t.itemId])],{data:_,error:p}=await m.from("items").select("project_price, market_value").eq("account_id",e).in("item_id",u);if(p)throw p;const h=(_||[]).map(v=>v.project_price||v.market_value||"0.00").reduce((v,E)=>v+parseFloat(E||"0"),0).toFixed(2),y={item_ids:u,amount:h,notes:n||"Transaction for items purchased from project and moved to business inventory",updated_at:new Date().toISOString()},{error:b}=await m.from("transactions").update(y).eq("account_id",e).eq("transaction_id",r);if(b)throw b;console.log("ðŸ”„ Updated INV_SALE transaction with",u.length,"items, amount:",h)}else{const l=t.projectPrice||t.marketValue||"0.00",u=new Date,_={account_id:e,transaction_id:r,project_id:o,transaction_date:q(u),source:c,transaction_type:"To Inventory",payment_method:"Pending",amount:parseFloat(l).toFixed(2),budget_category:"Furnishings",notes:n||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:N,trigger_event:"Inventory sale",item_ids:[t.itemId],created_by:i.id,created_at:u.toISOString(),updated_at:u.toISOString()};console.log("ðŸ†• Creating new INV_SALE transaction with amount:",_.amount);const{error:p}=await m.from("transactions").insert(_);if(p)throw p}return console.log("âœ… Sale transaction created/updated successfully"),r}},H={async allocateBusinessInventoryToProject(e,t,o,n,a){return await S.allocateItemToProject(e,t,o,n,a)},async returnItemToBusinessInventory(e,t,o,n){await S.returnItemFromProject(e,t,n)},async completePendingTransaction(e,t,o,n,a){return await S.completePendingTransaction(e,"sale",n,a)},async handleItemDeallocation(e,t,o,n){return await V.handleInventoryDesignation(e,t,o,n)}},Y=Object.freeze(Object.defineProperty({__proto__:null,auditService:P,deallocationService:V,integrationService:H,projectService:D,transactionService:j,unifiedItemsService:S},Symbol.toStringTag,{value:"Module"}));export{G as a,q as b,Y as c,K as f,H as i,w as l,D as p,j as t,S as u};
//# sourceMappingURL=inventoryService.js.map
