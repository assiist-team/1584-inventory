import{t as p,z as l,N as j,O as N,m,P as q,B as D,Q as E,q as R,u as f,A as u,D as B,s as C,R as L,S as x,U as H,V as Q}from"./firebase.js";import{e as b,f as P,d}from"./index.js";const U=a=>{if(!a)return null;if(a instanceof Date)return a;if(typeof a=="object"&&a){if("toDate"in a&&typeof a.toDate=="function")try{return a.toDate()}catch(t){return console.warn("Failed to convert Firestore Timestamp to Date:",t),null}if("seconds"in a&&"nanoseconds"in a)try{return new Date(a.seconds*1e3+a.nanoseconds/1e6)}catch(t){return console.warn("Failed to convert Firestore Timestamp to Date:",t),null}}if(typeof a=="string")try{if(/^\d{4}-\d{2}-\d{2}$/.test(a)){const[n,e,o]=a.split("-").map(Number),s=new Date(n,e-1,o);return isNaN(s.getTime())?null:s}const t=new Date(a);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to parse date string:",a,t),null}if(typeof a=="number")try{const t=new Date(a);return isNaN(t.getTime())?null:t}catch(t){return console.warn("Failed to convert number to Date:",a,t),null}return null},J=(a,t="Unknown")=>{const n=U(a);if(!n)return t;try{return n.toLocaleDateString("en-US",{year:"numeric",month:"short",day:"numeric"})}catch(e){return console.warn("Failed to format date:",a,e),t}},X=(a,t="$0.00")=>{const n=typeof a=="string"?parseFloat(a):a;return isNaN(n)?t:n.toLocaleString("en-US",{style:"currency",currency:"USD",minimumFractionDigits:2,maximumFractionDigits:2})},k=a=>{if(!a)return"";if(typeof a=="string"&&/^\d{4}-\d{2}-\d{2}$/.test(a))return a;const t=U(a);if(!t)return"";const n=t.getFullYear(),e=String(t.getMonth()+1).padStart(2,"0"),o=String(t.getDate()).padStart(2,"0");return`${n}-${e}-${o}`},I={async logAllocationEvent(a,t,n,e,o){try{let s=null,r={};typeof e=="string"?(s=e,r=o||{}):(s=null,r=e||{});const i=p(d,"audit_logs");await E(i,{event_type:a,item_id:t,project_id:n,transaction_id:s,details:r,timestamp:x(),created_at:new Date().toISOString()}),console.log(`📋 Audit logged: ${a} for item ${t}`)}catch(s){console.warn("⚠️ Failed to log audit event (non-critical):",s)}},async logTransactionStateChange(a,t,n,e){try{const o=p(d,"transaction_audit_logs");await E(o,{transaction_id:a,change_type:t,old_state:n,new_state:e,timestamp:x(),created_at:new Date().toISOString()}),console.log(`📋 Transaction audit logged: ${t} for ${a}`)}catch(o){console.warn("⚠️ Failed to log transaction audit (non-critical):",o)}}},O={async getProjects(){await b();const a=p(d,"projects"),t=l(a,j("updatedAt","desc"));return(await f(t)).docs.map(e=>{const o=P(e.data());return{id:e.id,...o}})},async getProject(a){await b();const t=m(d,"projects",a),n=await R(t);if(n.exists()){const e=P(n.data());return{id:n.id,...e}}return null},async createProject(a){const t=p(d,"projects"),n=new Date,e={...a,createdAt:n,updatedAt:n};return(await E(t,e)).id},async updateProject(a,t){const n=m(d,"projects",a);await D(n,{...t,updatedAt:new Date})},async deleteProject(a){const t=m(d,"projects",a);await q(t)},subscribeToProjects(a){const t=p(d,"projects"),n=l(t,j("updatedAt","desc"));return N(n,e=>{const o=e.docs.map(s=>{const r=P(s.data());return{id:s.id,...r}});a(o)})}},W={async getTransactions(a){const t=p(d,"transactions"),n=l(t,u("project_id","==",a),j("created_at","desc"));return(await f(n)).docs.map(o=>{const s=P(o.data()),r={...s,transaction_images:Array.isArray(s.transaction_images)?s.transaction_images:[],receipt_images:Array.isArray(s.receipt_images)?s.receipt_images:[],other_images:Array.isArray(s.other_images)?s.other_images:[]};return{transaction_id:o.id,...r}})},async getTransaction(a,t){const n=m(d,"transactions",t),e=await R(n);if(e.exists()){const o=P(e.data());console.log("inventoryService - raw data:",o),console.log("inventoryService - transaction_images:",o.transaction_images),console.log("inventoryService - transaction_images type:",typeof o.transaction_images);const s={...o,transaction_images:Array.isArray(o.transaction_images)?o.transaction_images:[],receipt_images:Array.isArray(o.receipt_images)?o.receipt_images:[],other_images:Array.isArray(o.other_images)?o.other_images:[]};return console.log("inventoryService - processed transactionData:",s),{transaction_id:e.id,...s}}return null},async getTransactionById(a){const t=m(d,"transactions",a),n=await R(t);if(n.exists()){const e=P(n.data()),o={...e,transaction_images:Array.isArray(e.transaction_images)?e.transaction_images:[],receipt_images:Array.isArray(e.receipt_images)?e.receipt_images:[],other_images:Array.isArray(e.other_images)?e.other_images:[]};return{transaction:{transaction_id:n.id,...o},projectId:e.project_id||null}}return{transaction:null,projectId:null}},async createTransaction(a,t,n){try{const e=p(d,"transactions"),s={...t,project_id:a,created_at:new Date().toISOString(),status:t.status||"completed",reimbursement_type:t.reimbursement_type||null,trigger_event:t.trigger_event||null};console.log("Creating transaction:",s),console.log("Transaction items:",n);const i=(await E(e,s)).id;if(console.log("Transaction created successfully:",i),n&&n.length>0){console.log("Creating items for transaction:",i);const c=await F.createTransactionItems(a||"",i,t.transaction_date,t.source,n);console.log("Created items:",c)}return i}catch(e){throw console.error("Error creating transaction:",e),e}},async updateTransaction(a,t,n){const e=m(d,"transactions",t),o={...n};o.status==="completed"&&o.reimbursement_type!==void 0&&(o.reimbursement_type=Q()),o.reimbursement_type===""&&(o.reimbursement_type=Q()),o.reimbursement_type&&o.status==="completed"&&(o.status="pending");const s={};Object.keys(o).forEach(r=>{o[r]!==void 0&&(s[r]=o[r])}),await D(e,s)},async deleteTransaction(a,t){const n=m(d,"transactions",t);await q(n)},subscribeToTransactions(a,t){const n=p(d,"transactions"),e=l(n,u("project_id","==",a),j("created_at","desc"));return N(e,o=>{const s=o.docs.map(r=>{const i=P(r.data()),c={...i,transaction_images:Array.isArray(i.transaction_images)?i.transaction_images:[],receipt_images:Array.isArray(i.receipt_images)?i.receipt_images:[],other_images:Array.isArray(i.other_images)?i.other_images:[]};return{transaction_id:r.id,...c}});t(s)})},subscribeToTransaction(a,t,n){const e=m(d,"transactions",t);return N(e,o=>{if(o.exists()){const s=P(o.data());console.log("inventoryService - real-time raw data:",s),console.log("inventoryService - real-time transaction_images:",s.transaction_images);const r={...s,transaction_images:Array.isArray(s.transaction_images)?s.transaction_images:[],receipt_images:Array.isArray(s.receipt_images)?s.receipt_images:[],other_images:Array.isArray(s.other_images)?s.other_images:[]};console.log("inventoryService - real-time processed transactionData:",r);const i={transaction_id:o.id,...r};n(i)}else n(null)})},async getPendingTransactions(a){const t=p(d,"projects",a,"transactions"),n=l(t,u("status","==","pending"),j("created_at","desc"));return(await f(n)).docs.map(o=>{const s=P(o.data()),r={...s,transaction_images:Array.isArray(s.transaction_images)?s.transaction_images:[],receipt_images:Array.isArray(s.receipt_images)?s.receipt_images:[],other_images:Array.isArray(s.other_images)?s.other_images:[]};return{transaction_id:o.id,...r}})},async updateTransactionStatus(a,t,n,e){const o=m(d,"projects",a,"transactions",t),s={status:n,...e};n==="completed"&&!(e!=null&&e.transaction_date)&&(s.transaction_date=k(new Date)),s.last_updated=new Date().toISOString(),await D(o,s)},async getInventoryRelatedTransactions(){const a=p(d,"transactions"),t=l(a,u("reimbursement_type","in",["Client Owes","We Owe"]),j("created_at","desc"));return(await f(t)).docs.map(e=>{const o=P(e.data()),s={...o,transaction_images:Array.isArray(o.transaction_images)?o.transaction_images:[],receipt_images:Array.isArray(o.receipt_images)?o.receipt_images:[],other_images:Array.isArray(o.other_images)?o.other_images:[]};return{transaction_id:e.id,...s}})},async getBusinessInventoryTransactions(){const a=p(d,"transactions"),t=l(a,u("project_id","==",null),j("created_at","desc"));return(await f(t)).docs.map(e=>{const o=P(e.data()),s={...o,transaction_images:Array.isArray(o.transaction_images)?o.transaction_images:[],receipt_images:Array.isArray(o.receipt_images)?o.receipt_images:[],other_images:Array.isArray(o.other_images)?o.other_images:[]};return{transaction_id:e.id,...s}})}},F={async getItemsByProject(a,t,n){await b();const e=p(d,"items");let o=l(e,u("project_id","==",a));if(t!=null&&t.status&&(o=l(o,u("disposition","==",t.status))),t!=null&&t.category&&(o=l(o,u("source","==",t.category))),t!=null&&t.tags&&t.tags.length>0&&(o=l(o,u("tags","array-contains-any",t.tags))),t!=null&&t.priceRange&&(o=l(o,u("project_price",">=",t.priceRange.min),u("project_price","<=",t.priceRange.max))),t!=null&&t.searchQuery){const i=t.searchQuery.toLowerCase();o=l(o,u("description",">=",i),u("description","<=",i+""))}o=l(o,j("last_updated","desc")),n&&(o=l(o,L(n.limit)),n.page>0&&(o=l(o,L(n.page*n.limit))));let r=(await f(o)).docs.map(i=>({item_id:i.id,...i.data()}));if(t!=null&&t.searchQuery&&r.length>0){const i=t.searchQuery.toLowerCase();r=r.filter(c=>c.description.toLowerCase().includes(i)||c.source.toLowerCase().includes(i)||c.sku.toLowerCase().includes(i)||c.payment_method.toLowerCase().includes(i))}return r},subscribeToItemsByProject(a,t,n){const e=p(d,"items");let o=l(e,u("project_id","==",a),j("last_updated","desc"));if(n!=null&&n.status&&(o=l(o,u("disposition","==",n.status))),n!=null&&n.category&&(o=l(o,u("source","==",n.category))),n!=null&&n.searchQuery){const s=n.searchQuery.toLowerCase();o=l(o,u("description",">=",s),u("description","<=",s+""))}return N(o,s=>{let r=s.docs.map(i=>({item_id:i.id,...i.data()}));if(n!=null&&n.searchQuery){const i=n.searchQuery.toLowerCase();r=r.filter(c=>c.description.toLowerCase().includes(i)||c.source.toLowerCase().includes(i)||c.sku.toLowerCase().includes(i)||c.payment_method.toLowerCase().includes(i))}t(r)})},async getBusinessInventoryItems(a,t){await b();const n=p(d,"items");let e=l(n,u("project_id","==",null));a!=null&&a.status&&(e=l(e,u("inventory_status","==",a.status))),e=l(e,j("last_updated","desc")),t&&(e=l(e,L(t.limit)),t.page>0&&(e=l(e,L(t.page*t.limit))));let s=(await f(e)).docs.map(r=>({item_id:r.id,...r.data()}));if(a!=null&&a.searchQuery){const r=a.searchQuery.toLowerCase();s=s.filter(i=>{var c;return i.description.toLowerCase().includes(r)||i.source.toLowerCase().includes(r)||i.sku.toLowerCase().includes(r)||((c=i.business_inventory_location)==null?void 0:c.toLowerCase().includes(r))})}return s},subscribeToBusinessInventory(a,t){const n=p(d,"items");let e=l(n,u("project_id","==",null),j("last_updated","desc"));return t!=null&&t.status&&(e=l(e,u("inventory_status","==",t.status))),N(e,o=>{let s=o.docs.map(r=>({item_id:r.id,...r.data()}));if(t!=null&&t.searchQuery){const r=t.searchQuery.toLowerCase();s=s.filter(i=>{var c;return i.description.toLowerCase().includes(r)||i.source.toLowerCase().includes(r)||i.sku.toLowerCase().includes(r)||((c=i.business_inventory_location)==null?void 0:c.toLowerCase().includes(r))})}a(s)})},async createItem(a){await b();const t=p(d,"items"),n=new Date,e={...a,inventory_status:a.inventory_status||"available",date_created:n.toISOString(),last_updated:n.toISOString()};return(await E(t,e)).id},async updateItem(a,t){await b();const n=m(d,"items",a),e={last_updated:new Date().toISOString()};t.inventory_status!==void 0&&(e.inventory_status=t.inventory_status),t.project_id!==void 0&&(e.project_id=t.project_id),t.business_inventory_location!==void 0&&(e.business_inventory_location=t.business_inventory_location),t.transaction_id!==void 0&&(e.transaction_id=t.transaction_id),t.purchase_price!==void 0&&(e.purchase_price=t.purchase_price),t.project_price!==void 0&&(e.project_price=t.project_price),t.description!==void 0&&(e.description=t.description),t.source!==void 0&&(e.source=t.source),t.sku!==void 0&&(e.sku=t.sku),t.market_value!==void 0&&(e.market_value=t.market_value),t.payment_method!==void 0&&(e.payment_method=t.payment_method),t.disposition!==void 0&&(e.disposition=t.disposition),t.notes!==void 0&&(e.notes=t.notes),t.space!==void 0&&(e.space=t.space),t.bookmark!==void 0&&(e.bookmark=t.bookmark),t.images!==void 0&&(e.images=t.images),await D(n,e)},async deleteItem(a){await b();const t=m(d,"items",a);await q(t)},async getItemsForTransaction(a,t){await b();const n=p(d,"items"),e=l(n,u("transaction_id","==",t),j("date_created","asc"));return(await f(e)).docs.map(s=>({item_id:s.id,...s.data()}))},async allocateItemToProject(a,t,n,e){await b();const o=await this.getItemById(a);if(!o)throw new Error("Item not found");const s=n||o.project_price||o.market_value||"0.00",r=o.transaction_id||null;console.log("🔄 Starting allocation process:",{itemId:a,projectId:t,currentTransactionId:r,itemProjectId:o.project_id,finalAmount:s});try{await I.logAllocationEvent("allocation",a,o.project_id,r,{action:"allocation_started",target_project_id:t,current_transaction_id:r,amount:s})}catch(i){console.warn("⚠️ Failed to log allocation start:",i)}return o.project_id===null?(console.log("📋 Scenario C: Item in inventory, allocating to project"),await this.handleInventoryToPurchaseMove(a,t,s,e)):r!=null&&r.startsWith("INV_SALE_")?r.replace("INV_SALE_","")===t?(console.log("📋 Scenario A.1: Item in Sale, allocating to same project"),await this.handleSaleToPurchaseMove(a,r,t,s,e)):(console.log("📋 Scenario A.2: Item in Sale, allocating to different project"),await this.handleSaleToDifferentProjectMove(a,r,t,s,e)):r!=null&&r.startsWith("INV_PURCHASE_")?r.replace("INV_PURCHASE_","")===t?(console.log("📋 Scenario B.1: Item in Purchase, allocating to same project"),await this.handlePurchaseToInventoryMove(a,r,t,s,e)):(console.log("📋 Scenario B.2: Item in Purchase, allocating to different project"),await this.handlePurchaseToDifferentProjectMove(a,r,t,s,e)):(console.log("📋 Fallback: Unknown scenario, treating as new allocation"),await this.handleInventoryToPurchaseMove(a,t,s,e))},async handleSaleToPurchaseMove(a,t,n,e,o){const s=`INV_PURCHASE_${n}`;await this.removeItemFromTransaction(a,t,e),await this.addItemToTransaction(a,s,e,"Purchase","Inventory allocation",o),await this.updateItem(a,{project_id:n,inventory_status:"allocated",transaction_id:s,disposition:"keep"}),console.log("✅ A.1 completed: Sale → Purchase (same project)");try{await I.logAllocationEvent("allocation",a,n,s,{action:"allocation_completed",scenario:"A.1",from_transaction:t,to_transaction:s,amount:e})}catch(r){console.warn("⚠️ Failed to log allocation completion:",r)}return s},async handleSaleToDifferentProjectMove(a,t,n,e,o){const s=`INV_PURCHASE_${n}`;await this.removeItemFromTransaction(a,t,e),await this.addItemToTransaction(a,s,e,"Purchase","Inventory allocation",o),await this.updateItem(a,{project_id:n,inventory_status:"allocated",transaction_id:s,disposition:"keep"}),console.log("✅ A.2 completed: Sale → Purchase (different project)");try{await I.logAllocationEvent("allocation",a,n,s,{action:"allocation_completed",scenario:"A.2",from_transaction:t,to_transaction:s,amount:e})}catch(r){console.warn("⚠️ Failed to log allocation completion:",r)}return s},async handlePurchaseToInventoryMove(a,t,n,e,o){await this.removeItemFromTransaction(a,t,e),await this.updateItem(a,{project_id:null,inventory_status:"available",disposition:"inventory",notes:o||"Item returned to inventory from project"}),console.log("✅ B.1 completed: Purchase → Inventory (same project)");try{await I.logAllocationEvent("deallocation",a,null,"inventory",{action:"deallocation_completed",scenario:"B.1",from_transaction:t,to_status:"inventory",amount:e})}catch(s){console.warn("⚠️ Failed to log deallocation completion:",s)}return t},async handlePurchaseToDifferentProjectMove(a,t,n,e,o){const s=`INV_SALE_${n}`;await this.removeItemFromTransaction(a,t,e),await this.addItemToTransaction(a,s,e,"To Inventory","Inventory sale",o),await this.updateItem(a,{project_id:null,inventory_status:"available",transaction_id:s,disposition:"inventory"}),console.log("✅ B.2 completed: Purchase → Sale (different project)");try{await I.logAllocationEvent("allocation",a,null,s,{action:"allocation_completed",scenario:"B.2",from_transaction:t,to_transaction:s,amount:e})}catch(r){console.warn("⚠️ Failed to log allocation completion:",r)}return s},async handleInventoryToPurchaseMove(a,t,n,e){const o=`INV_PURCHASE_${t}`;await this.addItemToTransaction(a,o,n,"Purchase","Inventory allocation",e),await this.updateItem(a,{project_id:t,inventory_status:"allocated",transaction_id:o,disposition:"keep"}),console.log("✅ C completed: Inventory → Purchase (new allocation)");try{await I.logAllocationEvent("allocation",a,t,o,{action:"allocation_completed",scenario:"C",from_status:"inventory",to_transaction:o,amount:n})}catch(s){console.warn("⚠️ Failed to log allocation completion:",s)}return o},async removeItemFromTransaction(a,t,n){const e=m(d,"transactions",t),o=await R(e);if(!o.exists()){console.warn("⚠️ Transaction not found for removal:",t);return}const s=o.data(),i=(s.item_ids||[]).filter(c=>c!==a);if(i.length===0)try{await q(e),console.log("🗑️ Deleted empty transaction:",t);try{await I.logTransactionStateChange(t,"deleted",s,null)}catch(c){console.warn("⚠️ Failed to log transaction deletion:",c)}}catch(c){console.error("❌ Failed to delete empty transaction:",t,c)}else try{const c=p(d,"items"),_=l(c,u("__name__","in",i)),g=(await f(_)).docs.map(S=>S.data().project_price||S.data().market_value||"0.00").reduce((S,A)=>S+parseFloat(A||"0"),0).toFixed(2),v={item_ids:i,amount:g,last_updated:new Date().toISOString()};await D(e,v),console.log("🔄 Updated transaction after removal:",t,"new amount:",g);try{await I.logTransactionStateChange(t,"updated",s,v)}catch(S){console.warn("⚠️ Failed to log transaction update:",S)}}catch(c){console.error("❌ Failed to update transaction after removal:",t,c)}},async addItemToTransaction(a,t,n,e,o,s){const r=m(d,"transactions",t),i=await R(r);if(i.exists())try{const c=i.data(),_=c.item_ids||[],y=[...new Set([..._,a])],g=p(d,"items"),v=l(g,u("__name__","in",y)),A=(await f(v)).docs.map(w=>w.data().project_price||w.data().market_value||"0.00").reduce((w,T)=>w+parseFloat(T||"0"),0).toFixed(2),h={item_ids:y,amount:A,last_updated:new Date().toISOString()};await D(r,h),console.log("🔄 Added item to existing transaction:",t,"new amount:",A);try{await I.logTransactionStateChange(t,"updated",c,h)}catch(w){console.warn("⚠️ Failed to log transaction update:",w)}}catch(c){console.error("❌ Failed to update existing transaction:",t,c)}else try{const c=await O.getProject(t.replace(e==="Purchase"?"INV_PURCHASE_":"INV_SALE_","")),_=(c==null?void 0:c.name)||"Other",y={project_id:t.replace(e==="Purchase"?"INV_PURCHASE_":"INV_SALE_",""),project_name:null,transaction_date:k(new Date),source:e==="Purchase"?"Inventory":_,transaction_type:e,payment_method:"Pending",amount:n,budget_category:"Furnishings",notes:s||`Transaction for items ${e==="Purchase"?"purchased from":"sold to"} ${e==="Purchase"?"inventory":"project"}`,status:"pending",reimbursement_type:e==="Purchase"?"Client Owes":"We Owe",trigger_event:o,item_ids:[a],created_by:"system",created_at:new Date().toISOString(),last_updated:new Date().toISOString()};await C(r,y),console.log("🆕 Created new transaction:",t,"amount:",n);try{await I.logTransactionStateChange(t,"created",null,y)}catch(g){console.warn("⚠️ Failed to log transaction creation:",g)}}catch(c){console.error("❌ Failed to create new transaction:",t,c)}},async batchAllocateItemsToProject(a,t,n={}){await b();const e=p(d,"items"),o=l(e,u("__name__","in",a),u("project_id","==",null)),s=await f(o);if(s.empty)throw new Error("No business inventory items found");const r=`INV_PURCHASE_${t}`,i=m(d,"transactions",r),c=await R(i);let _;if(c.exists()){console.log("📋 Existing INV_PURCHASE transaction found, updating with new items");const g=c.data(),v=g.item_ids||[];_=[...new Set([...v,...a])];const S=l(e,u("__name__","in",_)),A=await f(S),h=n.amount||A.docs.map(T=>T.data().project_price||T.data().market_value||"0.00").reduce((T,$)=>T+parseFloat($||"0"),0).toFixed(2),w={...g,item_ids:_,amount:h,notes:n.notes||g.notes||"Transaction for items purchased from business inventory and allocated to project",last_updated:new Date().toISOString()};await C(i,w,{merge:!0}),console.log("🔄 Updated INV_PURCHASE transaction with",_.length,"items, amount:",h)}else{_=a;const g=n.amount||s.docs.map(S=>S.data().project_price||S.data().market_value||"0.00").reduce((S,A)=>S+parseFloat(A||"0"),0).toFixed(2),v={project_id:t,transaction_date:k(new Date),source:"Inventory",transaction_type:"Purchase",payment_method:"Pending",amount:g,budget_category:"Furnishings",notes:n.notes||"Transaction for items purchased from business inventory and allocated to project",status:"pending",reimbursement_type:"Client Owes",trigger_event:"Inventory allocation",item_ids:_,created_by:"system",created_at:new Date().toISOString(),last_updated:new Date().toISOString()};console.log("🆕 Creating new INV_PURCHASE transaction with amount:",g),await C(i,v,{merge:!0})}const y=B(d);return s.docs.forEach(g=>{const v=g.id;y.update(m(d,"items",v),{project_id:t,inventory_status:"allocated",transaction_id:r,disposition:"keep",last_updated:new Date().toISOString()})}),await y.commit(),r},async returnItemFromProject(a,t,n,e){await b();const o=await this.getItemById(a);if(!o)throw new Error("Item not found");const s=n||o.project_price||o.market_value||"0.00",r=o.transaction_id||null;console.log("🔄 Starting return process:",{itemId:a,projectId:t,currentTransactionId:r,itemProjectId:o.project_id,finalAmount:s});try{await I.logAllocationEvent("return",a,o.project_id,r,{action:"return_started",target_project_id:t,current_transaction_id:r,amount:s})}catch(i){console.warn("⚠️ Failed to log return start:",i)}return r!=null&&r.startsWith("INV_PURCHASE_")&&r.replace("INV_PURCHASE_","")===t?(console.log("📋 Return Scenario: Item in Purchase, returning from same project"),await this.handleReturnFromPurchase(a,r,t,s,e)):(console.log("📋 Return Scenario: Item not in transaction or new return"),await this.handleNewReturn(a,t,s,e))},async handleReturnFromPurchase(a,t,n,e,o){await this.removeItemFromTransaction(a,t,e);const s=`INV_SALE_${t.replace("INV_PURCHASE_","")}`;await this.addItemToTransaction(a,s,e,"To Inventory","Inventory sale",o),await this.updateItem(a,{project_id:null,inventory_status:"available",transaction_id:s,disposition:"inventory"}),console.log("✅ Return completed: Purchase → Sale (same project)");try{await I.logAllocationEvent("return",a,null,s,{action:"return_completed",scenario:"return_from_purchase",from_transaction:t,to_transaction:s,amount:e})}catch(r){console.warn("⚠️ Failed to log return completion:",r)}return s},async handleNewReturn(a,t,n,e){let o="Other";try{const c=await O.getProject(t);o=(c==null?void 0:c.name)||"Other"}catch(c){console.warn("Could not fetch project name for transaction source:",c)}const s=`INV_SALE_${t}`,r={project_id:t,project_name:null,transaction_date:k(new Date),source:o,transaction_type:"To Inventory",payment_method:"Pending",amount:n,budget_category:"Furnishings",notes:e||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:"We Owe",trigger_event:"Inventory sale",item_ids:[a],created_by:"system",created_at:new Date().toISOString(),last_updated:new Date().toISOString()},i=m(d,"transactions",s);await C(i,r,{merge:!0}),await this.updateItem(a,{project_id:null,inventory_status:"available",transaction_id:s,disposition:"inventory"}),console.log("✅ New return completed: Inventory → Sale");try{await I.logAllocationEvent("return",a,null,s,{action:"return_completed",scenario:"new_return",from_status:"inventory",to_transaction:s,amount:n})}catch(c){console.warn("⚠️ Failed to log return completion:",c)}return s},async completePendingTransaction(a,t,n){await b();const e=a==="sale"?`INV_SALE_${t}`:`INV_PURCHASE_${t}`,o=m(d,"transactions",e),s=await R(o);if(!s.exists())throw new Error("Transaction not found");const i=s.data().item_ids||[];await D(o,{status:"completed",payment_method:n,transaction_date:k(new Date),last_updated:new Date().toISOString()});const c=B(d);for(const _ of i){const y=m(d,"items",_);a==="sale"?c.update(y,{transaction_id:null,inventory_status:"sold",last_updated:new Date().toISOString()}):c.update(y,{project_id:null,transaction_id:null,inventory_status:"available",last_updated:new Date().toISOString()})}await c.commit()},async getItemById(a){await b();const t=m(d,"items",a),n=await R(t);return n.exists()?{item_id:n.id,...n.data()}:null},async duplicateItem(a,t){const n=await this.getItemById(t);if(!n)throw new Error("Original item not found");const e=new Date,o=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,s=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,r={item_id:o,description:n.description,source:n.source,sku:n.sku||"",purchase_price:n.purchase_price||"",project_price:n.project_price||"",market_value:n.market_value||"",payment_method:n.payment_method,disposition:"keep",notes:n.notes||"",space:n.space||"",qr_key:s,bookmark:!1,transaction_id:n.transaction_id,project_id:a,date_created:e.toISOString(),last_updated:e.toISOString(),images:n.images||[]};Object.keys(r).forEach(c=>{r[c]===void 0&&delete r[c]});const i=m(d,"items",o);return await C(i,r),o},async createTransactionItems(a,t,n,e,o){const s=B(d),r=[],i=new Date;return o.forEach(c=>{const _=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`;r.push(_);const y=m(d,"items",_),g=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,v={item_id:_,description:c.description,source:e,sku:c.sku||"",purchase_price:c.purchase_price,project_price:c.project_price,market_value:c.market_value||"",payment_method:"Client Card",disposition:"keep",notes:c.notes||"",qr_key:g,bookmark:!1,transaction_id:t,project_id:a,date_created:n,last_updated:i.toISOString(),images:[]};s.set(y,v)}),await s.commit(),r}},K={async getBusinessInventoryItems(a,t){const n=p(d,"business_inventory");let e=l(n);a!=null&&a.status&&(e=l(e,u("inventory_status","==",a.status))),e=l(e,j("last_updated","desc")),t&&(e=l(e,L(t.limit)),t.page>0&&(e=l(e,L(t.page*t.limit))));let s=(await f(e)).docs.map(r=>({item_id:r.id,...r.data()}));if(a!=null&&a.searchQuery){const r=a.searchQuery.toLowerCase();s=s.filter(i=>{var c;return i.description.toLowerCase().includes(r)||i.source.toLowerCase().includes(r)||i.sku.toLowerCase().includes(r)||((c=i.business_inventory_location)==null?void 0:c.toLowerCase().includes(r))})}return s},async getBusinessInventoryItem(a){const t=m(d,"business_inventory",a),n=await R(t);return n.exists()?{item_id:n.id,...n.data()}:null},async duplicateBusinessInventoryItem(a){const t=await this.getBusinessInventoryItem(a);if(!t)throw new Error("Original business inventory item not found");const n=new Date,e=`BI-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,o=`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,s={item_id:e,description:t.description,source:t.source,sku:t.sku||"",purchase_price:t.purchase_price||"",project_price:t.project_price||"",market_value:t.market_value||"",payment_method:t.payment_method,disposition:"keep",notes:t.notes||"",space:t.space||"",qr_key:o,bookmark:!1,inventory_status:"available",business_inventory_location:t.business_inventory_location||"",transaction_id:t.transaction_id,date_created:n.toISOString(),last_updated:n.toISOString(),images:t.images||[]};Object.keys(s).forEach(i=>{s[i]===void 0&&delete s[i]});const r=m(d,"business_inventory",e);return await C(r,s),e},async createBusinessInventoryItem(a){const t=p(d,"business_inventory"),n=new Date,e={...a,inventory_status:a.inventory_status||"available",date_created:n.toISOString(),last_updated:n.toISOString()};return(await E(t,e)).id},async updateBusinessInventoryItem(a,t){const n=m(d,"business_inventory",a),e={last_updated:new Date().toISOString()};t.inventory_status!==void 0&&(e.inventory_status=t.inventory_status),t.business_inventory_location!==void 0&&(e.business_inventory_location=t.business_inventory_location),t.purchase_price!==void 0&&(e.purchase_price=t.purchase_price),t.project_price!==void 0&&(e.project_price=t.project_price),t.description!==void 0&&(e.description=t.description),t.source!==void 0&&(e.source=t.source),t.sku!==void 0&&(e.sku=t.sku),t.market_value!==void 0&&(e.market_value=t.market_value),t.payment_method!==void 0&&(e.payment_method=t.payment_method),t.disposition!==void 0&&(e.disposition=t.disposition),t.notes!==void 0&&(e.notes=t.notes),t.space!==void 0&&(e.space=t.space),t.bookmark!==void 0&&(e.bookmark=t.bookmark),t.images!==void 0&&(e.images=t.images),await D(n,e)},async deleteBusinessInventoryItem(a){const t=m(d,"business_inventory",a);await q(t)},async getBusinessInventoryStats(){const a=p(d,"business_inventory"),t=await H(a),n=l(a),e=await f(n);let o=0,s=0,r=0;return e.docs.forEach(i=>{switch(i.data().inventory_status){case"available":o++;break;case"pending":s++;break;case"sold":r++;break}}),{totalItems:t.data().count,availableItems:o,pendingItems:s,soldItems:r}},subscribeToBusinessInventory(a,t){const n=p(d,"business_inventory");let e=l(n,j("last_updated","desc"));return t!=null&&t.status&&(e=l(e,u("inventory_status","==",t.status))),N(e,o=>{let s=o.docs.map(r=>({item_id:r.id,...r.data()}));if(t!=null&&t.searchQuery){const r=t.searchQuery.toLowerCase();s=s.filter(i=>{var c;return i.description.toLowerCase().includes(r)||i.source.toLowerCase().includes(r)||i.sku.toLowerCase().includes(r)||((c=i.business_inventory_location)==null?void 0:c.toLowerCase().includes(r))})}a(s)})},async allocateItemToProject(a,t,n,e){const o=await this.getBusinessInventoryItem(a);if(!o)throw new Error("Business inventory item not found");const s=n||o.project_price||o.market_value||"0.00";let r="Project";try{const y=await O.getProject(t);r=(y==null?void 0:y.name)||"Project"}catch(y){console.warn("Could not fetch project name for transaction notes:",y)}const i={project_id:t,transaction_date:k(new Date),source:"Inventory",transaction_type:"Purchase",payment_method:"Pending",amount:s,budget_category:"Furnishings",notes:e||`${r} inventory purchase`,created_by:"system",status:"pending",reimbursement_type:"Client Owes",trigger_event:"Inventory allocation"},c=p(d,"projects",t,"transactions"),_=await E(c,i);return await this.updateBusinessInventoryItem(a,{inventory_status:"allocated",transaction_id:_.id}),_.id},async batchAllocateItemsToProject(a,t,n={}){const e=B(d),o=[],s=new Date,r=p(d,"business_inventory"),i=l(r,u("__name__","in",a)),c=await f(i);if(c.empty)throw new Error("No business inventory items found");let _="Project";try{const h=await O.getProject(t);_=(h==null?void 0:h.name)||"Project"}catch(h){console.warn("Could not fetch project name for transaction notes:",h)}const y={project_id:t,transaction_date:k(s),source:"Inventory",transaction_type:"Purchase",payment_method:"Pending",amount:n.amount||"0.00",budget_category:"Furnishings",notes:n.notes||`${_} inventory purchase`,created_by:"system",status:"pending",reimbursement_type:"Client Owes",trigger_event:"Inventory allocation"},g=p(d,"projects",t,"transactions"),v=m(g);e.set(v,y),o.push(v.id),c.docs.forEach(h=>{const w=h.data(),T=`I-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,$=m(d,"projects",t,"items",T),M={item_id:T,description:w.description,source:w.source,sku:w.sku,project_price:w.project_price,market_value:w.market_value||"",payment_method:"1584",disposition:"keep",notes:w.notes||"",space:n.space||"",qr_key:`QR-${Date.now()}-${Math.random().toString(36).substr(2,4)}`,bookmark:!1,transaction_id:v.id,project_id:t,date_created:w.date_created,last_updated:s.toISOString(),images:w.images||[]};e.set($,M)}),a.forEach(h=>{const w=m(d,"business_inventory",h);e.update(w,{inventory_status:"sold",transaction_id:v.id,last_updated:s.toISOString()})}),await e.commit();const A=(await F.getItemsByProject(t)).length;return await O.updateProject(t,{metadata:{totalItems:A,lastActivity:s}}),o},async returnItemFromProject(a,t,n){const e=m(d,"projects",n,"transactions",t);await D(e,{status:"cancelled",last_updated:new Date().toISOString()}),await this.updateBusinessInventoryItem(a,{inventory_status:"available",transaction_id:void 0})},async markItemAsSold(a,t,n,e){const o=m(d,"projects",n,"transactions",t);await D(o,{status:"completed",transaction_date:k(new Date),payment_method:e,last_updated:new Date().toISOString()}),await this.updateBusinessInventoryItem(a,{inventory_status:"sold",transaction_id:void 0})},async moveItemToBusinessInventory(a,t,n,e){const o=p(d,"projects",t,"items"),s=l(o,u("item_id","==",a)),r=await f(s);if(r.empty)throw new Error("Item not found in project");const i=r.docs[0].data(),c={project_id:t,transaction_date:k(new Date),source:"Client Purchase",transaction_type:"Purchase",payment_method:"Pending",amount:n,budget_category:"Furnishings",notes:e||"Client-purchased item moved to business inventory",created_by:"system",status:"pending",reimbursement_type:"We Owe",trigger_event:"Purchase from client"},_=p(d,"projects",t,"transactions"),y=await E(_,c),g={description:i.description,source:i.source,sku:i.sku,price:i.price,market_value:i.market_value,payment_method:i.payment_method,disposition:i.disposition||"keep",notes:i.notes,space:i.space,qr_key:i.qr_key,bookmark:i.bookmark||!1,inventory_status:"available",business_inventory_location:"Warehouse - Client Purchase",transaction_id:y.id,images:i.images||[]};return await this.createBusinessInventoryItem(g),await q(r.docs[0].ref),y.id}},V={async handleInventoryDesignation(a,t,n){if(console.log("🔄 handleInventoryDesignation called:",{itemId:a,projectId:t,disposition:n}),n!=="inventory"){console.log("⏭️ Skipping - disposition is not inventory:",n);return}try{console.log("🔍 Getting item details for:",a);const e=await F.getItemById(a);if(!e)throw new Error("Item not found");console.log("✅ Item found:",e.item_id,"disposition:",e.disposition,"project_id:",e.project_id),console.log("🏦 Creating/updating Sale transaction for inventory designation");try{await I.logAllocationEvent("deallocation",a,e.project_id,e.transaction_id,{action:"deallocation_started",target_status:"inventory",current_transaction_id:e.transaction_id})}catch(s){console.warn("⚠️ Failed to log deallocation start:",s)}const o=await this.ensureSaleTransaction(e,t,"Transaction for items purchased from project and moved to business inventory");console.log("📦 Moving item to business inventory..."),await F.updateItem(e.item_id,{project_id:null,inventory_status:"available",transaction_id:o,last_updated:new Date().toISOString()});try{await I.logAllocationEvent("deallocation",a,null,o,{action:"deallocation_completed",from_project_id:e.project_id,to_transaction:o,amount:e.project_price||e.market_value||"0.00"})}catch(s){console.warn("⚠️ Failed to log deallocation completion:",s)}console.log("✅ Item moved to business inventory successfully"),console.log("✅ Deallocation completed successfully")}catch(e){throw console.error("❌ Error handling inventory designation:",e),e}},async ensureSaleTransaction(a,t,n){console.log("🏦 Creating/updating sale transaction for item:",a.item_id);let e="Other";try{const i=await O.getProject(t);e=(i==null?void 0:i.name)||"Other"}catch(i){console.warn("Could not fetch project name for transaction source:",i)}const o=`INV_SALE_${t}`;console.log("🔑 Canonical transaction ID:",o);const s=m(d,"transactions",o),r=await R(s);if(r.exists()){console.log("📋 Existing INV_SALE transaction found, updating with new item");const i=r.data(),c=i.item_ids||[],_=[...new Set([...c,a.item_id])],y=p(d,"items"),g=l(y,u("__name__","in",_)),S=(await f(g)).docs.map(h=>h.data().project_price||h.data().market_value||"0.00").reduce((h,w)=>h+parseFloat(w||"0"),0).toFixed(2),A={...i,item_ids:_,amount:S,notes:n||"Transaction for items purchased from project and moved to business inventory",last_updated:new Date().toISOString()};await C(s,A,{merge:!0}),console.log("🔄 Updated INV_SALE transaction with",_.length,"items, amount:",S)}else{const i=a.project_price||a.market_value||"0.00",c={project_id:t,project_name:null,transaction_date:k(new Date),source:e,transaction_type:"To Inventory",payment_method:"Pending",amount:parseFloat(i).toFixed(2),budget_category:"Furnishings",notes:n||"Transaction for items purchased from project and moved to business inventory",status:"pending",reimbursement_type:"We Owe",trigger_event:"Inventory sale",item_ids:[a.item_id],created_by:"system",created_at:new Date().toISOString(),last_updated:new Date().toISOString()};console.log("🆕 Creating new INV_SALE transaction with amount:",c.amount),await C(s,c,{merge:!0})}return console.log("✅ Sale transaction created/updated successfully"),o}},z={async allocateBusinessInventoryToProject(a,t,n,e){return await F.allocateItemToProject(a,t,n,e)},async returnItemToBusinessInventory(a,t,n){await F.returnItemFromProject(a,n)},async completePendingTransaction(a,t,n,e){return await F.completePendingTransaction("sale",n,e)},async handleItemDeallocation(a,t,n){return await V.handleInventoryDesignation(a,t,n)}},Z=Object.freeze(Object.defineProperty({__proto__:null,auditService:I,businessInventoryService:K,deallocationService:V,integrationService:z,projectService:O,transactionService:W,unifiedItemsService:F},Symbol.toStringTag,{value:"Module"}));export{X as a,k as b,K as c,Z as d,J as f,z as i,O as p,W as t,F as u};
//# sourceMappingURL=inventoryService.js.map
